// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mw.internal.robotics.gazebotransport.CoSimMsgs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[60]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
namespace mw {
namespace internal {
namespace robotics {
namespace gazebotransport {
class ApplyJointTorque;
class ApplyJointTorqueDefaultTypeInternal;
extern ApplyJointTorqueDefaultTypeInternal _ApplyJointTorque_default_instance_;
class ApplyLinkWrench;
class ApplyLinkWrenchDefaultTypeInternal;
extern ApplyLinkWrenchDefaultTypeInternal _ApplyLinkWrench_default_instance_;
class Axis;
class AxisDefaultTypeInternal;
extern AxisDefaultTypeInternal _Axis_default_instance_;
class CustomMessageSupport;
class CustomMessageSupportDefaultTypeInternal;
extern CustomMessageSupportDefaultTypeInternal _CustomMessageSupport_default_instance_;
class GazeboModelSDF;
class GazeboModelSDFDefaultTypeInternal;
extern GazeboModelSDFDefaultTypeInternal _GazeboModelSDF_default_instance_;
class Gazebomodel;
class GazebomodelDefaultTypeInternal;
extern GazebomodelDefaultTypeInternal _Gazebomodel_default_instance_;
class GetGazeboModelParam;
class GetGazeboModelParamDefaultTypeInternal;
extern GetGazeboModelParamDefaultTypeInternal _GetGazeboModelParam_default_instance_;
class GetGazeboModelSDF;
class GetGazeboModelSDFDefaultTypeInternal;
extern GetGazeboModelSDFDefaultTypeInternal _GetGazeboModelSDF_default_instance_;
class GetGroundTruthWorldPose;
class GetGroundTruthWorldPoseDefaultTypeInternal;
extern GetGroundTruthWorldPoseDefaultTypeInternal _GetGroundTruthWorldPose_default_instance_;
class GetJointState;
class GetJointStateDefaultTypeInternal;
extern GetJointStateDefaultTypeInternal _GetJointState_default_instance_;
class GetLinkState;
class GetLinkStateDefaultTypeInternal;
extern GetLinkStateDefaultTypeInternal _GetLinkState_default_instance_;
class GetModelInfo;
class GetModelInfoDefaultTypeInternal;
extern GetModelInfoDefaultTypeInternal _GetModelInfo_default_instance_;
class GetPose;
class GetPoseDefaultTypeInternal;
extern GetPoseDefaultTypeInternal _GetPose_default_instance_;
class GetTopicList;
class GetTopicListDefaultTypeInternal;
extern GetTopicListDefaultTypeInternal _GetTopicList_default_instance_;
class Image;
class ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class ImuData;
class ImuDataDefaultTypeInternal;
extern ImuDataDefaultTypeInternal _ImuData_default_instance_;
class InitCustomPublisher;
class InitCustomPublisherDefaultTypeInternal;
extern InitCustomPublisherDefaultTypeInternal _InitCustomPublisher_default_instance_;
class InitCustomSubscriber;
class InitCustomSubscriberDefaultTypeInternal;
extern InitCustomSubscriberDefaultTypeInternal _InitCustomSubscriber_default_instance_;
class JointState;
class JointStateDefaultTypeInternal;
extern JointStateDefaultTypeInternal _JointState_default_instance_;
class LaserData;
class LaserDataDefaultTypeInternal;
extern LaserDataDefaultTypeInternal _LaserData_default_instance_;
class LinkState;
class LinkStateDefaultTypeInternal;
extern LinkStateDefaultTypeInternal _LinkState_default_instance_;
class ML_Axis;
class ML_AxisDefaultTypeInternal;
extern ML_AxisDefaultTypeInternal _ML_Axis_default_instance_;
class ML_Cord;
class ML_CordDefaultTypeInternal;
extern ML_CordDefaultTypeInternal _ML_Cord_default_instance_;
class ML_Inertial;
class ML_InertialDefaultTypeInternal;
extern ML_InertialDefaultTypeInternal _ML_Inertial_default_instance_;
class ML_Joints;
class ML_JointsDefaultTypeInternal;
extern ML_JointsDefaultTypeInternal _ML_Joints_default_instance_;
class ML_Links;
class ML_LinksDefaultTypeInternal;
extern ML_LinksDefaultTypeInternal _ML_Links_default_instance_;
class ML_Point;
class ML_PointDefaultTypeInternal;
extern ML_PointDefaultTypeInternal _ML_Point_default_instance_;
class ML_Pose;
class ML_PoseDefaultTypeInternal;
extern ML_PoseDefaultTypeInternal _ML_Pose_default_instance_;
class ML_Quat;
class ML_QuatDefaultTypeInternal;
extern ML_QuatDefaultTypeInternal _ML_Quat_default_instance_;
class MaxStepSize;
class MaxStepSizeDefaultTypeInternal;
extern MaxStepSizeDefaultTypeInternal _MaxStepSize_default_instance_;
class ModelInfo;
class ModelInfoDefaultTypeInternal;
extern ModelInfoDefaultTypeInternal _ModelInfo_default_instance_;
class ModelInfo_JOINTS;
class ModelInfo_JOINTSDefaultTypeInternal;
extern ModelInfo_JOINTSDefaultTypeInternal _ModelInfo_JOINTS_default_instance_;
class ModelInfo_LINKS;
class ModelInfo_LINKSDefaultTypeInternal;
extern ModelInfo_LINKSDefaultTypeInternal _ModelInfo_LINKS_default_instance_;
class ModelInfo_Model;
class ModelInfo_ModelDefaultTypeInternal;
extern ModelInfo_ModelDefaultTypeInternal _ModelInfo_Model_default_instance_;
class Packet;
class PacketDefaultTypeInternal;
extern PacketDefaultTypeInternal _Packet_default_instance_;
class PacketHeader;
class PacketHeaderDefaultTypeInternal;
extern PacketHeaderDefaultTypeInternal _PacketHeader_default_instance_;
class PluginVersion;
class PluginVersionDefaultTypeInternal;
extern PluginVersionDefaultTypeInternal _PluginVersion_default_instance_;
class Point;
class PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class Pose;
class PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class Quaternion;
class QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class RequestCoSim;
class RequestCoSimDefaultTypeInternal;
extern RequestCoSimDefaultTypeInternal _RequestCoSim_default_instance_;
class RequestCustomMessageSupport;
class RequestCustomMessageSupportDefaultTypeInternal;
extern RequestCustomMessageSupportDefaultTypeInternal _RequestCustomMessageSupport_default_instance_;
class RequestImage;
class RequestImageDefaultTypeInternal;
extern RequestImageDefaultTypeInternal _RequestImage_default_instance_;
class RequestImu;
class RequestImuDefaultTypeInternal;
extern RequestImuDefaultTypeInternal _RequestImu_default_instance_;
class RequestLaser;
class RequestLaserDefaultTypeInternal;
extern RequestLaserDefaultTypeInternal _RequestLaser_default_instance_;
class ResetSimulation;
class ResetSimulationDefaultTypeInternal;
extern ResetSimulationDefaultTypeInternal _ResetSimulation_default_instance_;
class SetJointPosition;
class SetJointPositionDefaultTypeInternal;
extern SetJointPositionDefaultTypeInternal _SetJointPosition_default_instance_;
class SetJointVelocity;
class SetJointVelocityDefaultTypeInternal;
extern SetJointVelocityDefaultTypeInternal _SetJointVelocity_default_instance_;
class SetLinkAngularVelocity;
class SetLinkAngularVelocityDefaultTypeInternal;
extern SetLinkAngularVelocityDefaultTypeInternal _SetLinkAngularVelocity_default_instance_;
class SetLinkLinearVelocity;
class SetLinkLinearVelocityDefaultTypeInternal;
extern SetLinkLinearVelocityDefaultTypeInternal _SetLinkLinearVelocity_default_instance_;
class SetLinkWorldPose;
class SetLinkWorldPoseDefaultTypeInternal;
extern SetLinkWorldPoseDefaultTypeInternal _SetLinkWorldPose_default_instance_;
class StepSimulation;
class StepSimulationDefaultTypeInternal;
extern StepSimulationDefaultTypeInternal _StepSimulation_default_instance_;
class StopCoSim;
class StopCoSimDefaultTypeInternal;
extern StopCoSimDefaultTypeInternal _StopCoSim_default_instance_;
class StopSimulation;
class StopSimulationDefaultTypeInternal;
extern StopSimulationDefaultTypeInternal _StopSimulation_default_instance_;
class SubscribeImage;
class SubscribeImageDefaultTypeInternal;
extern SubscribeImageDefaultTypeInternal _SubscribeImage_default_instance_;
class SubscribeImu;
class SubscribeImuDefaultTypeInternal;
extern SubscribeImuDefaultTypeInternal _SubscribeImu_default_instance_;
class SubscribeLaser;
class SubscribeLaserDefaultTypeInternal;
extern SubscribeLaserDefaultTypeInternal _SubscribeLaser_default_instance_;
class Time;
class TimeDefaultTypeInternal;
extern TimeDefaultTypeInternal _Time_default_instance_;
class TopicList;
class TopicListDefaultTypeInternal;
extern TopicListDefaultTypeInternal _TopicList_default_instance_;
class TopicList_TopicInfo;
class TopicList_TopicInfoDefaultTypeInternal;
extern TopicList_TopicInfoDefaultTypeInternal _TopicList_TopicInfo_default_instance_;
}  // namespace gazebotransport
}  // namespace robotics
}  // namespace internal
}  // namespace mw
PROTOBUF_NAMESPACE_OPEN
template<> ::mw::internal::robotics::gazebotransport::ApplyJointTorque* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ApplyJointTorque>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ApplyLinkWrench>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::Axis* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Axis>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::CustomMessageSupport* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::CustomMessageSupport>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::GazeboModelSDF* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::GazeboModelSDF>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::Gazebomodel* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Gazebomodel>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::GetGazeboModelParam* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::GetGazeboModelParam>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::GetGazeboModelSDF>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::GetJointState* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::GetJointState>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::GetLinkState* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::GetLinkState>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::GetModelInfo* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::GetModelInfo>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::GetPose* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::GetPose>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::GetTopicList* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::GetTopicList>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::Image* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Image>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::ImuData* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ImuData>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::InitCustomPublisher* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::InitCustomPublisher>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::InitCustomSubscriber>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::JointState* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::JointState>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::LaserData* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::LaserData>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::LinkState* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::LinkState>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::ML_Axis* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ML_Axis>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::ML_Cord* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ML_Cord>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::ML_Inertial* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ML_Inertial>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::ML_Joints* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ML_Joints>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::ML_Links* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ML_Links>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::ML_Point* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ML_Point>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::ML_Pose* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ML_Pose>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::ML_Quat* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ML_Quat>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::MaxStepSize* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::MaxStepSize>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::ModelInfo* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ModelInfo>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ModelInfo_LINKS>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::ModelInfo_Model* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ModelInfo_Model>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::Packet* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Packet>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::PacketHeader* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::PacketHeader>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::PluginVersion* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::PluginVersion>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::Point* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Point>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::Pose* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Pose>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::Quaternion* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Quaternion>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::RequestCoSim* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::RequestCoSim>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::RequestImage* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::RequestImage>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::RequestImu* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::RequestImu>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::RequestLaser* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::RequestLaser>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::ResetSimulation* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ResetSimulation>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::SetJointPosition* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::SetJointPosition>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::SetJointVelocity* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::SetJointVelocity>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::SetLinkWorldPose>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::StepSimulation* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::StepSimulation>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::StopCoSim* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::StopCoSim>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::StopSimulation* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::StopSimulation>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::SubscribeImage* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::SubscribeImage>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::SubscribeImu* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::SubscribeImu>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::SubscribeLaser* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::SubscribeLaser>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::Time* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Time>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::TopicList* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::TopicList>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::TopicList_TopicInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mw {
namespace internal {
namespace robotics {
namespace gazebotransport {

enum PacketHeader_MsgID : int {
  PacketHeader_MsgID_STATUS = 0,
  PacketHeader_MsgID_STEP_SIMULATION = 1,
  PacketHeader_MsgID_RESET_SIMULATION = 2,
  PacketHeader_MsgID_IMAGE = 3,
  PacketHeader_MsgID_REQUEST_IMAGE = 4,
  PacketHeader_MsgID_REQUEST_COSIM = 5,
  PacketHeader_MsgID_STOP_COSIM = 6,
  PacketHeader_MsgID_GET_GROUND_TRUTH_WORLD_POSE = 7,
  PacketHeader_MsgID_POSE = 8,
  PacketHeader_MsgID_STOP_SIMULATION = 9,
  PacketHeader_MsgID_LASER_DATA = 10,
  PacketHeader_MsgID_REQUEST_LASER = 11,
  PacketHeader_MsgID_IMU_DATA = 12,
  PacketHeader_MsgID_REQUEST_IMU = 13,
  PacketHeader_MsgID_SUBSCRIBE_IMAGE = 14,
  PacketHeader_MsgID_SUBSCRIBE_LASER = 15,
  PacketHeader_MsgID_SUBSCRIBE_IMU = 16,
  PacketHeader_MsgID_APPLY_JOINT_TORQUE = 17,
  PacketHeader_MsgID_GET_POSE = 18,
  PacketHeader_MsgID_GET_TOPIC_LIST = 19,
  PacketHeader_MsgID_TOPIC_LIST = 20,
  PacketHeader_MsgID_GET_MODEL_INFO = 21,
  PacketHeader_MsgID_MODEL_INFO = 22,
  PacketHeader_MsgID_APPLY_LINK_WRENCH = 23,
  PacketHeader_MsgID_MAX_STEP_SIZE = 24,
  PacketHeader_MsgID_CUSTOM_MESSAGE_SUBSCRIBER = 25,
  PacketHeader_MsgID_CUSTOM_MESSAGE_PUBLISHER = 26,
  PacketHeader_MsgID_INIT_CUSTOM_MESSAGE_PUBLISHER = 27,
  PacketHeader_MsgID_INIT_CUSTOM_MESSAGE_SUBSCRIBER = 28,
  PacketHeader_MsgID_SET_JOINT_POSITION = 29,
  PacketHeader_MsgID_SET_JOINT_VELOCITY = 30,
  PacketHeader_MsgID_GET_JOINT_STATE = 31,
  PacketHeader_MsgID_JOINT_STATE = 32,
  PacketHeader_MsgID_SET_LINK_WORLD_POSE = 33,
  PacketHeader_MsgID_SET_LINK_LINEAR_VELOCITY = 34,
  PacketHeader_MsgID_SET_LINK_ANGULAR_VELOCITY = 35,
  PacketHeader_MsgID_GET_LINK_STATE = 36,
  PacketHeader_MsgID_LINK_STATE = 37,
  PacketHeader_MsgID_GAZEBO_MODEL = 38,
  PacketHeader_MsgID_SET_GAZEBO_MODEL_PARAM = 39,
  PacketHeader_MsgID_GET_GAZEBO_MODEL_PARAM = 40,
  PacketHeader_MsgID_GAZEBO_MODEL_SDF = 41,
  PacketHeader_MsgID_GET_GAZEBO_MODEL_SDF = 42
};
bool PacketHeader_MsgID_IsValid(int value);
constexpr PacketHeader_MsgID PacketHeader_MsgID_MsgID_MIN = PacketHeader_MsgID_STATUS;
constexpr PacketHeader_MsgID PacketHeader_MsgID_MsgID_MAX = PacketHeader_MsgID_GET_GAZEBO_MODEL_SDF;
constexpr int PacketHeader_MsgID_MsgID_ARRAYSIZE = PacketHeader_MsgID_MsgID_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PacketHeader_MsgID_descriptor();
template<typename T>
inline const std::string& PacketHeader_MsgID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PacketHeader_MsgID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PacketHeader_MsgID_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PacketHeader_MsgID_descriptor(), enum_t_value);
}
inline bool PacketHeader_MsgID_Parse(
    const std::string& name, PacketHeader_MsgID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PacketHeader_MsgID>(
    PacketHeader_MsgID_descriptor(), name, value);
}
enum Packet_CoSimError : int {
  Packet_CoSimError_NONE = 0,
  Packet_CoSimError_STEP_FAILED = 1,
  Packet_CoSimError_MSG_INVALID = 2,
  Packet_CoSimError_SOCKET_FAILED = 3,
  Packet_CoSimError_RESET_FAILED = 4,
  Packet_CoSimError_COSIM_FAILED = 5,
  Packet_CoSimError_STOP_COSIM_FAILED = 6,
  Packet_CoSimError_GET_GROUND_TRUTH_WORLD_POSE_FAILED = 7,
  Packet_CoSimError_RESET_TIME_SCENE_FAILED = 8,
  Packet_CoSimError_RESET_TIME_FAILED = 9,
  Packet_CoSimError_STOP_FAILED = 10,
  Packet_CoSimError_FORCE_TYPE_INVALID = 11,
  Packet_CoSimError_MODEL_NAME_INVALID = 12,
  Packet_CoSimError_LINK_NAME_INVALID = 13,
  Packet_CoSimError_JOINT_NAME_INVALID = 14,
  Packet_CoSimError_TOPIC_NAME_INVALID = 15,
  Packet_CoSimError_TORQUE_TYPE_INVALID = 16,
  Packet_CoSimError_MAX_STEP_SIZE_ERROR = 17,
  Packet_CoSimError_CUSTOM_MESSAGE_INVALID = 18,
  Packet_CoSimError_MESSAGE_TYPE_INVALID = 19,
  Packet_CoSimError_JOINT_AXIS_NONE = 20,
  Packet_CoSimError_INVALID_JOINT_AXIS = 21
};
bool Packet_CoSimError_IsValid(int value);
constexpr Packet_CoSimError Packet_CoSimError_CoSimError_MIN = Packet_CoSimError_NONE;
constexpr Packet_CoSimError Packet_CoSimError_CoSimError_MAX = Packet_CoSimError_INVALID_JOINT_AXIS;
constexpr int Packet_CoSimError_CoSimError_ARRAYSIZE = Packet_CoSimError_CoSimError_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Packet_CoSimError_descriptor();
template<typename T>
inline const std::string& Packet_CoSimError_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Packet_CoSimError>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Packet_CoSimError_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Packet_CoSimError_descriptor(), enum_t_value);
}
inline bool Packet_CoSimError_Parse(
    const std::string& name, Packet_CoSimError* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Packet_CoSimError>(
    Packet_CoSimError_descriptor(), name, value);
}
enum ResetSimulation_ResetBehavior : int {
  ResetSimulation_ResetBehavior_RESET_TIME = 0,
  ResetSimulation_ResetBehavior_RESET_TIME_AND_SCENE = 1
};
bool ResetSimulation_ResetBehavior_IsValid(int value);
constexpr ResetSimulation_ResetBehavior ResetSimulation_ResetBehavior_ResetBehavior_MIN = ResetSimulation_ResetBehavior_RESET_TIME;
constexpr ResetSimulation_ResetBehavior ResetSimulation_ResetBehavior_ResetBehavior_MAX = ResetSimulation_ResetBehavior_RESET_TIME_AND_SCENE;
constexpr int ResetSimulation_ResetBehavior_ResetBehavior_ARRAYSIZE = ResetSimulation_ResetBehavior_ResetBehavior_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResetSimulation_ResetBehavior_descriptor();
template<typename T>
inline const std::string& ResetSimulation_ResetBehavior_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResetSimulation_ResetBehavior>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResetSimulation_ResetBehavior_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResetSimulation_ResetBehavior_descriptor(), enum_t_value);
}
inline bool ResetSimulation_ResetBehavior_Parse(
    const std::string& name, ResetSimulation_ResetBehavior* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResetSimulation_ResetBehavior>(
    ResetSimulation_ResetBehavior_descriptor(), name, value);
}
enum MaxStepSize_TYPE : int {
  MaxStepSize_TYPE_SET_STEP_SIZE = 0,
  MaxStepSize_TYPE_GET_STEP_SIZE = 1
};
bool MaxStepSize_TYPE_IsValid(int value);
constexpr MaxStepSize_TYPE MaxStepSize_TYPE_TYPE_MIN = MaxStepSize_TYPE_SET_STEP_SIZE;
constexpr MaxStepSize_TYPE MaxStepSize_TYPE_TYPE_MAX = MaxStepSize_TYPE_GET_STEP_SIZE;
constexpr int MaxStepSize_TYPE_TYPE_ARRAYSIZE = MaxStepSize_TYPE_TYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MaxStepSize_TYPE_descriptor();
template<typename T>
inline const std::string& MaxStepSize_TYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MaxStepSize_TYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MaxStepSize_TYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MaxStepSize_TYPE_descriptor(), enum_t_value);
}
inline bool MaxStepSize_TYPE_Parse(
    const std::string& name, MaxStepSize_TYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MaxStepSize_TYPE>(
    MaxStepSize_TYPE_descriptor(), name, value);
}
enum JointState_Joint_Type : int {
  JointState_Joint_Type_REVOLUTE = 1,
  JointState_Joint_Type_REVOLUTE2 = 2,
  JointState_Joint_Type_PRISMATIC = 3,
  JointState_Joint_Type_UNIVERSAL = 4,
  JointState_Joint_Type_BALL = 5,
  JointState_Joint_Type_SCREW = 6,
  JointState_Joint_Type_GEARBOX = 7,
  JointState_Joint_Type_FIXED = 8
};
bool JointState_Joint_Type_IsValid(int value);
constexpr JointState_Joint_Type JointState_Joint_Type_Joint_Type_MIN = JointState_Joint_Type_REVOLUTE;
constexpr JointState_Joint_Type JointState_Joint_Type_Joint_Type_MAX = JointState_Joint_Type_FIXED;
constexpr int JointState_Joint_Type_Joint_Type_ARRAYSIZE = JointState_Joint_Type_Joint_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JointState_Joint_Type_descriptor();
template<typename T>
inline const std::string& JointState_Joint_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JointState_Joint_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JointState_Joint_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    JointState_Joint_Type_descriptor(), enum_t_value);
}
inline bool JointState_Joint_Type_Parse(
    const std::string& name, JointState_Joint_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<JointState_Joint_Type>(
    JointState_Joint_Type_descriptor(), name, value);
}
// ===================================================================

class PluginVersion PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.PluginVersion) */ {
 public:
  inline PluginVersion() : PluginVersion(nullptr) {};
  virtual ~PluginVersion();

  PluginVersion(const PluginVersion& from);
  PluginVersion(PluginVersion&& from) noexcept
    : PluginVersion() {
    *this = ::std::move(from);
  }

  inline PluginVersion& operator=(const PluginVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline PluginVersion& operator=(PluginVersion&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PluginVersion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PluginVersion* internal_default_instance() {
    return reinterpret_cast<const PluginVersion*>(
               &_PluginVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PluginVersion& a, PluginVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(PluginVersion* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PluginVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PluginVersion* New() const final {
    return CreateMaybeMessage<PluginVersion>(nullptr);
  }

  PluginVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PluginVersion>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PluginVersion& from);
  void MergeFrom(const PluginVersion& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PluginVersion* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.PluginVersion";
  }
  protected:
  explicit PluginVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
  };
  // required string version = 1 [default = "R2022b"];
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  void set_version(const std::string& value);
  void set_version(std::string&& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  std::string* mutable_version();
  std::string* release_version();
  void set_allocated_version(std::string* version);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_version();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_version(
      std::string* version);
  private:
  const std::string& _internal_version() const;
  void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.PluginVersion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  public:
  static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> _i_give_permission_to_break_this_code_default_version_;
  private:
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class Time PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.Time) */ {
 public:
  inline Time() : Time(nullptr) {};
  virtual ~Time();

  Time(const Time& from);
  Time(Time&& from) noexcept
    : Time() {
    *this = ::std::move(from);
  }

  inline Time& operator=(const Time& from) {
    CopyFrom(from);
    return *this;
  }
  inline Time& operator=(Time&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Time& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Time* internal_default_instance() {
    return reinterpret_cast<const Time*>(
               &_Time_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Time& a, Time& b) {
    a.Swap(&b);
  }
  inline void Swap(Time* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Time* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Time* New() const final {
    return CreateMaybeMessage<Time>(nullptr);
  }

  Time* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Time>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Time& from);
  void MergeFrom(const Time& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Time* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.Time";
  }
  protected:
  explicit Time(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecondsFieldNumber = 1,
    kNanoSecondsFieldNumber = 2,
  };
  // required uint64 seconds = 1;
  bool has_seconds() const;
  private:
  bool _internal_has_seconds() const;
  public:
  void clear_seconds();
  ::PROTOBUF_NAMESPACE_ID::uint64 seconds() const;
  void set_seconds(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_seconds() const;
  void _internal_set_seconds(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 nano_seconds = 2;
  bool has_nano_seconds() const;
  private:
  bool _internal_has_nano_seconds() const;
  public:
  void clear_nano_seconds();
  ::PROTOBUF_NAMESPACE_ID::uint64 nano_seconds() const;
  void set_nano_seconds(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_nano_seconds() const;
  void _internal_set_nano_seconds(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.Time)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 seconds_;
  ::PROTOBUF_NAMESPACE_ID::uint64 nano_seconds_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class PacketHeader PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.PacketHeader) */ {
 public:
  inline PacketHeader() : PacketHeader(nullptr) {};
  virtual ~PacketHeader();

  PacketHeader(const PacketHeader& from);
  PacketHeader(PacketHeader&& from) noexcept
    : PacketHeader() {
    *this = ::std::move(from);
  }

  inline PacketHeader& operator=(const PacketHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline PacketHeader& operator=(PacketHeader&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PacketHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PacketHeader* internal_default_instance() {
    return reinterpret_cast<const PacketHeader*>(
               &_PacketHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PacketHeader& a, PacketHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(PacketHeader* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PacketHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PacketHeader* New() const final {
    return CreateMaybeMessage<PacketHeader>(nullptr);
  }

  PacketHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PacketHeader>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PacketHeader& from);
  void MergeFrom(const PacketHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PacketHeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.PacketHeader";
  }
  protected:
  explicit PacketHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef PacketHeader_MsgID MsgID;
  static constexpr MsgID STATUS =
    PacketHeader_MsgID_STATUS;
  static constexpr MsgID STEP_SIMULATION =
    PacketHeader_MsgID_STEP_SIMULATION;
  static constexpr MsgID RESET_SIMULATION =
    PacketHeader_MsgID_RESET_SIMULATION;
  static constexpr MsgID IMAGE =
    PacketHeader_MsgID_IMAGE;
  static constexpr MsgID REQUEST_IMAGE =
    PacketHeader_MsgID_REQUEST_IMAGE;
  static constexpr MsgID REQUEST_COSIM =
    PacketHeader_MsgID_REQUEST_COSIM;
  static constexpr MsgID STOP_COSIM =
    PacketHeader_MsgID_STOP_COSIM;
  static constexpr MsgID GET_GROUND_TRUTH_WORLD_POSE =
    PacketHeader_MsgID_GET_GROUND_TRUTH_WORLD_POSE;
  static constexpr MsgID POSE =
    PacketHeader_MsgID_POSE;
  static constexpr MsgID STOP_SIMULATION =
    PacketHeader_MsgID_STOP_SIMULATION;
  static constexpr MsgID LASER_DATA =
    PacketHeader_MsgID_LASER_DATA;
  static constexpr MsgID REQUEST_LASER =
    PacketHeader_MsgID_REQUEST_LASER;
  static constexpr MsgID IMU_DATA =
    PacketHeader_MsgID_IMU_DATA;
  static constexpr MsgID REQUEST_IMU =
    PacketHeader_MsgID_REQUEST_IMU;
  static constexpr MsgID SUBSCRIBE_IMAGE =
    PacketHeader_MsgID_SUBSCRIBE_IMAGE;
  static constexpr MsgID SUBSCRIBE_LASER =
    PacketHeader_MsgID_SUBSCRIBE_LASER;
  static constexpr MsgID SUBSCRIBE_IMU =
    PacketHeader_MsgID_SUBSCRIBE_IMU;
  static constexpr MsgID APPLY_JOINT_TORQUE =
    PacketHeader_MsgID_APPLY_JOINT_TORQUE;
  static constexpr MsgID GET_POSE =
    PacketHeader_MsgID_GET_POSE;
  static constexpr MsgID GET_TOPIC_LIST =
    PacketHeader_MsgID_GET_TOPIC_LIST;
  static constexpr MsgID TOPIC_LIST =
    PacketHeader_MsgID_TOPIC_LIST;
  static constexpr MsgID GET_MODEL_INFO =
    PacketHeader_MsgID_GET_MODEL_INFO;
  static constexpr MsgID MODEL_INFO =
    PacketHeader_MsgID_MODEL_INFO;
  static constexpr MsgID APPLY_LINK_WRENCH =
    PacketHeader_MsgID_APPLY_LINK_WRENCH;
  static constexpr MsgID MAX_STEP_SIZE =
    PacketHeader_MsgID_MAX_STEP_SIZE;
  static constexpr MsgID CUSTOM_MESSAGE_SUBSCRIBER =
    PacketHeader_MsgID_CUSTOM_MESSAGE_SUBSCRIBER;
  static constexpr MsgID CUSTOM_MESSAGE_PUBLISHER =
    PacketHeader_MsgID_CUSTOM_MESSAGE_PUBLISHER;
  static constexpr MsgID INIT_CUSTOM_MESSAGE_PUBLISHER =
    PacketHeader_MsgID_INIT_CUSTOM_MESSAGE_PUBLISHER;
  static constexpr MsgID INIT_CUSTOM_MESSAGE_SUBSCRIBER =
    PacketHeader_MsgID_INIT_CUSTOM_MESSAGE_SUBSCRIBER;
  static constexpr MsgID SET_JOINT_POSITION =
    PacketHeader_MsgID_SET_JOINT_POSITION;
  static constexpr MsgID SET_JOINT_VELOCITY =
    PacketHeader_MsgID_SET_JOINT_VELOCITY;
  static constexpr MsgID GET_JOINT_STATE =
    PacketHeader_MsgID_GET_JOINT_STATE;
  static constexpr MsgID JOINT_STATE =
    PacketHeader_MsgID_JOINT_STATE;
  static constexpr MsgID SET_LINK_WORLD_POSE =
    PacketHeader_MsgID_SET_LINK_WORLD_POSE;
  static constexpr MsgID SET_LINK_LINEAR_VELOCITY =
    PacketHeader_MsgID_SET_LINK_LINEAR_VELOCITY;
  static constexpr MsgID SET_LINK_ANGULAR_VELOCITY =
    PacketHeader_MsgID_SET_LINK_ANGULAR_VELOCITY;
  static constexpr MsgID GET_LINK_STATE =
    PacketHeader_MsgID_GET_LINK_STATE;
  static constexpr MsgID LINK_STATE =
    PacketHeader_MsgID_LINK_STATE;
  static constexpr MsgID GAZEBO_MODEL =
    PacketHeader_MsgID_GAZEBO_MODEL;
  static constexpr MsgID SET_GAZEBO_MODEL_PARAM =
    PacketHeader_MsgID_SET_GAZEBO_MODEL_PARAM;
  static constexpr MsgID GET_GAZEBO_MODEL_PARAM =
    PacketHeader_MsgID_GET_GAZEBO_MODEL_PARAM;
  static constexpr MsgID GAZEBO_MODEL_SDF =
    PacketHeader_MsgID_GAZEBO_MODEL_SDF;
  static constexpr MsgID GET_GAZEBO_MODEL_SDF =
    PacketHeader_MsgID_GET_GAZEBO_MODEL_SDF;
  static inline bool MsgID_IsValid(int value) {
    return PacketHeader_MsgID_IsValid(value);
  }
  static constexpr MsgID MsgID_MIN =
    PacketHeader_MsgID_MsgID_MIN;
  static constexpr MsgID MsgID_MAX =
    PacketHeader_MsgID_MsgID_MAX;
  static constexpr int MsgID_ARRAYSIZE =
    PacketHeader_MsgID_MsgID_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MsgID_descriptor() {
    return PacketHeader_MsgID_descriptor();
  }
  template<typename T>
  static inline const std::string& MsgID_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgID>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgID_Name.");
    return PacketHeader_MsgID_Name(enum_t_value);
  }
  static inline bool MsgID_Parse(const std::string& name,
      MsgID* value) {
    return PacketHeader_MsgID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimeStampFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // required .mw.internal.robotics.gazebotransport.Time time_stamp = 2;
  bool has_time_stamp() const;
  private:
  bool _internal_has_time_stamp() const;
  public:
  void clear_time_stamp();
  const ::mw::internal::robotics::gazebotransport::Time& time_stamp() const;
  ::mw::internal::robotics::gazebotransport::Time* release_time_stamp();
  ::mw::internal::robotics::gazebotransport::Time* mutable_time_stamp();
  void set_allocated_time_stamp(::mw::internal::robotics::gazebotransport::Time* time_stamp);
  private:
  const ::mw::internal::robotics::gazebotransport::Time& _internal_time_stamp() const;
  ::mw::internal::robotics::gazebotransport::Time* _internal_mutable_time_stamp();
  public:
  void unsafe_arena_set_allocated_time_stamp(
      ::mw::internal::robotics::gazebotransport::Time* time_stamp);
  ::mw::internal::robotics::gazebotransport::Time* unsafe_arena_release_time_stamp();

  // required .mw.internal.robotics.gazebotransport.PacketHeader.MsgID id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::mw::internal::robotics::gazebotransport::PacketHeader_MsgID id() const;
  void set_id(::mw::internal::robotics::gazebotransport::PacketHeader_MsgID value);
  private:
  ::mw::internal::robotics::gazebotransport::PacketHeader_MsgID _internal_id() const;
  void _internal_set_id(::mw::internal::robotics::gazebotransport::PacketHeader_MsgID value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.PacketHeader)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::mw::internal::robotics::gazebotransport::Time* time_stamp_;
  int id_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class Packet PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.Packet) */ {
 public:
  inline Packet() : Packet(nullptr) {};
  virtual ~Packet();

  Packet(const Packet& from);
  Packet(Packet&& from) noexcept
    : Packet() {
    *this = ::std::move(from);
  }

  inline Packet& operator=(const Packet& from) {
    CopyFrom(from);
    return *this;
  }
  inline Packet& operator=(Packet&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Packet& default_instance();

  enum PayloadCase {
    kStatus = 2,
    kStepSimulation = 3,
    kResetSimulation = 4,
    kImage = 5,
    kRequestImage = 6,
    kRequestCosim = 7,
    kStopCosim = 8,
    kGetGroundTruthWorldPose = 9,
    kPose = 10,
    kStopSimulation = 11,
    kLaserData = 12,
    kRequestLaser = 13,
    kImuData = 14,
    kRequestImu = 15,
    kSubscribeImage = 16,
    kSubscribeLaser = 17,
    kSubscribeImu = 18,
    kApplyJointTorque = 19,
    kGetPose = 20,
    kGetTopicList = 21,
    kTopicList = 22,
    kGetModelInfo = 23,
    kModelInfo = 24,
    kApplyLinkWrench = 25,
    kMaxStepSize = 26,
    kCustomMessageSupport = 27,
    kInitCustomPublisher = 28,
    kInitCustomSubscriber = 29,
    kRequestCustomMessageSupport = 30,
    kSetJointPosition = 31,
    kSetJointVelocity = 32,
    kGetJointState = 33,
    kJointState = 34,
    kSetLinkWorldPose = 35,
    kSetLinkLinearVelocity = 36,
    kSetLinkAngularVelocity = 37,
    kGetLinkState = 38,
    kLinkState = 39,
    kGazeboModel = 40,
    kGetGazeboModelParam = 41,
    kGazeboModelSdf = 42,
    kGetGazeboModelSdf = 43,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Packet* internal_default_instance() {
    return reinterpret_cast<const Packet*>(
               &_Packet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Packet& a, Packet& b) {
    a.Swap(&b);
  }
  inline void Swap(Packet* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Packet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Packet* New() const final {
    return CreateMaybeMessage<Packet>(nullptr);
  }

  Packet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Packet>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Packet& from);
  void MergeFrom(const Packet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Packet* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.Packet";
  }
  protected:
  explicit Packet(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Packet_CoSimError CoSimError;
  static constexpr CoSimError NONE =
    Packet_CoSimError_NONE;
  static constexpr CoSimError STEP_FAILED =
    Packet_CoSimError_STEP_FAILED;
  static constexpr CoSimError MSG_INVALID =
    Packet_CoSimError_MSG_INVALID;
  static constexpr CoSimError SOCKET_FAILED =
    Packet_CoSimError_SOCKET_FAILED;
  static constexpr CoSimError RESET_FAILED =
    Packet_CoSimError_RESET_FAILED;
  static constexpr CoSimError COSIM_FAILED =
    Packet_CoSimError_COSIM_FAILED;
  static constexpr CoSimError STOP_COSIM_FAILED =
    Packet_CoSimError_STOP_COSIM_FAILED;
  static constexpr CoSimError GET_GROUND_TRUTH_WORLD_POSE_FAILED =
    Packet_CoSimError_GET_GROUND_TRUTH_WORLD_POSE_FAILED;
  static constexpr CoSimError RESET_TIME_SCENE_FAILED =
    Packet_CoSimError_RESET_TIME_SCENE_FAILED;
  static constexpr CoSimError RESET_TIME_FAILED =
    Packet_CoSimError_RESET_TIME_FAILED;
  static constexpr CoSimError STOP_FAILED =
    Packet_CoSimError_STOP_FAILED;
  static constexpr CoSimError FORCE_TYPE_INVALID =
    Packet_CoSimError_FORCE_TYPE_INVALID;
  static constexpr CoSimError MODEL_NAME_INVALID =
    Packet_CoSimError_MODEL_NAME_INVALID;
  static constexpr CoSimError LINK_NAME_INVALID =
    Packet_CoSimError_LINK_NAME_INVALID;
  static constexpr CoSimError JOINT_NAME_INVALID =
    Packet_CoSimError_JOINT_NAME_INVALID;
  static constexpr CoSimError TOPIC_NAME_INVALID =
    Packet_CoSimError_TOPIC_NAME_INVALID;
  static constexpr CoSimError TORQUE_TYPE_INVALID =
    Packet_CoSimError_TORQUE_TYPE_INVALID;
  static constexpr CoSimError MAX_STEP_SIZE_ERROR =
    Packet_CoSimError_MAX_STEP_SIZE_ERROR;
  static constexpr CoSimError CUSTOM_MESSAGE_INVALID =
    Packet_CoSimError_CUSTOM_MESSAGE_INVALID;
  static constexpr CoSimError MESSAGE_TYPE_INVALID =
    Packet_CoSimError_MESSAGE_TYPE_INVALID;
  static constexpr CoSimError JOINT_AXIS_NONE =
    Packet_CoSimError_JOINT_AXIS_NONE;
  static constexpr CoSimError INVALID_JOINT_AXIS =
    Packet_CoSimError_INVALID_JOINT_AXIS;
  static inline bool CoSimError_IsValid(int value) {
    return Packet_CoSimError_IsValid(value);
  }
  static constexpr CoSimError CoSimError_MIN =
    Packet_CoSimError_CoSimError_MIN;
  static constexpr CoSimError CoSimError_MAX =
    Packet_CoSimError_CoSimError_MAX;
  static constexpr int CoSimError_ARRAYSIZE =
    Packet_CoSimError_CoSimError_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CoSimError_descriptor() {
    return Packet_CoSimError_descriptor();
  }
  template<typename T>
  static inline const std::string& CoSimError_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CoSimError>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CoSimError_Name.");
    return Packet_CoSimError_Name(enum_t_value);
  }
  static inline bool CoSimError_Parse(const std::string& name,
      CoSimError* value) {
    return Packet_CoSimError_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 44,
    kHeaderFieldNumber = 1,
    kIsNewReadingFieldNumber = 45,
    kStatusFieldNumber = 2,
    kStepSimulationFieldNumber = 3,
    kResetSimulationFieldNumber = 4,
    kImageFieldNumber = 5,
    kRequestImageFieldNumber = 6,
    kRequestCosimFieldNumber = 7,
    kStopCosimFieldNumber = 8,
    kGetGroundTruthWorldPoseFieldNumber = 9,
    kPoseFieldNumber = 10,
    kStopSimulationFieldNumber = 11,
    kLaserDataFieldNumber = 12,
    kRequestLaserFieldNumber = 13,
    kImuDataFieldNumber = 14,
    kRequestImuFieldNumber = 15,
    kSubscribeImageFieldNumber = 16,
    kSubscribeLaserFieldNumber = 17,
    kSubscribeImuFieldNumber = 18,
    kApplyJointTorqueFieldNumber = 19,
    kGetPoseFieldNumber = 20,
    kGetTopicListFieldNumber = 21,
    kTopicListFieldNumber = 22,
    kGetModelInfoFieldNumber = 23,
    kModelInfoFieldNumber = 24,
    kApplyLinkWrenchFieldNumber = 25,
    kMaxStepSizeFieldNumber = 26,
    kCustomMessageSupportFieldNumber = 27,
    kInitCustomPublisherFieldNumber = 28,
    kInitCustomSubscriberFieldNumber = 29,
    kRequestCustomMessageSupportFieldNumber = 30,
    kSetJointPositionFieldNumber = 31,
    kSetJointVelocityFieldNumber = 32,
    kGetJointStateFieldNumber = 33,
    kJointStateFieldNumber = 34,
    kSetLinkWorldPoseFieldNumber = 35,
    kSetLinkLinearVelocityFieldNumber = 36,
    kSetLinkAngularVelocityFieldNumber = 37,
    kGetLinkStateFieldNumber = 38,
    kLinkStateFieldNumber = 39,
    kGazeboModelFieldNumber = 40,
    kGetGazeboModelParamFieldNumber = 41,
    kGazeboModelSdfFieldNumber = 42,
    kGetGazeboModelSdfFieldNumber = 43,
  };
  // optional string error_message = 44;
  bool has_error_message() const;
  private:
  bool _internal_has_error_message() const;
  public:
  void clear_error_message();
  const std::string& error_message() const;
  void set_error_message(const std::string& value);
  void set_error_message(std::string&& value);
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  std::string* mutable_error_message();
  std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_error_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_error_message(
      std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // required .mw.internal.robotics.gazebotransport.PacketHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::mw::internal::robotics::gazebotransport::PacketHeader& header() const;
  ::mw::internal::robotics::gazebotransport::PacketHeader* release_header();
  ::mw::internal::robotics::gazebotransport::PacketHeader* mutable_header();
  void set_allocated_header(::mw::internal::robotics::gazebotransport::PacketHeader* header);
  private:
  const ::mw::internal::robotics::gazebotransport::PacketHeader& _internal_header() const;
  ::mw::internal::robotics::gazebotransport::PacketHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::mw::internal::robotics::gazebotransport::PacketHeader* header);
  ::mw::internal::robotics::gazebotransport::PacketHeader* unsafe_arena_release_header();

  // optional bool is_new_reading = 45;
  bool has_is_new_reading() const;
  private:
  bool _internal_has_is_new_reading() const;
  public:
  void clear_is_new_reading();
  bool is_new_reading() const;
  void set_is_new_reading(bool value);
  private:
  bool _internal_is_new_reading() const;
  void _internal_set_is_new_reading(bool value);
  public:

  // .mw.internal.robotics.gazebotransport.Packet.CoSimError status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::mw::internal::robotics::gazebotransport::Packet_CoSimError status() const;
  void set_status(::mw::internal::robotics::gazebotransport::Packet_CoSimError value);
  private:
  ::mw::internal::robotics::gazebotransport::Packet_CoSimError _internal_status() const;
  void _internal_set_status(::mw::internal::robotics::gazebotransport::Packet_CoSimError value);
  public:

  // .mw.internal.robotics.gazebotransport.StepSimulation step_simulation = 3;
  bool has_step_simulation() const;
  private:
  bool _internal_has_step_simulation() const;
  public:
  void clear_step_simulation();
  const ::mw::internal::robotics::gazebotransport::StepSimulation& step_simulation() const;
  ::mw::internal::robotics::gazebotransport::StepSimulation* release_step_simulation();
  ::mw::internal::robotics::gazebotransport::StepSimulation* mutable_step_simulation();
  void set_allocated_step_simulation(::mw::internal::robotics::gazebotransport::StepSimulation* step_simulation);
  private:
  const ::mw::internal::robotics::gazebotransport::StepSimulation& _internal_step_simulation() const;
  ::mw::internal::robotics::gazebotransport::StepSimulation* _internal_mutable_step_simulation();
  public:
  void unsafe_arena_set_allocated_step_simulation(
      ::mw::internal::robotics::gazebotransport::StepSimulation* step_simulation);
  ::mw::internal::robotics::gazebotransport::StepSimulation* unsafe_arena_release_step_simulation();

  // .mw.internal.robotics.gazebotransport.ResetSimulation reset_simulation = 4;
  bool has_reset_simulation() const;
  private:
  bool _internal_has_reset_simulation() const;
  public:
  void clear_reset_simulation();
  const ::mw::internal::robotics::gazebotransport::ResetSimulation& reset_simulation() const;
  ::mw::internal::robotics::gazebotransport::ResetSimulation* release_reset_simulation();
  ::mw::internal::robotics::gazebotransport::ResetSimulation* mutable_reset_simulation();
  void set_allocated_reset_simulation(::mw::internal::robotics::gazebotransport::ResetSimulation* reset_simulation);
  private:
  const ::mw::internal::robotics::gazebotransport::ResetSimulation& _internal_reset_simulation() const;
  ::mw::internal::robotics::gazebotransport::ResetSimulation* _internal_mutable_reset_simulation();
  public:
  void unsafe_arena_set_allocated_reset_simulation(
      ::mw::internal::robotics::gazebotransport::ResetSimulation* reset_simulation);
  ::mw::internal::robotics::gazebotransport::ResetSimulation* unsafe_arena_release_reset_simulation();

  // .mw.internal.robotics.gazebotransport.Image image = 5;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::mw::internal::robotics::gazebotransport::Image& image() const;
  ::mw::internal::robotics::gazebotransport::Image* release_image();
  ::mw::internal::robotics::gazebotransport::Image* mutable_image();
  void set_allocated_image(::mw::internal::robotics::gazebotransport::Image* image);
  private:
  const ::mw::internal::robotics::gazebotransport::Image& _internal_image() const;
  ::mw::internal::robotics::gazebotransport::Image* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::mw::internal::robotics::gazebotransport::Image* image);
  ::mw::internal::robotics::gazebotransport::Image* unsafe_arena_release_image();

  // .mw.internal.robotics.gazebotransport.RequestImage request_image = 6;
  bool has_request_image() const;
  private:
  bool _internal_has_request_image() const;
  public:
  void clear_request_image();
  const ::mw::internal::robotics::gazebotransport::RequestImage& request_image() const;
  ::mw::internal::robotics::gazebotransport::RequestImage* release_request_image();
  ::mw::internal::robotics::gazebotransport::RequestImage* mutable_request_image();
  void set_allocated_request_image(::mw::internal::robotics::gazebotransport::RequestImage* request_image);
  private:
  const ::mw::internal::robotics::gazebotransport::RequestImage& _internal_request_image() const;
  ::mw::internal::robotics::gazebotransport::RequestImage* _internal_mutable_request_image();
  public:
  void unsafe_arena_set_allocated_request_image(
      ::mw::internal::robotics::gazebotransport::RequestImage* request_image);
  ::mw::internal::robotics::gazebotransport::RequestImage* unsafe_arena_release_request_image();

  // .mw.internal.robotics.gazebotransport.RequestCoSim request_cosim = 7;
  bool has_request_cosim() const;
  private:
  bool _internal_has_request_cosim() const;
  public:
  void clear_request_cosim();
  const ::mw::internal::robotics::gazebotransport::RequestCoSim& request_cosim() const;
  ::mw::internal::robotics::gazebotransport::RequestCoSim* release_request_cosim();
  ::mw::internal::robotics::gazebotransport::RequestCoSim* mutable_request_cosim();
  void set_allocated_request_cosim(::mw::internal::robotics::gazebotransport::RequestCoSim* request_cosim);
  private:
  const ::mw::internal::robotics::gazebotransport::RequestCoSim& _internal_request_cosim() const;
  ::mw::internal::robotics::gazebotransport::RequestCoSim* _internal_mutable_request_cosim();
  public:
  void unsafe_arena_set_allocated_request_cosim(
      ::mw::internal::robotics::gazebotransport::RequestCoSim* request_cosim);
  ::mw::internal::robotics::gazebotransport::RequestCoSim* unsafe_arena_release_request_cosim();

  // .mw.internal.robotics.gazebotransport.StopCoSim stop_cosim = 8;
  bool has_stop_cosim() const;
  private:
  bool _internal_has_stop_cosim() const;
  public:
  void clear_stop_cosim();
  const ::mw::internal::robotics::gazebotransport::StopCoSim& stop_cosim() const;
  ::mw::internal::robotics::gazebotransport::StopCoSim* release_stop_cosim();
  ::mw::internal::robotics::gazebotransport::StopCoSim* mutable_stop_cosim();
  void set_allocated_stop_cosim(::mw::internal::robotics::gazebotransport::StopCoSim* stop_cosim);
  private:
  const ::mw::internal::robotics::gazebotransport::StopCoSim& _internal_stop_cosim() const;
  ::mw::internal::robotics::gazebotransport::StopCoSim* _internal_mutable_stop_cosim();
  public:
  void unsafe_arena_set_allocated_stop_cosim(
      ::mw::internal::robotics::gazebotransport::StopCoSim* stop_cosim);
  ::mw::internal::robotics::gazebotransport::StopCoSim* unsafe_arena_release_stop_cosim();

  // .mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose get_ground_truth_world_pose = 9;
  bool has_get_ground_truth_world_pose() const;
  private:
  bool _internal_has_get_ground_truth_world_pose() const;
  public:
  void clear_get_ground_truth_world_pose();
  const ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose& get_ground_truth_world_pose() const;
  ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* release_get_ground_truth_world_pose();
  ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* mutable_get_ground_truth_world_pose();
  void set_allocated_get_ground_truth_world_pose(::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* get_ground_truth_world_pose);
  private:
  const ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose& _internal_get_ground_truth_world_pose() const;
  ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* _internal_mutable_get_ground_truth_world_pose();
  public:
  void unsafe_arena_set_allocated_get_ground_truth_world_pose(
      ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* get_ground_truth_world_pose);
  ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* unsafe_arena_release_get_ground_truth_world_pose();

  // .mw.internal.robotics.gazebotransport.Pose pose = 10;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::mw::internal::robotics::gazebotransport::Pose& pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* release_pose();
  ::mw::internal::robotics::gazebotransport::Pose* mutable_pose();
  void set_allocated_pose(::mw::internal::robotics::gazebotransport::Pose* pose);
  private:
  const ::mw::internal::robotics::gazebotransport::Pose& _internal_pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::mw::internal::robotics::gazebotransport::Pose* pose);
  ::mw::internal::robotics::gazebotransport::Pose* unsafe_arena_release_pose();

  // .mw.internal.robotics.gazebotransport.StopSimulation stop_simulation = 11;
  bool has_stop_simulation() const;
  private:
  bool _internal_has_stop_simulation() const;
  public:
  void clear_stop_simulation();
  const ::mw::internal::robotics::gazebotransport::StopSimulation& stop_simulation() const;
  ::mw::internal::robotics::gazebotransport::StopSimulation* release_stop_simulation();
  ::mw::internal::robotics::gazebotransport::StopSimulation* mutable_stop_simulation();
  void set_allocated_stop_simulation(::mw::internal::robotics::gazebotransport::StopSimulation* stop_simulation);
  private:
  const ::mw::internal::robotics::gazebotransport::StopSimulation& _internal_stop_simulation() const;
  ::mw::internal::robotics::gazebotransport::StopSimulation* _internal_mutable_stop_simulation();
  public:
  void unsafe_arena_set_allocated_stop_simulation(
      ::mw::internal::robotics::gazebotransport::StopSimulation* stop_simulation);
  ::mw::internal::robotics::gazebotransport::StopSimulation* unsafe_arena_release_stop_simulation();

  // .mw.internal.robotics.gazebotransport.LaserData laser_data = 12;
  bool has_laser_data() const;
  private:
  bool _internal_has_laser_data() const;
  public:
  void clear_laser_data();
  const ::mw::internal::robotics::gazebotransport::LaserData& laser_data() const;
  ::mw::internal::robotics::gazebotransport::LaserData* release_laser_data();
  ::mw::internal::robotics::gazebotransport::LaserData* mutable_laser_data();
  void set_allocated_laser_data(::mw::internal::robotics::gazebotransport::LaserData* laser_data);
  private:
  const ::mw::internal::robotics::gazebotransport::LaserData& _internal_laser_data() const;
  ::mw::internal::robotics::gazebotransport::LaserData* _internal_mutable_laser_data();
  public:
  void unsafe_arena_set_allocated_laser_data(
      ::mw::internal::robotics::gazebotransport::LaserData* laser_data);
  ::mw::internal::robotics::gazebotransport::LaserData* unsafe_arena_release_laser_data();

  // .mw.internal.robotics.gazebotransport.RequestLaser request_laser = 13;
  bool has_request_laser() const;
  private:
  bool _internal_has_request_laser() const;
  public:
  void clear_request_laser();
  const ::mw::internal::robotics::gazebotransport::RequestLaser& request_laser() const;
  ::mw::internal::robotics::gazebotransport::RequestLaser* release_request_laser();
  ::mw::internal::robotics::gazebotransport::RequestLaser* mutable_request_laser();
  void set_allocated_request_laser(::mw::internal::robotics::gazebotransport::RequestLaser* request_laser);
  private:
  const ::mw::internal::robotics::gazebotransport::RequestLaser& _internal_request_laser() const;
  ::mw::internal::robotics::gazebotransport::RequestLaser* _internal_mutable_request_laser();
  public:
  void unsafe_arena_set_allocated_request_laser(
      ::mw::internal::robotics::gazebotransport::RequestLaser* request_laser);
  ::mw::internal::robotics::gazebotransport::RequestLaser* unsafe_arena_release_request_laser();

  // .mw.internal.robotics.gazebotransport.ImuData imu_data = 14;
  bool has_imu_data() const;
  private:
  bool _internal_has_imu_data() const;
  public:
  void clear_imu_data();
  const ::mw::internal::robotics::gazebotransport::ImuData& imu_data() const;
  ::mw::internal::robotics::gazebotransport::ImuData* release_imu_data();
  ::mw::internal::robotics::gazebotransport::ImuData* mutable_imu_data();
  void set_allocated_imu_data(::mw::internal::robotics::gazebotransport::ImuData* imu_data);
  private:
  const ::mw::internal::robotics::gazebotransport::ImuData& _internal_imu_data() const;
  ::mw::internal::robotics::gazebotransport::ImuData* _internal_mutable_imu_data();
  public:
  void unsafe_arena_set_allocated_imu_data(
      ::mw::internal::robotics::gazebotransport::ImuData* imu_data);
  ::mw::internal::robotics::gazebotransport::ImuData* unsafe_arena_release_imu_data();

  // .mw.internal.robotics.gazebotransport.RequestImu request_imu = 15;
  bool has_request_imu() const;
  private:
  bool _internal_has_request_imu() const;
  public:
  void clear_request_imu();
  const ::mw::internal::robotics::gazebotransport::RequestImu& request_imu() const;
  ::mw::internal::robotics::gazebotransport::RequestImu* release_request_imu();
  ::mw::internal::robotics::gazebotransport::RequestImu* mutable_request_imu();
  void set_allocated_request_imu(::mw::internal::robotics::gazebotransport::RequestImu* request_imu);
  private:
  const ::mw::internal::robotics::gazebotransport::RequestImu& _internal_request_imu() const;
  ::mw::internal::robotics::gazebotransport::RequestImu* _internal_mutable_request_imu();
  public:
  void unsafe_arena_set_allocated_request_imu(
      ::mw::internal::robotics::gazebotransport::RequestImu* request_imu);
  ::mw::internal::robotics::gazebotransport::RequestImu* unsafe_arena_release_request_imu();

  // .mw.internal.robotics.gazebotransport.SubscribeImage subscribe_image = 16;
  bool has_subscribe_image() const;
  private:
  bool _internal_has_subscribe_image() const;
  public:
  void clear_subscribe_image();
  const ::mw::internal::robotics::gazebotransport::SubscribeImage& subscribe_image() const;
  ::mw::internal::robotics::gazebotransport::SubscribeImage* release_subscribe_image();
  ::mw::internal::robotics::gazebotransport::SubscribeImage* mutable_subscribe_image();
  void set_allocated_subscribe_image(::mw::internal::robotics::gazebotransport::SubscribeImage* subscribe_image);
  private:
  const ::mw::internal::robotics::gazebotransport::SubscribeImage& _internal_subscribe_image() const;
  ::mw::internal::robotics::gazebotransport::SubscribeImage* _internal_mutable_subscribe_image();
  public:
  void unsafe_arena_set_allocated_subscribe_image(
      ::mw::internal::robotics::gazebotransport::SubscribeImage* subscribe_image);
  ::mw::internal::robotics::gazebotransport::SubscribeImage* unsafe_arena_release_subscribe_image();

  // .mw.internal.robotics.gazebotransport.SubscribeLaser subscribe_laser = 17;
  bool has_subscribe_laser() const;
  private:
  bool _internal_has_subscribe_laser() const;
  public:
  void clear_subscribe_laser();
  const ::mw::internal::robotics::gazebotransport::SubscribeLaser& subscribe_laser() const;
  ::mw::internal::robotics::gazebotransport::SubscribeLaser* release_subscribe_laser();
  ::mw::internal::robotics::gazebotransport::SubscribeLaser* mutable_subscribe_laser();
  void set_allocated_subscribe_laser(::mw::internal::robotics::gazebotransport::SubscribeLaser* subscribe_laser);
  private:
  const ::mw::internal::robotics::gazebotransport::SubscribeLaser& _internal_subscribe_laser() const;
  ::mw::internal::robotics::gazebotransport::SubscribeLaser* _internal_mutable_subscribe_laser();
  public:
  void unsafe_arena_set_allocated_subscribe_laser(
      ::mw::internal::robotics::gazebotransport::SubscribeLaser* subscribe_laser);
  ::mw::internal::robotics::gazebotransport::SubscribeLaser* unsafe_arena_release_subscribe_laser();

  // .mw.internal.robotics.gazebotransport.SubscribeImu subscribe_imu = 18;
  bool has_subscribe_imu() const;
  private:
  bool _internal_has_subscribe_imu() const;
  public:
  void clear_subscribe_imu();
  const ::mw::internal::robotics::gazebotransport::SubscribeImu& subscribe_imu() const;
  ::mw::internal::robotics::gazebotransport::SubscribeImu* release_subscribe_imu();
  ::mw::internal::robotics::gazebotransport::SubscribeImu* mutable_subscribe_imu();
  void set_allocated_subscribe_imu(::mw::internal::robotics::gazebotransport::SubscribeImu* subscribe_imu);
  private:
  const ::mw::internal::robotics::gazebotransport::SubscribeImu& _internal_subscribe_imu() const;
  ::mw::internal::robotics::gazebotransport::SubscribeImu* _internal_mutable_subscribe_imu();
  public:
  void unsafe_arena_set_allocated_subscribe_imu(
      ::mw::internal::robotics::gazebotransport::SubscribeImu* subscribe_imu);
  ::mw::internal::robotics::gazebotransport::SubscribeImu* unsafe_arena_release_subscribe_imu();

  // .mw.internal.robotics.gazebotransport.ApplyJointTorque apply_joint_torque = 19;
  bool has_apply_joint_torque() const;
  private:
  bool _internal_has_apply_joint_torque() const;
  public:
  void clear_apply_joint_torque();
  const ::mw::internal::robotics::gazebotransport::ApplyJointTorque& apply_joint_torque() const;
  ::mw::internal::robotics::gazebotransport::ApplyJointTorque* release_apply_joint_torque();
  ::mw::internal::robotics::gazebotransport::ApplyJointTorque* mutable_apply_joint_torque();
  void set_allocated_apply_joint_torque(::mw::internal::robotics::gazebotransport::ApplyJointTorque* apply_joint_torque);
  private:
  const ::mw::internal::robotics::gazebotransport::ApplyJointTorque& _internal_apply_joint_torque() const;
  ::mw::internal::robotics::gazebotransport::ApplyJointTorque* _internal_mutable_apply_joint_torque();
  public:
  void unsafe_arena_set_allocated_apply_joint_torque(
      ::mw::internal::robotics::gazebotransport::ApplyJointTorque* apply_joint_torque);
  ::mw::internal::robotics::gazebotransport::ApplyJointTorque* unsafe_arena_release_apply_joint_torque();

  // .mw.internal.robotics.gazebotransport.GetPose get_pose = 20;
  bool has_get_pose() const;
  private:
  bool _internal_has_get_pose() const;
  public:
  void clear_get_pose();
  const ::mw::internal::robotics::gazebotransport::GetPose& get_pose() const;
  ::mw::internal::robotics::gazebotransport::GetPose* release_get_pose();
  ::mw::internal::robotics::gazebotransport::GetPose* mutable_get_pose();
  void set_allocated_get_pose(::mw::internal::robotics::gazebotransport::GetPose* get_pose);
  private:
  const ::mw::internal::robotics::gazebotransport::GetPose& _internal_get_pose() const;
  ::mw::internal::robotics::gazebotransport::GetPose* _internal_mutable_get_pose();
  public:
  void unsafe_arena_set_allocated_get_pose(
      ::mw::internal::robotics::gazebotransport::GetPose* get_pose);
  ::mw::internal::robotics::gazebotransport::GetPose* unsafe_arena_release_get_pose();

  // .mw.internal.robotics.gazebotransport.GetTopicList get_topic_list = 21;
  bool has_get_topic_list() const;
  private:
  bool _internal_has_get_topic_list() const;
  public:
  void clear_get_topic_list();
  const ::mw::internal::robotics::gazebotransport::GetTopicList& get_topic_list() const;
  ::mw::internal::robotics::gazebotransport::GetTopicList* release_get_topic_list();
  ::mw::internal::robotics::gazebotransport::GetTopicList* mutable_get_topic_list();
  void set_allocated_get_topic_list(::mw::internal::robotics::gazebotransport::GetTopicList* get_topic_list);
  private:
  const ::mw::internal::robotics::gazebotransport::GetTopicList& _internal_get_topic_list() const;
  ::mw::internal::robotics::gazebotransport::GetTopicList* _internal_mutable_get_topic_list();
  public:
  void unsafe_arena_set_allocated_get_topic_list(
      ::mw::internal::robotics::gazebotransport::GetTopicList* get_topic_list);
  ::mw::internal::robotics::gazebotransport::GetTopicList* unsafe_arena_release_get_topic_list();

  // .mw.internal.robotics.gazebotransport.TopicList topic_list = 22;
  bool has_topic_list() const;
  private:
  bool _internal_has_topic_list() const;
  public:
  void clear_topic_list();
  const ::mw::internal::robotics::gazebotransport::TopicList& topic_list() const;
  ::mw::internal::robotics::gazebotransport::TopicList* release_topic_list();
  ::mw::internal::robotics::gazebotransport::TopicList* mutable_topic_list();
  void set_allocated_topic_list(::mw::internal::robotics::gazebotransport::TopicList* topic_list);
  private:
  const ::mw::internal::robotics::gazebotransport::TopicList& _internal_topic_list() const;
  ::mw::internal::robotics::gazebotransport::TopicList* _internal_mutable_topic_list();
  public:
  void unsafe_arena_set_allocated_topic_list(
      ::mw::internal::robotics::gazebotransport::TopicList* topic_list);
  ::mw::internal::robotics::gazebotransport::TopicList* unsafe_arena_release_topic_list();

  // .mw.internal.robotics.gazebotransport.GetModelInfo get_model_info = 23;
  bool has_get_model_info() const;
  private:
  bool _internal_has_get_model_info() const;
  public:
  void clear_get_model_info();
  const ::mw::internal::robotics::gazebotransport::GetModelInfo& get_model_info() const;
  ::mw::internal::robotics::gazebotransport::GetModelInfo* release_get_model_info();
  ::mw::internal::robotics::gazebotransport::GetModelInfo* mutable_get_model_info();
  void set_allocated_get_model_info(::mw::internal::robotics::gazebotransport::GetModelInfo* get_model_info);
  private:
  const ::mw::internal::robotics::gazebotransport::GetModelInfo& _internal_get_model_info() const;
  ::mw::internal::robotics::gazebotransport::GetModelInfo* _internal_mutable_get_model_info();
  public:
  void unsafe_arena_set_allocated_get_model_info(
      ::mw::internal::robotics::gazebotransport::GetModelInfo* get_model_info);
  ::mw::internal::robotics::gazebotransport::GetModelInfo* unsafe_arena_release_get_model_info();

  // .mw.internal.robotics.gazebotransport.ModelInfo model_info = 24;
  bool has_model_info() const;
  private:
  bool _internal_has_model_info() const;
  public:
  void clear_model_info();
  const ::mw::internal::robotics::gazebotransport::ModelInfo& model_info() const;
  ::mw::internal::robotics::gazebotransport::ModelInfo* release_model_info();
  ::mw::internal::robotics::gazebotransport::ModelInfo* mutable_model_info();
  void set_allocated_model_info(::mw::internal::robotics::gazebotransport::ModelInfo* model_info);
  private:
  const ::mw::internal::robotics::gazebotransport::ModelInfo& _internal_model_info() const;
  ::mw::internal::robotics::gazebotransport::ModelInfo* _internal_mutable_model_info();
  public:
  void unsafe_arena_set_allocated_model_info(
      ::mw::internal::robotics::gazebotransport::ModelInfo* model_info);
  ::mw::internal::robotics::gazebotransport::ModelInfo* unsafe_arena_release_model_info();

  // .mw.internal.robotics.gazebotransport.ApplyLinkWrench apply_link_wrench = 25;
  bool has_apply_link_wrench() const;
  private:
  bool _internal_has_apply_link_wrench() const;
  public:
  void clear_apply_link_wrench();
  const ::mw::internal::robotics::gazebotransport::ApplyLinkWrench& apply_link_wrench() const;
  ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* release_apply_link_wrench();
  ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* mutable_apply_link_wrench();
  void set_allocated_apply_link_wrench(::mw::internal::robotics::gazebotransport::ApplyLinkWrench* apply_link_wrench);
  private:
  const ::mw::internal::robotics::gazebotransport::ApplyLinkWrench& _internal_apply_link_wrench() const;
  ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* _internal_mutable_apply_link_wrench();
  public:
  void unsafe_arena_set_allocated_apply_link_wrench(
      ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* apply_link_wrench);
  ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* unsafe_arena_release_apply_link_wrench();

  // .mw.internal.robotics.gazebotransport.MaxStepSize max_step_size = 26;
  bool has_max_step_size() const;
  private:
  bool _internal_has_max_step_size() const;
  public:
  void clear_max_step_size();
  const ::mw::internal::robotics::gazebotransport::MaxStepSize& max_step_size() const;
  ::mw::internal::robotics::gazebotransport::MaxStepSize* release_max_step_size();
  ::mw::internal::robotics::gazebotransport::MaxStepSize* mutable_max_step_size();
  void set_allocated_max_step_size(::mw::internal::robotics::gazebotransport::MaxStepSize* max_step_size);
  private:
  const ::mw::internal::robotics::gazebotransport::MaxStepSize& _internal_max_step_size() const;
  ::mw::internal::robotics::gazebotransport::MaxStepSize* _internal_mutable_max_step_size();
  public:
  void unsafe_arena_set_allocated_max_step_size(
      ::mw::internal::robotics::gazebotransport::MaxStepSize* max_step_size);
  ::mw::internal::robotics::gazebotransport::MaxStepSize* unsafe_arena_release_max_step_size();

  // .mw.internal.robotics.gazebotransport.CustomMessageSupport custom_message_support = 27;
  bool has_custom_message_support() const;
  private:
  bool _internal_has_custom_message_support() const;
  public:
  void clear_custom_message_support();
  const ::mw::internal::robotics::gazebotransport::CustomMessageSupport& custom_message_support() const;
  ::mw::internal::robotics::gazebotransport::CustomMessageSupport* release_custom_message_support();
  ::mw::internal::robotics::gazebotransport::CustomMessageSupport* mutable_custom_message_support();
  void set_allocated_custom_message_support(::mw::internal::robotics::gazebotransport::CustomMessageSupport* custom_message_support);
  private:
  const ::mw::internal::robotics::gazebotransport::CustomMessageSupport& _internal_custom_message_support() const;
  ::mw::internal::robotics::gazebotransport::CustomMessageSupport* _internal_mutable_custom_message_support();
  public:
  void unsafe_arena_set_allocated_custom_message_support(
      ::mw::internal::robotics::gazebotransport::CustomMessageSupport* custom_message_support);
  ::mw::internal::robotics::gazebotransport::CustomMessageSupport* unsafe_arena_release_custom_message_support();

  // .mw.internal.robotics.gazebotransport.InitCustomPublisher init_custom_publisher = 28;
  bool has_init_custom_publisher() const;
  private:
  bool _internal_has_init_custom_publisher() const;
  public:
  void clear_init_custom_publisher();
  const ::mw::internal::robotics::gazebotransport::InitCustomPublisher& init_custom_publisher() const;
  ::mw::internal::robotics::gazebotransport::InitCustomPublisher* release_init_custom_publisher();
  ::mw::internal::robotics::gazebotransport::InitCustomPublisher* mutable_init_custom_publisher();
  void set_allocated_init_custom_publisher(::mw::internal::robotics::gazebotransport::InitCustomPublisher* init_custom_publisher);
  private:
  const ::mw::internal::robotics::gazebotransport::InitCustomPublisher& _internal_init_custom_publisher() const;
  ::mw::internal::robotics::gazebotransport::InitCustomPublisher* _internal_mutable_init_custom_publisher();
  public:
  void unsafe_arena_set_allocated_init_custom_publisher(
      ::mw::internal::robotics::gazebotransport::InitCustomPublisher* init_custom_publisher);
  ::mw::internal::robotics::gazebotransport::InitCustomPublisher* unsafe_arena_release_init_custom_publisher();

  // .mw.internal.robotics.gazebotransport.InitCustomSubscriber init_custom_subscriber = 29;
  bool has_init_custom_subscriber() const;
  private:
  bool _internal_has_init_custom_subscriber() const;
  public:
  void clear_init_custom_subscriber();
  const ::mw::internal::robotics::gazebotransport::InitCustomSubscriber& init_custom_subscriber() const;
  ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* release_init_custom_subscriber();
  ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* mutable_init_custom_subscriber();
  void set_allocated_init_custom_subscriber(::mw::internal::robotics::gazebotransport::InitCustomSubscriber* init_custom_subscriber);
  private:
  const ::mw::internal::robotics::gazebotransport::InitCustomSubscriber& _internal_init_custom_subscriber() const;
  ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* _internal_mutable_init_custom_subscriber();
  public:
  void unsafe_arena_set_allocated_init_custom_subscriber(
      ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* init_custom_subscriber);
  ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* unsafe_arena_release_init_custom_subscriber();

  // .mw.internal.robotics.gazebotransport.RequestCustomMessageSupport request_custom_message_support = 30;
  bool has_request_custom_message_support() const;
  private:
  bool _internal_has_request_custom_message_support() const;
  public:
  void clear_request_custom_message_support();
  const ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport& request_custom_message_support() const;
  ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* release_request_custom_message_support();
  ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* mutable_request_custom_message_support();
  void set_allocated_request_custom_message_support(::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* request_custom_message_support);
  private:
  const ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport& _internal_request_custom_message_support() const;
  ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* _internal_mutable_request_custom_message_support();
  public:
  void unsafe_arena_set_allocated_request_custom_message_support(
      ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* request_custom_message_support);
  ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* unsafe_arena_release_request_custom_message_support();

  // .mw.internal.robotics.gazebotransport.SetJointPosition set_joint_position = 31;
  bool has_set_joint_position() const;
  private:
  bool _internal_has_set_joint_position() const;
  public:
  void clear_set_joint_position();
  const ::mw::internal::robotics::gazebotransport::SetJointPosition& set_joint_position() const;
  ::mw::internal::robotics::gazebotransport::SetJointPosition* release_set_joint_position();
  ::mw::internal::robotics::gazebotransport::SetJointPosition* mutable_set_joint_position();
  void set_allocated_set_joint_position(::mw::internal::robotics::gazebotransport::SetJointPosition* set_joint_position);
  private:
  const ::mw::internal::robotics::gazebotransport::SetJointPosition& _internal_set_joint_position() const;
  ::mw::internal::robotics::gazebotransport::SetJointPosition* _internal_mutable_set_joint_position();
  public:
  void unsafe_arena_set_allocated_set_joint_position(
      ::mw::internal::robotics::gazebotransport::SetJointPosition* set_joint_position);
  ::mw::internal::robotics::gazebotransport::SetJointPosition* unsafe_arena_release_set_joint_position();

  // .mw.internal.robotics.gazebotransport.SetJointVelocity set_joint_velocity = 32;
  bool has_set_joint_velocity() const;
  private:
  bool _internal_has_set_joint_velocity() const;
  public:
  void clear_set_joint_velocity();
  const ::mw::internal::robotics::gazebotransport::SetJointVelocity& set_joint_velocity() const;
  ::mw::internal::robotics::gazebotransport::SetJointVelocity* release_set_joint_velocity();
  ::mw::internal::robotics::gazebotransport::SetJointVelocity* mutable_set_joint_velocity();
  void set_allocated_set_joint_velocity(::mw::internal::robotics::gazebotransport::SetJointVelocity* set_joint_velocity);
  private:
  const ::mw::internal::robotics::gazebotransport::SetJointVelocity& _internal_set_joint_velocity() const;
  ::mw::internal::robotics::gazebotransport::SetJointVelocity* _internal_mutable_set_joint_velocity();
  public:
  void unsafe_arena_set_allocated_set_joint_velocity(
      ::mw::internal::robotics::gazebotransport::SetJointVelocity* set_joint_velocity);
  ::mw::internal::robotics::gazebotransport::SetJointVelocity* unsafe_arena_release_set_joint_velocity();

  // .mw.internal.robotics.gazebotransport.GetJointState get_joint_state = 33;
  bool has_get_joint_state() const;
  private:
  bool _internal_has_get_joint_state() const;
  public:
  void clear_get_joint_state();
  const ::mw::internal::robotics::gazebotransport::GetJointState& get_joint_state() const;
  ::mw::internal::robotics::gazebotransport::GetJointState* release_get_joint_state();
  ::mw::internal::robotics::gazebotransport::GetJointState* mutable_get_joint_state();
  void set_allocated_get_joint_state(::mw::internal::robotics::gazebotransport::GetJointState* get_joint_state);
  private:
  const ::mw::internal::robotics::gazebotransport::GetJointState& _internal_get_joint_state() const;
  ::mw::internal::robotics::gazebotransport::GetJointState* _internal_mutable_get_joint_state();
  public:
  void unsafe_arena_set_allocated_get_joint_state(
      ::mw::internal::robotics::gazebotransport::GetJointState* get_joint_state);
  ::mw::internal::robotics::gazebotransport::GetJointState* unsafe_arena_release_get_joint_state();

  // .mw.internal.robotics.gazebotransport.JointState joint_state = 34;
  bool has_joint_state() const;
  private:
  bool _internal_has_joint_state() const;
  public:
  void clear_joint_state();
  const ::mw::internal::robotics::gazebotransport::JointState& joint_state() const;
  ::mw::internal::robotics::gazebotransport::JointState* release_joint_state();
  ::mw::internal::robotics::gazebotransport::JointState* mutable_joint_state();
  void set_allocated_joint_state(::mw::internal::robotics::gazebotransport::JointState* joint_state);
  private:
  const ::mw::internal::robotics::gazebotransport::JointState& _internal_joint_state() const;
  ::mw::internal::robotics::gazebotransport::JointState* _internal_mutable_joint_state();
  public:
  void unsafe_arena_set_allocated_joint_state(
      ::mw::internal::robotics::gazebotransport::JointState* joint_state);
  ::mw::internal::robotics::gazebotransport::JointState* unsafe_arena_release_joint_state();

  // .mw.internal.robotics.gazebotransport.SetLinkWorldPose set_link_world_pose = 35;
  bool has_set_link_world_pose() const;
  private:
  bool _internal_has_set_link_world_pose() const;
  public:
  void clear_set_link_world_pose();
  const ::mw::internal::robotics::gazebotransport::SetLinkWorldPose& set_link_world_pose() const;
  ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* release_set_link_world_pose();
  ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* mutable_set_link_world_pose();
  void set_allocated_set_link_world_pose(::mw::internal::robotics::gazebotransport::SetLinkWorldPose* set_link_world_pose);
  private:
  const ::mw::internal::robotics::gazebotransport::SetLinkWorldPose& _internal_set_link_world_pose() const;
  ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* _internal_mutable_set_link_world_pose();
  public:
  void unsafe_arena_set_allocated_set_link_world_pose(
      ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* set_link_world_pose);
  ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* unsafe_arena_release_set_link_world_pose();

  // .mw.internal.robotics.gazebotransport.SetLinkLinearVelocity set_link_linear_velocity = 36;
  bool has_set_link_linear_velocity() const;
  private:
  bool _internal_has_set_link_linear_velocity() const;
  public:
  void clear_set_link_linear_velocity();
  const ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity& set_link_linear_velocity() const;
  ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* release_set_link_linear_velocity();
  ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* mutable_set_link_linear_velocity();
  void set_allocated_set_link_linear_velocity(::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* set_link_linear_velocity);
  private:
  const ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity& _internal_set_link_linear_velocity() const;
  ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* _internal_mutable_set_link_linear_velocity();
  public:
  void unsafe_arena_set_allocated_set_link_linear_velocity(
      ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* set_link_linear_velocity);
  ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* unsafe_arena_release_set_link_linear_velocity();

  // .mw.internal.robotics.gazebotransport.SetLinkAngularVelocity set_link_angular_velocity = 37;
  bool has_set_link_angular_velocity() const;
  private:
  bool _internal_has_set_link_angular_velocity() const;
  public:
  void clear_set_link_angular_velocity();
  const ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity& set_link_angular_velocity() const;
  ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* release_set_link_angular_velocity();
  ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* mutable_set_link_angular_velocity();
  void set_allocated_set_link_angular_velocity(::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* set_link_angular_velocity);
  private:
  const ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity& _internal_set_link_angular_velocity() const;
  ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* _internal_mutable_set_link_angular_velocity();
  public:
  void unsafe_arena_set_allocated_set_link_angular_velocity(
      ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* set_link_angular_velocity);
  ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* unsafe_arena_release_set_link_angular_velocity();

  // .mw.internal.robotics.gazebotransport.GetLinkState get_link_state = 38;
  bool has_get_link_state() const;
  private:
  bool _internal_has_get_link_state() const;
  public:
  void clear_get_link_state();
  const ::mw::internal::robotics::gazebotransport::GetLinkState& get_link_state() const;
  ::mw::internal::robotics::gazebotransport::GetLinkState* release_get_link_state();
  ::mw::internal::robotics::gazebotransport::GetLinkState* mutable_get_link_state();
  void set_allocated_get_link_state(::mw::internal::robotics::gazebotransport::GetLinkState* get_link_state);
  private:
  const ::mw::internal::robotics::gazebotransport::GetLinkState& _internal_get_link_state() const;
  ::mw::internal::robotics::gazebotransport::GetLinkState* _internal_mutable_get_link_state();
  public:
  void unsafe_arena_set_allocated_get_link_state(
      ::mw::internal::robotics::gazebotransport::GetLinkState* get_link_state);
  ::mw::internal::robotics::gazebotransport::GetLinkState* unsafe_arena_release_get_link_state();

  // .mw.internal.robotics.gazebotransport.LinkState link_state = 39;
  bool has_link_state() const;
  private:
  bool _internal_has_link_state() const;
  public:
  void clear_link_state();
  const ::mw::internal::robotics::gazebotransport::LinkState& link_state() const;
  ::mw::internal::robotics::gazebotransport::LinkState* release_link_state();
  ::mw::internal::robotics::gazebotransport::LinkState* mutable_link_state();
  void set_allocated_link_state(::mw::internal::robotics::gazebotransport::LinkState* link_state);
  private:
  const ::mw::internal::robotics::gazebotransport::LinkState& _internal_link_state() const;
  ::mw::internal::robotics::gazebotransport::LinkState* _internal_mutable_link_state();
  public:
  void unsafe_arena_set_allocated_link_state(
      ::mw::internal::robotics::gazebotransport::LinkState* link_state);
  ::mw::internal::robotics::gazebotransport::LinkState* unsafe_arena_release_link_state();

  // .mw.internal.robotics.gazebotransport.Gazebomodel gazebo_model = 40;
  bool has_gazebo_model() const;
  private:
  bool _internal_has_gazebo_model() const;
  public:
  void clear_gazebo_model();
  const ::mw::internal::robotics::gazebotransport::Gazebomodel& gazebo_model() const;
  ::mw::internal::robotics::gazebotransport::Gazebomodel* release_gazebo_model();
  ::mw::internal::robotics::gazebotransport::Gazebomodel* mutable_gazebo_model();
  void set_allocated_gazebo_model(::mw::internal::robotics::gazebotransport::Gazebomodel* gazebo_model);
  private:
  const ::mw::internal::robotics::gazebotransport::Gazebomodel& _internal_gazebo_model() const;
  ::mw::internal::robotics::gazebotransport::Gazebomodel* _internal_mutable_gazebo_model();
  public:
  void unsafe_arena_set_allocated_gazebo_model(
      ::mw::internal::robotics::gazebotransport::Gazebomodel* gazebo_model);
  ::mw::internal::robotics::gazebotransport::Gazebomodel* unsafe_arena_release_gazebo_model();

  // .mw.internal.robotics.gazebotransport.GetGazeboModelParam get_gazebo_model_param = 41;
  bool has_get_gazebo_model_param() const;
  private:
  bool _internal_has_get_gazebo_model_param() const;
  public:
  void clear_get_gazebo_model_param();
  const ::mw::internal::robotics::gazebotransport::GetGazeboModelParam& get_gazebo_model_param() const;
  ::mw::internal::robotics::gazebotransport::GetGazeboModelParam* release_get_gazebo_model_param();
  ::mw::internal::robotics::gazebotransport::GetGazeboModelParam* mutable_get_gazebo_model_param();
  void set_allocated_get_gazebo_model_param(::mw::internal::robotics::gazebotransport::GetGazeboModelParam* get_gazebo_model_param);
  private:
  const ::mw::internal::robotics::gazebotransport::GetGazeboModelParam& _internal_get_gazebo_model_param() const;
  ::mw::internal::robotics::gazebotransport::GetGazeboModelParam* _internal_mutable_get_gazebo_model_param();
  public:
  void unsafe_arena_set_allocated_get_gazebo_model_param(
      ::mw::internal::robotics::gazebotransport::GetGazeboModelParam* get_gazebo_model_param);
  ::mw::internal::robotics::gazebotransport::GetGazeboModelParam* unsafe_arena_release_get_gazebo_model_param();

  // .mw.internal.robotics.gazebotransport.GazeboModelSDF gazebo_model_sdf = 42;
  bool has_gazebo_model_sdf() const;
  private:
  bool _internal_has_gazebo_model_sdf() const;
  public:
  void clear_gazebo_model_sdf();
  const ::mw::internal::robotics::gazebotransport::GazeboModelSDF& gazebo_model_sdf() const;
  ::mw::internal::robotics::gazebotransport::GazeboModelSDF* release_gazebo_model_sdf();
  ::mw::internal::robotics::gazebotransport::GazeboModelSDF* mutable_gazebo_model_sdf();
  void set_allocated_gazebo_model_sdf(::mw::internal::robotics::gazebotransport::GazeboModelSDF* gazebo_model_sdf);
  private:
  const ::mw::internal::robotics::gazebotransport::GazeboModelSDF& _internal_gazebo_model_sdf() const;
  ::mw::internal::robotics::gazebotransport::GazeboModelSDF* _internal_mutable_gazebo_model_sdf();
  public:
  void unsafe_arena_set_allocated_gazebo_model_sdf(
      ::mw::internal::robotics::gazebotransport::GazeboModelSDF* gazebo_model_sdf);
  ::mw::internal::robotics::gazebotransport::GazeboModelSDF* unsafe_arena_release_gazebo_model_sdf();

  // .mw.internal.robotics.gazebotransport.GetGazeboModelSDF get_gazebo_model_sdf = 43;
  bool has_get_gazebo_model_sdf() const;
  private:
  bool _internal_has_get_gazebo_model_sdf() const;
  public:
  void clear_get_gazebo_model_sdf();
  const ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF& get_gazebo_model_sdf() const;
  ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* release_get_gazebo_model_sdf();
  ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* mutable_get_gazebo_model_sdf();
  void set_allocated_get_gazebo_model_sdf(::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* get_gazebo_model_sdf);
  private:
  const ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF& _internal_get_gazebo_model_sdf() const;
  ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* _internal_mutable_get_gazebo_model_sdf();
  public:
  void unsafe_arena_set_allocated_get_gazebo_model_sdf(
      ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* get_gazebo_model_sdf);
  ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* unsafe_arena_release_get_gazebo_model_sdf();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.Packet)
 private:
  class _Internal;
  void set_has_status();
  void set_has_step_simulation();
  void set_has_reset_simulation();
  void set_has_image();
  void set_has_request_image();
  void set_has_request_cosim();
  void set_has_stop_cosim();
  void set_has_get_ground_truth_world_pose();
  void set_has_pose();
  void set_has_stop_simulation();
  void set_has_laser_data();
  void set_has_request_laser();
  void set_has_imu_data();
  void set_has_request_imu();
  void set_has_subscribe_image();
  void set_has_subscribe_laser();
  void set_has_subscribe_imu();
  void set_has_apply_joint_torque();
  void set_has_get_pose();
  void set_has_get_topic_list();
  void set_has_topic_list();
  void set_has_get_model_info();
  void set_has_model_info();
  void set_has_apply_link_wrench();
  void set_has_max_step_size();
  void set_has_custom_message_support();
  void set_has_init_custom_publisher();
  void set_has_init_custom_subscriber();
  void set_has_request_custom_message_support();
  void set_has_set_joint_position();
  void set_has_set_joint_velocity();
  void set_has_get_joint_state();
  void set_has_joint_state();
  void set_has_set_link_world_pose();
  void set_has_set_link_linear_velocity();
  void set_has_set_link_angular_velocity();
  void set_has_get_link_state();
  void set_has_link_state();
  void set_has_gazebo_model();
  void set_has_get_gazebo_model_param();
  void set_has_gazebo_model_sdf();
  void set_has_get_gazebo_model_sdf();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  ::mw::internal::robotics::gazebotransport::PacketHeader* header_;
  bool is_new_reading_;
  union PayloadUnion {
    PayloadUnion() {}
    int status_;
    ::mw::internal::robotics::gazebotransport::StepSimulation* step_simulation_;
    ::mw::internal::robotics::gazebotransport::ResetSimulation* reset_simulation_;
    ::mw::internal::robotics::gazebotransport::Image* image_;
    ::mw::internal::robotics::gazebotransport::RequestImage* request_image_;
    ::mw::internal::robotics::gazebotransport::RequestCoSim* request_cosim_;
    ::mw::internal::robotics::gazebotransport::StopCoSim* stop_cosim_;
    ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* get_ground_truth_world_pose_;
    ::mw::internal::robotics::gazebotransport::Pose* pose_;
    ::mw::internal::robotics::gazebotransport::StopSimulation* stop_simulation_;
    ::mw::internal::robotics::gazebotransport::LaserData* laser_data_;
    ::mw::internal::robotics::gazebotransport::RequestLaser* request_laser_;
    ::mw::internal::robotics::gazebotransport::ImuData* imu_data_;
    ::mw::internal::robotics::gazebotransport::RequestImu* request_imu_;
    ::mw::internal::robotics::gazebotransport::SubscribeImage* subscribe_image_;
    ::mw::internal::robotics::gazebotransport::SubscribeLaser* subscribe_laser_;
    ::mw::internal::robotics::gazebotransport::SubscribeImu* subscribe_imu_;
    ::mw::internal::robotics::gazebotransport::ApplyJointTorque* apply_joint_torque_;
    ::mw::internal::robotics::gazebotransport::GetPose* get_pose_;
    ::mw::internal::robotics::gazebotransport::GetTopicList* get_topic_list_;
    ::mw::internal::robotics::gazebotransport::TopicList* topic_list_;
    ::mw::internal::robotics::gazebotransport::GetModelInfo* get_model_info_;
    ::mw::internal::robotics::gazebotransport::ModelInfo* model_info_;
    ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* apply_link_wrench_;
    ::mw::internal::robotics::gazebotransport::MaxStepSize* max_step_size_;
    ::mw::internal::robotics::gazebotransport::CustomMessageSupport* custom_message_support_;
    ::mw::internal::robotics::gazebotransport::InitCustomPublisher* init_custom_publisher_;
    ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* init_custom_subscriber_;
    ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* request_custom_message_support_;
    ::mw::internal::robotics::gazebotransport::SetJointPosition* set_joint_position_;
    ::mw::internal::robotics::gazebotransport::SetJointVelocity* set_joint_velocity_;
    ::mw::internal::robotics::gazebotransport::GetJointState* get_joint_state_;
    ::mw::internal::robotics::gazebotransport::JointState* joint_state_;
    ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* set_link_world_pose_;
    ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* set_link_linear_velocity_;
    ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* set_link_angular_velocity_;
    ::mw::internal::robotics::gazebotransport::GetLinkState* get_link_state_;
    ::mw::internal::robotics::gazebotransport::LinkState* link_state_;
    ::mw::internal::robotics::gazebotransport::Gazebomodel* gazebo_model_;
    ::mw::internal::robotics::gazebotransport::GetGazeboModelParam* get_gazebo_model_param_;
    ::mw::internal::robotics::gazebotransport::GazeboModelSDF* gazebo_model_sdf_;
    ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* get_gazebo_model_sdf_;
  } payload_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class StepSimulation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.StepSimulation) */ {
 public:
  inline StepSimulation() : StepSimulation(nullptr) {};
  virtual ~StepSimulation();

  StepSimulation(const StepSimulation& from);
  StepSimulation(StepSimulation&& from) noexcept
    : StepSimulation() {
    *this = ::std::move(from);
  }

  inline StepSimulation& operator=(const StepSimulation& from) {
    CopyFrom(from);
    return *this;
  }
  inline StepSimulation& operator=(StepSimulation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StepSimulation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StepSimulation* internal_default_instance() {
    return reinterpret_cast<const StepSimulation*>(
               &_StepSimulation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StepSimulation& a, StepSimulation& b) {
    a.Swap(&b);
  }
  inline void Swap(StepSimulation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StepSimulation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StepSimulation* New() const final {
    return CreateMaybeMessage<StepSimulation>(nullptr);
  }

  StepSimulation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StepSimulation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StepSimulation& from);
  void MergeFrom(const StepSimulation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StepSimulation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.StepSimulation";
  }
  protected:
  explicit StepSimulation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumStepsFieldNumber = 1,
  };
  // required uint32 num_steps = 1;
  bool has_num_steps() const;
  private:
  bool _internal_has_num_steps() const;
  public:
  void clear_num_steps();
  ::PROTOBUF_NAMESPACE_ID::uint32 num_steps() const;
  void set_num_steps(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_num_steps() const;
  void _internal_set_num_steps(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.StepSimulation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 num_steps_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class ResetSimulation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ResetSimulation) */ {
 public:
  inline ResetSimulation() : ResetSimulation(nullptr) {};
  virtual ~ResetSimulation();

  ResetSimulation(const ResetSimulation& from);
  ResetSimulation(ResetSimulation&& from) noexcept
    : ResetSimulation() {
    *this = ::std::move(from);
  }

  inline ResetSimulation& operator=(const ResetSimulation& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetSimulation& operator=(ResetSimulation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResetSimulation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResetSimulation* internal_default_instance() {
    return reinterpret_cast<const ResetSimulation*>(
               &_ResetSimulation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ResetSimulation& a, ResetSimulation& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetSimulation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetSimulation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResetSimulation* New() const final {
    return CreateMaybeMessage<ResetSimulation>(nullptr);
  }

  ResetSimulation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResetSimulation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResetSimulation& from);
  void MergeFrom(const ResetSimulation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetSimulation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.ResetSimulation";
  }
  protected:
  explicit ResetSimulation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ResetSimulation_ResetBehavior ResetBehavior;
  static constexpr ResetBehavior RESET_TIME =
    ResetSimulation_ResetBehavior_RESET_TIME;
  static constexpr ResetBehavior RESET_TIME_AND_SCENE =
    ResetSimulation_ResetBehavior_RESET_TIME_AND_SCENE;
  static inline bool ResetBehavior_IsValid(int value) {
    return ResetSimulation_ResetBehavior_IsValid(value);
  }
  static constexpr ResetBehavior ResetBehavior_MIN =
    ResetSimulation_ResetBehavior_ResetBehavior_MIN;
  static constexpr ResetBehavior ResetBehavior_MAX =
    ResetSimulation_ResetBehavior_ResetBehavior_MAX;
  static constexpr int ResetBehavior_ARRAYSIZE =
    ResetSimulation_ResetBehavior_ResetBehavior_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ResetBehavior_descriptor() {
    return ResetSimulation_ResetBehavior_descriptor();
  }
  template<typename T>
  static inline const std::string& ResetBehavior_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ResetBehavior>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ResetBehavior_Name.");
    return ResetSimulation_ResetBehavior_Name(enum_t_value);
  }
  static inline bool ResetBehavior_Parse(const std::string& name,
      ResetBehavior* value) {
    return ResetSimulation_ResetBehavior_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBehaviorFieldNumber = 1,
  };
  // required .mw.internal.robotics.gazebotransport.ResetSimulation.ResetBehavior behavior = 1;
  bool has_behavior() const;
  private:
  bool _internal_has_behavior() const;
  public:
  void clear_behavior();
  ::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior behavior() const;
  void set_behavior(::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior value);
  private:
  ::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior _internal_behavior() const;
  void _internal_set_behavior(::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ResetSimulation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int behavior_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class Image PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.Image) */ {
 public:
  inline Image() : Image(nullptr) {};
  virtual ~Image();

  Image(const Image& from);
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline Image& operator=(Image&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Image& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }
  inline void Swap(Image* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Image* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Image* New() const final {
    return CreateMaybeMessage<Image>(nullptr);
  }

  Image* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Image>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Image* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.Image";
  }
  protected:
  explicit Image(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kDataTypeFieldNumber = 4,
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // optional bytes data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_data();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_data(
      std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // optional string data_type = 4;
  bool has_data_type() const;
  private:
  bool _internal_has_data_type() const;
  public:
  void clear_data_type();
  const std::string& data_type() const;
  void set_data_type(const std::string& value);
  void set_data_type(std::string&& value);
  void set_data_type(const char* value);
  void set_data_type(const char* value, size_t size);
  std::string* mutable_data_type();
  std::string* release_data_type();
  void set_allocated_data_type(std::string* data_type);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_data_type();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_data_type(
      std::string* data_type);
  private:
  const std::string& _internal_data_type() const;
  void _internal_set_data_type(const std::string& value);
  std::string* _internal_mutable_data_type();
  public:

  // optional uint32 width = 1;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::uint32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 height = 2;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::uint32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.Image)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 width_;
  ::PROTOBUF_NAMESPACE_ID::uint32 height_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class RequestImage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.RequestImage) */ {
 public:
  inline RequestImage() : RequestImage(nullptr) {};
  virtual ~RequestImage();

  RequestImage(const RequestImage& from);
  RequestImage(RequestImage&& from) noexcept
    : RequestImage() {
    *this = ::std::move(from);
  }

  inline RequestImage& operator=(const RequestImage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestImage& operator=(RequestImage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestImage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestImage* internal_default_instance() {
    return reinterpret_cast<const RequestImage*>(
               &_RequestImage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RequestImage& a, RequestImage& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestImage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestImage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestImage* New() const final {
    return CreateMaybeMessage<RequestImage>(nullptr);
  }

  RequestImage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestImage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestImage& from);
  void MergeFrom(const RequestImage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestImage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.RequestImage";
  }
  protected:
  explicit RequestImage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicNameFieldNumber = 1,
  };
  // required string topic_name = 1;
  bool has_topic_name() const;
  private:
  bool _internal_has_topic_name() const;
  public:
  void clear_topic_name();
  const std::string& topic_name() const;
  void set_topic_name(const std::string& value);
  void set_topic_name(std::string&& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  std::string* mutable_topic_name();
  std::string* release_topic_name();
  void set_allocated_topic_name(std::string* topic_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_topic_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_topic_name(
      std::string* topic_name);
  private:
  const std::string& _internal_topic_name() const;
  void _internal_set_topic_name(const std::string& value);
  std::string* _internal_mutable_topic_name();
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.RequestImage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_name_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class RequestCoSim PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.RequestCoSim) */ {
 public:
  inline RequestCoSim() : RequestCoSim(nullptr) {};
  virtual ~RequestCoSim();

  RequestCoSim(const RequestCoSim& from);
  RequestCoSim(RequestCoSim&& from) noexcept
    : RequestCoSim() {
    *this = ::std::move(from);
  }

  inline RequestCoSim& operator=(const RequestCoSim& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestCoSim& operator=(RequestCoSim&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestCoSim& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestCoSim* internal_default_instance() {
    return reinterpret_cast<const RequestCoSim*>(
               &_RequestCoSim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RequestCoSim& a, RequestCoSim& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestCoSim* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestCoSim* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestCoSim* New() const final {
    return CreateMaybeMessage<RequestCoSim>(nullptr);
  }

  RequestCoSim* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestCoSim>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestCoSim& from);
  void MergeFrom(const RequestCoSim& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestCoSim* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.RequestCoSim";
  }
  protected:
  explicit RequestCoSim(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kDurationFieldNumber = 2,
  };
  // required string client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const std::string& client_id() const;
  void set_client_id(const std::string& value);
  void set_client_id(std::string&& value);
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  std::string* mutable_client_id();
  std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_client_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_client_id(
      std::string* client_id);
  private:
  const std::string& _internal_client_id() const;
  void _internal_set_client_id(const std::string& value);
  std::string* _internal_mutable_client_id();
  public:

  // required double duration = 2;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  double duration() const;
  void set_duration(double value);
  private:
  double _internal_duration() const;
  void _internal_set_duration(double value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.RequestCoSim)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
  double duration_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class StopCoSim PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.StopCoSim) */ {
 public:
  inline StopCoSim() : StopCoSim(nullptr) {};
  virtual ~StopCoSim();

  StopCoSim(const StopCoSim& from);
  StopCoSim(StopCoSim&& from) noexcept
    : StopCoSim() {
    *this = ::std::move(from);
  }

  inline StopCoSim& operator=(const StopCoSim& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopCoSim& operator=(StopCoSim&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StopCoSim& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopCoSim* internal_default_instance() {
    return reinterpret_cast<const StopCoSim*>(
               &_StopCoSim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StopCoSim& a, StopCoSim& b) {
    a.Swap(&b);
  }
  inline void Swap(StopCoSim* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopCoSim* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StopCoSim* New() const final {
    return CreateMaybeMessage<StopCoSim>(nullptr);
  }

  StopCoSim* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StopCoSim>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StopCoSim& from);
  void MergeFrom(const StopCoSim& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopCoSim* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.StopCoSim";
  }
  protected:
  explicit StopCoSim(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // required string client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const std::string& client_id() const;
  void set_client_id(const std::string& value);
  void set_client_id(std::string&& value);
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  std::string* mutable_client_id();
  std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_client_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_client_id(
      std::string* client_id);
  private:
  const std::string& _internal_client_id() const;
  void _internal_set_client_id(const std::string& value);
  std::string* _internal_mutable_client_id();
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.StopCoSim)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class GetGroundTruthWorldPose PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose) */ {
 public:
  inline GetGroundTruthWorldPose() : GetGroundTruthWorldPose(nullptr) {};
  virtual ~GetGroundTruthWorldPose();

  GetGroundTruthWorldPose(const GetGroundTruthWorldPose& from);
  GetGroundTruthWorldPose(GetGroundTruthWorldPose&& from) noexcept
    : GetGroundTruthWorldPose() {
    *this = ::std::move(from);
  }

  inline GetGroundTruthWorldPose& operator=(const GetGroundTruthWorldPose& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetGroundTruthWorldPose& operator=(GetGroundTruthWorldPose&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetGroundTruthWorldPose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetGroundTruthWorldPose* internal_default_instance() {
    return reinterpret_cast<const GetGroundTruthWorldPose*>(
               &_GetGroundTruthWorldPose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetGroundTruthWorldPose& a, GetGroundTruthWorldPose& b) {
    a.Swap(&b);
  }
  inline void Swap(GetGroundTruthWorldPose* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetGroundTruthWorldPose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetGroundTruthWorldPose* New() const final {
    return CreateMaybeMessage<GetGroundTruthWorldPose>(nullptr);
  }

  GetGroundTruthWorldPose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetGroundTruthWorldPose>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetGroundTruthWorldPose& from);
  void MergeFrom(const GetGroundTruthWorldPose& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetGroundTruthWorldPose* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose";
  }
  protected:
  explicit GetGroundTruthWorldPose(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 1,
    kLinkNameFieldNumber = 2,
  };
  // required string model_name = 1;
  bool has_model_name() const;
  private:
  bool _internal_has_model_name() const;
  public:
  void clear_model_name();
  const std::string& model_name() const;
  void set_model_name(const std::string& value);
  void set_model_name(std::string&& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  std::string* mutable_model_name();
  std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_model_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_model_name(
      std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // required string link_name = 2;
  bool has_link_name() const;
  private:
  bool _internal_has_link_name() const;
  public:
  void clear_link_name();
  const std::string& link_name() const;
  void set_link_name(const std::string& value);
  void set_link_name(std::string&& value);
  void set_link_name(const char* value);
  void set_link_name(const char* value, size_t size);
  std::string* mutable_link_name();
  std::string* release_link_name();
  void set_allocated_link_name(std::string* link_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_link_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_link_name(
      std::string* link_name);
  private:
  const std::string& _internal_link_name() const;
  void _internal_set_link_name(const std::string& value);
  std::string* _internal_mutable_link_name();
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_name_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class Point PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.Point) */ {
 public:
  inline Point() : Point(nullptr) {};
  virtual ~Point();

  Point(const Point& from);
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point& operator=(Point&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Point& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }
  inline void Swap(Point* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Point* New() const final {
    return CreateMaybeMessage<Point>(nullptr);
  }

  Point* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.Point";
  }
  protected:
  explicit Point(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // required double x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // required double y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // required double z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.Point)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double x_;
  double y_;
  double z_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class Quaternion PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.Quaternion) */ {
 public:
  inline Quaternion() : Quaternion(nullptr) {};
  virtual ~Quaternion();

  Quaternion(const Quaternion& from);
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Quaternion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(Quaternion* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quaternion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Quaternion* New() const final {
    return CreateMaybeMessage<Quaternion>(nullptr);
  }

  Quaternion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Quaternion>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Quaternion& from);
  void MergeFrom(const Quaternion& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quaternion* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.Quaternion";
  }
  protected:
  explicit Quaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // required double x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // required double y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // required double z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // required double w = 4;
  bool has_w() const;
  private:
  bool _internal_has_w() const;
  public:
  void clear_w();
  double w() const;
  void set_w(double value);
  private:
  double _internal_w() const;
  void _internal_set_w(double value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.Quaternion)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double x_;
  double y_;
  double z_;
  double w_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class Pose PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.Pose) */ {
 public:
  inline Pose() : Pose(nullptr) {};
  virtual ~Pose();

  Pose(const Pose& from);
  Pose(Pose&& from) noexcept
    : Pose() {
    *this = ::std::move(from);
  }

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pose& operator=(Pose&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Pose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pose* internal_default_instance() {
    return reinterpret_cast<const Pose*>(
               &_Pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Pose& a, Pose& b) {
    a.Swap(&b);
  }
  inline void Swap(Pose* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Pose* New() const final {
    return CreateMaybeMessage<Pose>(nullptr);
  }

  Pose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Pose>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Pose& from);
  void MergeFrom(const Pose& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pose* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.Pose";
  }
  protected:
  explicit Pose(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kOrientationFieldNumber = 2,
  };
  // required .mw.internal.robotics.gazebotransport.Point position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::mw::internal::robotics::gazebotransport::Point& position() const;
  ::mw::internal::robotics::gazebotransport::Point* release_position();
  ::mw::internal::robotics::gazebotransport::Point* mutable_position();
  void set_allocated_position(::mw::internal::robotics::gazebotransport::Point* position);
  private:
  const ::mw::internal::robotics::gazebotransport::Point& _internal_position() const;
  ::mw::internal::robotics::gazebotransport::Point* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::mw::internal::robotics::gazebotransport::Point* position);
  ::mw::internal::robotics::gazebotransport::Point* unsafe_arena_release_position();

  // required .mw.internal.robotics.gazebotransport.Quaternion orientation = 2;
  bool has_orientation() const;
  private:
  bool _internal_has_orientation() const;
  public:
  void clear_orientation();
  const ::mw::internal::robotics::gazebotransport::Quaternion& orientation() const;
  ::mw::internal::robotics::gazebotransport::Quaternion* release_orientation();
  ::mw::internal::robotics::gazebotransport::Quaternion* mutable_orientation();
  void set_allocated_orientation(::mw::internal::robotics::gazebotransport::Quaternion* orientation);
  private:
  const ::mw::internal::robotics::gazebotransport::Quaternion& _internal_orientation() const;
  ::mw::internal::robotics::gazebotransport::Quaternion* _internal_mutable_orientation();
  public:
  void unsafe_arena_set_allocated_orientation(
      ::mw::internal::robotics::gazebotransport::Quaternion* orientation);
  ::mw::internal::robotics::gazebotransport::Quaternion* unsafe_arena_release_orientation();

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.Pose)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::mw::internal::robotics::gazebotransport::Point* position_;
  ::mw::internal::robotics::gazebotransport::Quaternion* orientation_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class StopSimulation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.StopSimulation) */ {
 public:
  inline StopSimulation() : StopSimulation(nullptr) {};
  virtual ~StopSimulation();

  StopSimulation(const StopSimulation& from);
  StopSimulation(StopSimulation&& from) noexcept
    : StopSimulation() {
    *this = ::std::move(from);
  }

  inline StopSimulation& operator=(const StopSimulation& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopSimulation& operator=(StopSimulation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StopSimulation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopSimulation* internal_default_instance() {
    return reinterpret_cast<const StopSimulation*>(
               &_StopSimulation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(StopSimulation& a, StopSimulation& b) {
    a.Swap(&b);
  }
  inline void Swap(StopSimulation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopSimulation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StopSimulation* New() const final {
    return CreateMaybeMessage<StopSimulation>(nullptr);
  }

  StopSimulation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StopSimulation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StopSimulation& from);
  void MergeFrom(const StopSimulation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopSimulation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.StopSimulation";
  }
  protected:
  explicit StopSimulation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopSceneFieldNumber = 1,
  };
  // required bool stop_scene = 1;
  bool has_stop_scene() const;
  private:
  bool _internal_has_stop_scene() const;
  public:
  void clear_stop_scene();
  bool stop_scene() const;
  void set_stop_scene(bool value);
  private:
  bool _internal_stop_scene() const;
  void _internal_set_stop_scene(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.StopSimulation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool stop_scene_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class LaserData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.LaserData) */ {
 public:
  inline LaserData() : LaserData(nullptr) {};
  virtual ~LaserData();

  LaserData(const LaserData& from);
  LaserData(LaserData&& from) noexcept
    : LaserData() {
    *this = ::std::move(from);
  }

  inline LaserData& operator=(const LaserData& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaserData& operator=(LaserData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LaserData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaserData* internal_default_instance() {
    return reinterpret_cast<const LaserData*>(
               &_LaserData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(LaserData& a, LaserData& b) {
    a.Swap(&b);
  }
  inline void Swap(LaserData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaserData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LaserData* New() const final {
    return CreateMaybeMessage<LaserData>(nullptr);
  }

  LaserData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LaserData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LaserData& from);
  void MergeFrom(const LaserData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaserData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.LaserData";
  }
  protected:
  explicit LaserData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRangeFieldNumber = 10,
    kIntensitiesFieldNumber = 11,
    kAngleMinFieldNumber = 1,
    kAngleMaxFieldNumber = 2,
    kAngleStepFieldNumber = 3,
    kRangeMinFieldNumber = 4,
    kRangeMaxFieldNumber = 5,
    kCountFieldNumber = 6,
    kVerticalAngleMinFieldNumber = 7,
    kVerticalAngleMaxFieldNumber = 8,
    kVerticalAngleStepFieldNumber = 9,
  };
  // repeated double range = 10;
  int range_size() const;
  private:
  int _internal_range_size() const;
  public:
  void clear_range();
  private:
  double _internal_range(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_range() const;
  void _internal_add_range(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_range();
  public:
  double range(int index) const;
  void set_range(int index, double value);
  void add_range(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      range() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_range();

  // repeated double intensities = 11;
  int intensities_size() const;
  private:
  int _internal_intensities_size() const;
  public:
  void clear_intensities();
  private:
  double _internal_intensities(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_intensities() const;
  void _internal_add_intensities(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_intensities();
  public:
  double intensities(int index) const;
  void set_intensities(int index, double value);
  void add_intensities(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      intensities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_intensities();

  // optional double angle_min = 1;
  bool has_angle_min() const;
  private:
  bool _internal_has_angle_min() const;
  public:
  void clear_angle_min();
  double angle_min() const;
  void set_angle_min(double value);
  private:
  double _internal_angle_min() const;
  void _internal_set_angle_min(double value);
  public:

  // optional double angle_max = 2;
  bool has_angle_max() const;
  private:
  bool _internal_has_angle_max() const;
  public:
  void clear_angle_max();
  double angle_max() const;
  void set_angle_max(double value);
  private:
  double _internal_angle_max() const;
  void _internal_set_angle_max(double value);
  public:

  // optional double angle_step = 3;
  bool has_angle_step() const;
  private:
  bool _internal_has_angle_step() const;
  public:
  void clear_angle_step();
  double angle_step() const;
  void set_angle_step(double value);
  private:
  double _internal_angle_step() const;
  void _internal_set_angle_step(double value);
  public:

  // optional double range_min = 4;
  bool has_range_min() const;
  private:
  bool _internal_has_range_min() const;
  public:
  void clear_range_min();
  double range_min() const;
  void set_range_min(double value);
  private:
  double _internal_range_min() const;
  void _internal_set_range_min(double value);
  public:

  // optional double range_max = 5;
  bool has_range_max() const;
  private:
  bool _internal_has_range_max() const;
  public:
  void clear_range_max();
  double range_max() const;
  void set_range_max(double value);
  private:
  double _internal_range_max() const;
  void _internal_set_range_max(double value);
  public:

  // optional double count = 6;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  double count() const;
  void set_count(double value);
  private:
  double _internal_count() const;
  void _internal_set_count(double value);
  public:

  // optional double vertical_angle_min = 7;
  bool has_vertical_angle_min() const;
  private:
  bool _internal_has_vertical_angle_min() const;
  public:
  void clear_vertical_angle_min();
  double vertical_angle_min() const;
  void set_vertical_angle_min(double value);
  private:
  double _internal_vertical_angle_min() const;
  void _internal_set_vertical_angle_min(double value);
  public:

  // optional double vertical_angle_max = 8;
  bool has_vertical_angle_max() const;
  private:
  bool _internal_has_vertical_angle_max() const;
  public:
  void clear_vertical_angle_max();
  double vertical_angle_max() const;
  void set_vertical_angle_max(double value);
  private:
  double _internal_vertical_angle_max() const;
  void _internal_set_vertical_angle_max(double value);
  public:

  // optional double vertical_angle_step = 9;
  bool has_vertical_angle_step() const;
  private:
  bool _internal_has_vertical_angle_step() const;
  public:
  void clear_vertical_angle_step();
  double vertical_angle_step() const;
  void set_vertical_angle_step(double value);
  private:
  double _internal_vertical_angle_step() const;
  void _internal_set_vertical_angle_step(double value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.LaserData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > range_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > intensities_;
  double angle_min_;
  double angle_max_;
  double angle_step_;
  double range_min_;
  double range_max_;
  double count_;
  double vertical_angle_min_;
  double vertical_angle_max_;
  double vertical_angle_step_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class RequestLaser PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.RequestLaser) */ {
 public:
  inline RequestLaser() : RequestLaser(nullptr) {};
  virtual ~RequestLaser();

  RequestLaser(const RequestLaser& from);
  RequestLaser(RequestLaser&& from) noexcept
    : RequestLaser() {
    *this = ::std::move(from);
  }

  inline RequestLaser& operator=(const RequestLaser& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestLaser& operator=(RequestLaser&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestLaser& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestLaser* internal_default_instance() {
    return reinterpret_cast<const RequestLaser*>(
               &_RequestLaser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RequestLaser& a, RequestLaser& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestLaser* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestLaser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestLaser* New() const final {
    return CreateMaybeMessage<RequestLaser>(nullptr);
  }

  RequestLaser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestLaser>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestLaser& from);
  void MergeFrom(const RequestLaser& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestLaser* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.RequestLaser";
  }
  protected:
  explicit RequestLaser(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicNameFieldNumber = 1,
  };
  // required string topic_name = 1;
  bool has_topic_name() const;
  private:
  bool _internal_has_topic_name() const;
  public:
  void clear_topic_name();
  const std::string& topic_name() const;
  void set_topic_name(const std::string& value);
  void set_topic_name(std::string&& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  std::string* mutable_topic_name();
  std::string* release_topic_name();
  void set_allocated_topic_name(std::string* topic_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_topic_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_topic_name(
      std::string* topic_name);
  private:
  const std::string& _internal_topic_name() const;
  void _internal_set_topic_name(const std::string& value);
  std::string* _internal_mutable_topic_name();
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.RequestLaser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_name_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class ImuData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ImuData) */ {
 public:
  inline ImuData() : ImuData(nullptr) {};
  virtual ~ImuData();

  ImuData(const ImuData& from);
  ImuData(ImuData&& from) noexcept
    : ImuData() {
    *this = ::std::move(from);
  }

  inline ImuData& operator=(const ImuData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImuData& operator=(ImuData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImuData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImuData* internal_default_instance() {
    return reinterpret_cast<const ImuData*>(
               &_ImuData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ImuData& a, ImuData& b) {
    a.Swap(&b);
  }
  inline void Swap(ImuData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImuData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImuData* New() const final {
    return CreateMaybeMessage<ImuData>(nullptr);
  }

  ImuData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImuData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImuData& from);
  void MergeFrom(const ImuData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImuData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.ImuData";
  }
  protected:
  explicit ImuData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinearAccelerationFieldNumber = 1,
    kAngularVelocityFieldNumber = 2,
    kOrientationFieldNumber = 3,
  };
  // optional .mw.internal.robotics.gazebotransport.Point linear_acceleration = 1;
  bool has_linear_acceleration() const;
  private:
  bool _internal_has_linear_acceleration() const;
  public:
  void clear_linear_acceleration();
  const ::mw::internal::robotics::gazebotransport::Point& linear_acceleration() const;
  ::mw::internal::robotics::gazebotransport::Point* release_linear_acceleration();
  ::mw::internal::robotics::gazebotransport::Point* mutable_linear_acceleration();
  void set_allocated_linear_acceleration(::mw::internal::robotics::gazebotransport::Point* linear_acceleration);
  private:
  const ::mw::internal::robotics::gazebotransport::Point& _internal_linear_acceleration() const;
  ::mw::internal::robotics::gazebotransport::Point* _internal_mutable_linear_acceleration();
  public:
  void unsafe_arena_set_allocated_linear_acceleration(
      ::mw::internal::robotics::gazebotransport::Point* linear_acceleration);
  ::mw::internal::robotics::gazebotransport::Point* unsafe_arena_release_linear_acceleration();

  // optional .mw.internal.robotics.gazebotransport.Point angular_velocity = 2;
  bool has_angular_velocity() const;
  private:
  bool _internal_has_angular_velocity() const;
  public:
  void clear_angular_velocity();
  const ::mw::internal::robotics::gazebotransport::Point& angular_velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* release_angular_velocity();
  ::mw::internal::robotics::gazebotransport::Point* mutable_angular_velocity();
  void set_allocated_angular_velocity(::mw::internal::robotics::gazebotransport::Point* angular_velocity);
  private:
  const ::mw::internal::robotics::gazebotransport::Point& _internal_angular_velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* _internal_mutable_angular_velocity();
  public:
  void unsafe_arena_set_allocated_angular_velocity(
      ::mw::internal::robotics::gazebotransport::Point* angular_velocity);
  ::mw::internal::robotics::gazebotransport::Point* unsafe_arena_release_angular_velocity();

  // optional .mw.internal.robotics.gazebotransport.Quaternion orientation = 3;
  bool has_orientation() const;
  private:
  bool _internal_has_orientation() const;
  public:
  void clear_orientation();
  const ::mw::internal::robotics::gazebotransport::Quaternion& orientation() const;
  ::mw::internal::robotics::gazebotransport::Quaternion* release_orientation();
  ::mw::internal::robotics::gazebotransport::Quaternion* mutable_orientation();
  void set_allocated_orientation(::mw::internal::robotics::gazebotransport::Quaternion* orientation);
  private:
  const ::mw::internal::robotics::gazebotransport::Quaternion& _internal_orientation() const;
  ::mw::internal::robotics::gazebotransport::Quaternion* _internal_mutable_orientation();
  public:
  void unsafe_arena_set_allocated_orientation(
      ::mw::internal::robotics::gazebotransport::Quaternion* orientation);
  ::mw::internal::robotics::gazebotransport::Quaternion* unsafe_arena_release_orientation();

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ImuData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::mw::internal::robotics::gazebotransport::Point* linear_acceleration_;
  ::mw::internal::robotics::gazebotransport::Point* angular_velocity_;
  ::mw::internal::robotics::gazebotransport::Quaternion* orientation_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class RequestImu PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.RequestImu) */ {
 public:
  inline RequestImu() : RequestImu(nullptr) {};
  virtual ~RequestImu();

  RequestImu(const RequestImu& from);
  RequestImu(RequestImu&& from) noexcept
    : RequestImu() {
    *this = ::std::move(from);
  }

  inline RequestImu& operator=(const RequestImu& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestImu& operator=(RequestImu&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestImu& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestImu* internal_default_instance() {
    return reinterpret_cast<const RequestImu*>(
               &_RequestImu_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RequestImu& a, RequestImu& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestImu* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestImu* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestImu* New() const final {
    return CreateMaybeMessage<RequestImu>(nullptr);
  }

  RequestImu* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestImu>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestImu& from);
  void MergeFrom(const RequestImu& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestImu* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.RequestImu";
  }
  protected:
  explicit RequestImu(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicNameFieldNumber = 1,
  };
  // required string topic_name = 1;
  bool has_topic_name() const;
  private:
  bool _internal_has_topic_name() const;
  public:
  void clear_topic_name();
  const std::string& topic_name() const;
  void set_topic_name(const std::string& value);
  void set_topic_name(std::string&& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  std::string* mutable_topic_name();
  std::string* release_topic_name();
  void set_allocated_topic_name(std::string* topic_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_topic_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_topic_name(
      std::string* topic_name);
  private:
  const std::string& _internal_topic_name() const;
  void _internal_set_topic_name(const std::string& value);
  std::string* _internal_mutable_topic_name();
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.RequestImu)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_name_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class SubscribeImage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.SubscribeImage) */ {
 public:
  inline SubscribeImage() : SubscribeImage(nullptr) {};
  virtual ~SubscribeImage();

  SubscribeImage(const SubscribeImage& from);
  SubscribeImage(SubscribeImage&& from) noexcept
    : SubscribeImage() {
    *this = ::std::move(from);
  }

  inline SubscribeImage& operator=(const SubscribeImage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeImage& operator=(SubscribeImage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SubscribeImage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubscribeImage* internal_default_instance() {
    return reinterpret_cast<const SubscribeImage*>(
               &_SubscribeImage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SubscribeImage& a, SubscribeImage& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeImage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeImage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubscribeImage* New() const final {
    return CreateMaybeMessage<SubscribeImage>(nullptr);
  }

  SubscribeImage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubscribeImage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SubscribeImage& from);
  void MergeFrom(const SubscribeImage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeImage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.SubscribeImage";
  }
  protected:
  explicit SubscribeImage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicNameFieldNumber = 1,
  };
  // required string topic_name = 1;
  bool has_topic_name() const;
  private:
  bool _internal_has_topic_name() const;
  public:
  void clear_topic_name();
  const std::string& topic_name() const;
  void set_topic_name(const std::string& value);
  void set_topic_name(std::string&& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  std::string* mutable_topic_name();
  std::string* release_topic_name();
  void set_allocated_topic_name(std::string* topic_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_topic_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_topic_name(
      std::string* topic_name);
  private:
  const std::string& _internal_topic_name() const;
  void _internal_set_topic_name(const std::string& value);
  std::string* _internal_mutable_topic_name();
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.SubscribeImage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_name_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class SubscribeLaser PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.SubscribeLaser) */ {
 public:
  inline SubscribeLaser() : SubscribeLaser(nullptr) {};
  virtual ~SubscribeLaser();

  SubscribeLaser(const SubscribeLaser& from);
  SubscribeLaser(SubscribeLaser&& from) noexcept
    : SubscribeLaser() {
    *this = ::std::move(from);
  }

  inline SubscribeLaser& operator=(const SubscribeLaser& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeLaser& operator=(SubscribeLaser&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SubscribeLaser& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubscribeLaser* internal_default_instance() {
    return reinterpret_cast<const SubscribeLaser*>(
               &_SubscribeLaser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SubscribeLaser& a, SubscribeLaser& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeLaser* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeLaser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubscribeLaser* New() const final {
    return CreateMaybeMessage<SubscribeLaser>(nullptr);
  }

  SubscribeLaser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubscribeLaser>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SubscribeLaser& from);
  void MergeFrom(const SubscribeLaser& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeLaser* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.SubscribeLaser";
  }
  protected:
  explicit SubscribeLaser(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicNameFieldNumber = 1,
  };
  // required string topic_name = 1;
  bool has_topic_name() const;
  private:
  bool _internal_has_topic_name() const;
  public:
  void clear_topic_name();
  const std::string& topic_name() const;
  void set_topic_name(const std::string& value);
  void set_topic_name(std::string&& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  std::string* mutable_topic_name();
  std::string* release_topic_name();
  void set_allocated_topic_name(std::string* topic_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_topic_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_topic_name(
      std::string* topic_name);
  private:
  const std::string& _internal_topic_name() const;
  void _internal_set_topic_name(const std::string& value);
  std::string* _internal_mutable_topic_name();
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.SubscribeLaser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_name_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class SubscribeImu PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.SubscribeImu) */ {
 public:
  inline SubscribeImu() : SubscribeImu(nullptr) {};
  virtual ~SubscribeImu();

  SubscribeImu(const SubscribeImu& from);
  SubscribeImu(SubscribeImu&& from) noexcept
    : SubscribeImu() {
    *this = ::std::move(from);
  }

  inline SubscribeImu& operator=(const SubscribeImu& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeImu& operator=(SubscribeImu&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SubscribeImu& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubscribeImu* internal_default_instance() {
    return reinterpret_cast<const SubscribeImu*>(
               &_SubscribeImu_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SubscribeImu& a, SubscribeImu& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeImu* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeImu* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubscribeImu* New() const final {
    return CreateMaybeMessage<SubscribeImu>(nullptr);
  }

  SubscribeImu* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubscribeImu>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SubscribeImu& from);
  void MergeFrom(const SubscribeImu& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeImu* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.SubscribeImu";
  }
  protected:
  explicit SubscribeImu(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicNameFieldNumber = 1,
  };
  // required string topic_name = 1;
  bool has_topic_name() const;
  private:
  bool _internal_has_topic_name() const;
  public:
  void clear_topic_name();
  const std::string& topic_name() const;
  void set_topic_name(const std::string& value);
  void set_topic_name(std::string&& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  std::string* mutable_topic_name();
  std::string* release_topic_name();
  void set_allocated_topic_name(std::string* topic_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_topic_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_topic_name(
      std::string* topic_name);
  private:
  const std::string& _internal_topic_name() const;
  void _internal_set_topic_name(const std::string& value);
  std::string* _internal_mutable_topic_name();
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.SubscribeImu)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_name_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class ApplyLinkWrench PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ApplyLinkWrench) */ {
 public:
  inline ApplyLinkWrench() : ApplyLinkWrench(nullptr) {};
  virtual ~ApplyLinkWrench();

  ApplyLinkWrench(const ApplyLinkWrench& from);
  ApplyLinkWrench(ApplyLinkWrench&& from) noexcept
    : ApplyLinkWrench() {
    *this = ::std::move(from);
  }

  inline ApplyLinkWrench& operator=(const ApplyLinkWrench& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyLinkWrench& operator=(ApplyLinkWrench&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ApplyLinkWrench& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ApplyLinkWrench* internal_default_instance() {
    return reinterpret_cast<const ApplyLinkWrench*>(
               &_ApplyLinkWrench_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ApplyLinkWrench& a, ApplyLinkWrench& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyLinkWrench* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyLinkWrench* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ApplyLinkWrench* New() const final {
    return CreateMaybeMessage<ApplyLinkWrench>(nullptr);
  }

  ApplyLinkWrench* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ApplyLinkWrench>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ApplyLinkWrench& from);
  void MergeFrom(const ApplyLinkWrench& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyLinkWrench* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.ApplyLinkWrench";
  }
  protected:
  explicit ApplyLinkWrench(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 1,
    kLinkNameFieldNumber = 2,
    kForceTypeFieldNumber = 3,
    kTorqueTypeFieldNumber = 7,
    kDurationFieldNumber = 11,
    kFxFieldNumber = 4,
    kFyFieldNumber = 5,
    kFzFieldNumber = 6,
    kTxFieldNumber = 8,
    kTyFieldNumber = 9,
    kTzFieldNumber = 10,
  };
  // required string model_name = 1;
  bool has_model_name() const;
  private:
  bool _internal_has_model_name() const;
  public:
  void clear_model_name();
  const std::string& model_name() const;
  void set_model_name(const std::string& value);
  void set_model_name(std::string&& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  std::string* mutable_model_name();
  std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_model_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_model_name(
      std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // required string link_name = 2;
  bool has_link_name() const;
  private:
  bool _internal_has_link_name() const;
  public:
  void clear_link_name();
  const std::string& link_name() const;
  void set_link_name(const std::string& value);
  void set_link_name(std::string&& value);
  void set_link_name(const char* value);
  void set_link_name(const char* value, size_t size);
  std::string* mutable_link_name();
  std::string* release_link_name();
  void set_allocated_link_name(std::string* link_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_link_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_link_name(
      std::string* link_name);
  private:
  const std::string& _internal_link_name() const;
  void _internal_set_link_name(const std::string& value);
  std::string* _internal_mutable_link_name();
  public:

  // required string force_type = 3;
  bool has_force_type() const;
  private:
  bool _internal_has_force_type() const;
  public:
  void clear_force_type();
  const std::string& force_type() const;
  void set_force_type(const std::string& value);
  void set_force_type(std::string&& value);
  void set_force_type(const char* value);
  void set_force_type(const char* value, size_t size);
  std::string* mutable_force_type();
  std::string* release_force_type();
  void set_allocated_force_type(std::string* force_type);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_force_type();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_force_type(
      std::string* force_type);
  private:
  const std::string& _internal_force_type() const;
  void _internal_set_force_type(const std::string& value);
  std::string* _internal_mutable_force_type();
  public:

  // required string torque_type = 7;
  bool has_torque_type() const;
  private:
  bool _internal_has_torque_type() const;
  public:
  void clear_torque_type();
  const std::string& torque_type() const;
  void set_torque_type(const std::string& value);
  void set_torque_type(std::string&& value);
  void set_torque_type(const char* value);
  void set_torque_type(const char* value, size_t size);
  std::string* mutable_torque_type();
  std::string* release_torque_type();
  void set_allocated_torque_type(std::string* torque_type);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_torque_type();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_torque_type(
      std::string* torque_type);
  private:
  const std::string& _internal_torque_type() const;
  void _internal_set_torque_type(const std::string& value);
  std::string* _internal_mutable_torque_type();
  public:

  // required .mw.internal.robotics.gazebotransport.Time duration = 11;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  const ::mw::internal::robotics::gazebotransport::Time& duration() const;
  ::mw::internal::robotics::gazebotransport::Time* release_duration();
  ::mw::internal::robotics::gazebotransport::Time* mutable_duration();
  void set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration);
  private:
  const ::mw::internal::robotics::gazebotransport::Time& _internal_duration() const;
  ::mw::internal::robotics::gazebotransport::Time* _internal_mutable_duration();
  public:
  void unsafe_arena_set_allocated_duration(
      ::mw::internal::robotics::gazebotransport::Time* duration);
  ::mw::internal::robotics::gazebotransport::Time* unsafe_arena_release_duration();

  // required double fx = 4;
  bool has_fx() const;
  private:
  bool _internal_has_fx() const;
  public:
  void clear_fx();
  double fx() const;
  void set_fx(double value);
  private:
  double _internal_fx() const;
  void _internal_set_fx(double value);
  public:

  // required double fy = 5;
  bool has_fy() const;
  private:
  bool _internal_has_fy() const;
  public:
  void clear_fy();
  double fy() const;
  void set_fy(double value);
  private:
  double _internal_fy() const;
  void _internal_set_fy(double value);
  public:

  // required double fz = 6;
  bool has_fz() const;
  private:
  bool _internal_has_fz() const;
  public:
  void clear_fz();
  double fz() const;
  void set_fz(double value);
  private:
  double _internal_fz() const;
  void _internal_set_fz(double value);
  public:

  // required double tx = 8;
  bool has_tx() const;
  private:
  bool _internal_has_tx() const;
  public:
  void clear_tx();
  double tx() const;
  void set_tx(double value);
  private:
  double _internal_tx() const;
  void _internal_set_tx(double value);
  public:

  // required double ty = 9;
  bool has_ty() const;
  private:
  bool _internal_has_ty() const;
  public:
  void clear_ty();
  double ty() const;
  void set_ty(double value);
  private:
  double _internal_ty() const;
  void _internal_set_ty(double value);
  public:

  // required double tz = 10;
  bool has_tz() const;
  private:
  bool _internal_has_tz() const;
  public:
  void clear_tz();
  double tz() const;
  void set_tz(double value);
  private:
  double _internal_tz() const;
  void _internal_set_tz(double value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr force_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr torque_type_;
  ::mw::internal::robotics::gazebotransport::Time* duration_;
  double fx_;
  double fy_;
  double fz_;
  double tx_;
  double ty_;
  double tz_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class ApplyJointTorque PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ApplyJointTorque) */ {
 public:
  inline ApplyJointTorque() : ApplyJointTorque(nullptr) {};
  virtual ~ApplyJointTorque();

  ApplyJointTorque(const ApplyJointTorque& from);
  ApplyJointTorque(ApplyJointTorque&& from) noexcept
    : ApplyJointTorque() {
    *this = ::std::move(from);
  }

  inline ApplyJointTorque& operator=(const ApplyJointTorque& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyJointTorque& operator=(ApplyJointTorque&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ApplyJointTorque& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ApplyJointTorque* internal_default_instance() {
    return reinterpret_cast<const ApplyJointTorque*>(
               &_ApplyJointTorque_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ApplyJointTorque& a, ApplyJointTorque& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyJointTorque* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyJointTorque* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ApplyJointTorque* New() const final {
    return CreateMaybeMessage<ApplyJointTorque>(nullptr);
  }

  ApplyJointTorque* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ApplyJointTorque>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ApplyJointTorque& from);
  void MergeFrom(const ApplyJointTorque& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyJointTorque* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.ApplyJointTorque";
  }
  protected:
  explicit ApplyJointTorque(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 1,
    kJointNameFieldNumber = 2,
    kDurationFieldNumber = 5,
    kEffortFieldNumber = 4,
    kIndexFieldNumber = 3,
  };
  // required string model_name = 1;
  bool has_model_name() const;
  private:
  bool _internal_has_model_name() const;
  public:
  void clear_model_name();
  const std::string& model_name() const;
  void set_model_name(const std::string& value);
  void set_model_name(std::string&& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  std::string* mutable_model_name();
  std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_model_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_model_name(
      std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // required string joint_name = 2;
  bool has_joint_name() const;
  private:
  bool _internal_has_joint_name() const;
  public:
  void clear_joint_name();
  const std::string& joint_name() const;
  void set_joint_name(const std::string& value);
  void set_joint_name(std::string&& value);
  void set_joint_name(const char* value);
  void set_joint_name(const char* value, size_t size);
  std::string* mutable_joint_name();
  std::string* release_joint_name();
  void set_allocated_joint_name(std::string* joint_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_joint_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_joint_name(
      std::string* joint_name);
  private:
  const std::string& _internal_joint_name() const;
  void _internal_set_joint_name(const std::string& value);
  std::string* _internal_mutable_joint_name();
  public:

  // required .mw.internal.robotics.gazebotransport.Time duration = 5;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  const ::mw::internal::robotics::gazebotransport::Time& duration() const;
  ::mw::internal::robotics::gazebotransport::Time* release_duration();
  ::mw::internal::robotics::gazebotransport::Time* mutable_duration();
  void set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration);
  private:
  const ::mw::internal::robotics::gazebotransport::Time& _internal_duration() const;
  ::mw::internal::robotics::gazebotransport::Time* _internal_mutable_duration();
  public:
  void unsafe_arena_set_allocated_duration(
      ::mw::internal::robotics::gazebotransport::Time* duration);
  ::mw::internal::robotics::gazebotransport::Time* unsafe_arena_release_duration();

  // required double effort = 4;
  bool has_effort() const;
  private:
  bool _internal_has_effort() const;
  public:
  void clear_effort();
  double effort() const;
  void set_effort(double value);
  private:
  double _internal_effort() const;
  void _internal_set_effort(double value);
  public:

  // required uint32 index = 3;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  ::PROTOBUF_NAMESPACE_ID::uint32 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_index() const;
  void _internal_set_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ApplyJointTorque)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr joint_name_;
  ::mw::internal::robotics::gazebotransport::Time* duration_;
  double effort_;
  ::PROTOBUF_NAMESPACE_ID::uint32 index_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class GetPose PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.GetPose) */ {
 public:
  inline GetPose() : GetPose(nullptr) {};
  virtual ~GetPose();

  GetPose(const GetPose& from);
  GetPose(GetPose&& from) noexcept
    : GetPose() {
    *this = ::std::move(from);
  }

  inline GetPose& operator=(const GetPose& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPose& operator=(GetPose&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetPose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetPose* internal_default_instance() {
    return reinterpret_cast<const GetPose*>(
               &_GetPose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(GetPose& a, GetPose& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPose* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetPose* New() const final {
    return CreateMaybeMessage<GetPose>(nullptr);
  }

  GetPose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetPose>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetPose& from);
  void MergeFrom(const GetPose& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPose* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.GetPose";
  }
  protected:
  explicit GetPose(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 1,
  };
  // required string model_name = 1;
  bool has_model_name() const;
  private:
  bool _internal_has_model_name() const;
  public:
  void clear_model_name();
  const std::string& model_name() const;
  void set_model_name(const std::string& value);
  void set_model_name(std::string&& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  std::string* mutable_model_name();
  std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_model_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_model_name(
      std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.GetPose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class GetTopicList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.GetTopicList) */ {
 public:
  inline GetTopicList() : GetTopicList(nullptr) {};
  virtual ~GetTopicList();

  GetTopicList(const GetTopicList& from);
  GetTopicList(GetTopicList&& from) noexcept
    : GetTopicList() {
    *this = ::std::move(from);
  }

  inline GetTopicList& operator=(const GetTopicList& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTopicList& operator=(GetTopicList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetTopicList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTopicList* internal_default_instance() {
    return reinterpret_cast<const GetTopicList*>(
               &_GetTopicList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(GetTopicList& a, GetTopicList& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTopicList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTopicList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTopicList* New() const final {
    return CreateMaybeMessage<GetTopicList>(nullptr);
  }

  GetTopicList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTopicList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetTopicList& from);
  void MergeFrom(const GetTopicList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTopicList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.GetTopicList";
  }
  protected:
  explicit GetTopicList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicNameFieldNumber = 1,
  };
  // required string topic_name = 1;
  bool has_topic_name() const;
  private:
  bool _internal_has_topic_name() const;
  public:
  void clear_topic_name();
  const std::string& topic_name() const;
  void set_topic_name(const std::string& value);
  void set_topic_name(std::string&& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  std::string* mutable_topic_name();
  std::string* release_topic_name();
  void set_allocated_topic_name(std::string* topic_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_topic_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_topic_name(
      std::string* topic_name);
  private:
  const std::string& _internal_topic_name() const;
  void _internal_set_topic_name(const std::string& value);
  std::string* _internal_mutable_topic_name();
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.GetTopicList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_name_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class TopicList_TopicInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.TopicList.TopicInfo) */ {
 public:
  inline TopicList_TopicInfo() : TopicList_TopicInfo(nullptr) {};
  virtual ~TopicList_TopicInfo();

  TopicList_TopicInfo(const TopicList_TopicInfo& from);
  TopicList_TopicInfo(TopicList_TopicInfo&& from) noexcept
    : TopicList_TopicInfo() {
    *this = ::std::move(from);
  }

  inline TopicList_TopicInfo& operator=(const TopicList_TopicInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TopicList_TopicInfo& operator=(TopicList_TopicInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TopicList_TopicInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TopicList_TopicInfo* internal_default_instance() {
    return reinterpret_cast<const TopicList_TopicInfo*>(
               &_TopicList_TopicInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(TopicList_TopicInfo& a, TopicList_TopicInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TopicList_TopicInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TopicList_TopicInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TopicList_TopicInfo* New() const final {
    return CreateMaybeMessage<TopicList_TopicInfo>(nullptr);
  }

  TopicList_TopicInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TopicList_TopicInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TopicList_TopicInfo& from);
  void MergeFrom(const TopicList_TopicInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TopicList_TopicInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.TopicList.TopicInfo";
  }
  protected:
  explicit TopicList_TopicInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required string type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  void set_type(const std::string& value);
  void set_type(std::string&& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  std::string* mutable_type();
  std::string* release_type();
  void set_allocated_type(std::string* type);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_type();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_type(
      std::string* type);
  private:
  const std::string& _internal_type() const;
  void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class TopicList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.TopicList) */ {
 public:
  inline TopicList() : TopicList(nullptr) {};
  virtual ~TopicList();

  TopicList(const TopicList& from);
  TopicList(TopicList&& from) noexcept
    : TopicList() {
    *this = ::std::move(from);
  }

  inline TopicList& operator=(const TopicList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TopicList& operator=(TopicList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TopicList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TopicList* internal_default_instance() {
    return reinterpret_cast<const TopicList*>(
               &_TopicList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(TopicList& a, TopicList& b) {
    a.Swap(&b);
  }
  inline void Swap(TopicList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TopicList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TopicList* New() const final {
    return CreateMaybeMessage<TopicList>(nullptr);
  }

  TopicList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TopicList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TopicList& from);
  void MergeFrom(const TopicList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TopicList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.TopicList";
  }
  protected:
  explicit TopicList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TopicList_TopicInfo TopicInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated .mw.internal.robotics.gazebotransport.TopicList.TopicInfo data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo >*
      mutable_data();
  private:
  const ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo& _internal_data(int index) const;
  ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo* _internal_add_data();
  public:
  const ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo& data(int index) const;
  ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo >&
      data() const;

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.TopicList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo > data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class GetModelInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.GetModelInfo) */ {
 public:
  inline GetModelInfo() : GetModelInfo(nullptr) {};
  virtual ~GetModelInfo();

  GetModelInfo(const GetModelInfo& from);
  GetModelInfo(GetModelInfo&& from) noexcept
    : GetModelInfo() {
    *this = ::std::move(from);
  }

  inline GetModelInfo& operator=(const GetModelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetModelInfo& operator=(GetModelInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetModelInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetModelInfo* internal_default_instance() {
    return reinterpret_cast<const GetModelInfo*>(
               &_GetModelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(GetModelInfo& a, GetModelInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GetModelInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetModelInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetModelInfo* New() const final {
    return CreateMaybeMessage<GetModelInfo>(nullptr);
  }

  GetModelInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetModelInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetModelInfo& from);
  void MergeFrom(const GetModelInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetModelInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.GetModelInfo";
  }
  protected:
  explicit GetModelInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicNameFieldNumber = 1,
  };
  // required string topic_name = 1;
  bool has_topic_name() const;
  private:
  bool _internal_has_topic_name() const;
  public:
  void clear_topic_name();
  const std::string& topic_name() const;
  void set_topic_name(const std::string& value);
  void set_topic_name(std::string&& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  std::string* mutable_topic_name();
  std::string* release_topic_name();
  void set_allocated_topic_name(std::string* topic_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_topic_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_topic_name(
      std::string* topic_name);
  private:
  const std::string& _internal_topic_name() const;
  void _internal_set_topic_name(const std::string& value);
  std::string* _internal_mutable_topic_name();
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.GetModelInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_name_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class ModelInfo_LINKS PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ModelInfo.LINKS) */ {
 public:
  inline ModelInfo_LINKS() : ModelInfo_LINKS(nullptr) {};
  virtual ~ModelInfo_LINKS();

  ModelInfo_LINKS(const ModelInfo_LINKS& from);
  ModelInfo_LINKS(ModelInfo_LINKS&& from) noexcept
    : ModelInfo_LINKS() {
    *this = ::std::move(from);
  }

  inline ModelInfo_LINKS& operator=(const ModelInfo_LINKS& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelInfo_LINKS& operator=(ModelInfo_LINKS&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelInfo_LINKS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelInfo_LINKS* internal_default_instance() {
    return reinterpret_cast<const ModelInfo_LINKS*>(
               &_ModelInfo_LINKS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ModelInfo_LINKS& a, ModelInfo_LINKS& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelInfo_LINKS* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelInfo_LINKS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelInfo_LINKS* New() const final {
    return CreateMaybeMessage<ModelInfo_LINKS>(nullptr);
  }

  ModelInfo_LINKS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelInfo_LINKS>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelInfo_LINKS& from);
  void MergeFrom(const ModelInfo_LINKS& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInfo_LINKS* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.ModelInfo.LINKS";
  }
  protected:
  explicit ModelInfo_LINKS(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinkNameFieldNumber = 1,
  };
  // repeated string link_name = 1;
  int link_name_size() const;
  private:
  int _internal_link_name_size() const;
  public:
  void clear_link_name();
  const std::string& link_name(int index) const;
  std::string* mutable_link_name(int index);
  void set_link_name(int index, const std::string& value);
  void set_link_name(int index, std::string&& value);
  void set_link_name(int index, const char* value);
  void set_link_name(int index, const char* value, size_t size);
  std::string* add_link_name();
  void add_link_name(const std::string& value);
  void add_link_name(std::string&& value);
  void add_link_name(const char* value);
  void add_link_name(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& link_name() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_link_name();
  private:
  const std::string& _internal_link_name(int index) const;
  std::string* _internal_add_link_name();
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> link_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class ModelInfo_JOINTS PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS) */ {
 public:
  inline ModelInfo_JOINTS() : ModelInfo_JOINTS(nullptr) {};
  virtual ~ModelInfo_JOINTS();

  ModelInfo_JOINTS(const ModelInfo_JOINTS& from);
  ModelInfo_JOINTS(ModelInfo_JOINTS&& from) noexcept
    : ModelInfo_JOINTS() {
    *this = ::std::move(from);
  }

  inline ModelInfo_JOINTS& operator=(const ModelInfo_JOINTS& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelInfo_JOINTS& operator=(ModelInfo_JOINTS&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelInfo_JOINTS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelInfo_JOINTS* internal_default_instance() {
    return reinterpret_cast<const ModelInfo_JOINTS*>(
               &_ModelInfo_JOINTS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ModelInfo_JOINTS& a, ModelInfo_JOINTS& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelInfo_JOINTS* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelInfo_JOINTS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelInfo_JOINTS* New() const final {
    return CreateMaybeMessage<ModelInfo_JOINTS>(nullptr);
  }

  ModelInfo_JOINTS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelInfo_JOINTS>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelInfo_JOINTS& from);
  void MergeFrom(const ModelInfo_JOINTS& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInfo_JOINTS* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.ModelInfo.JOINTS";
  }
  protected:
  explicit ModelInfo_JOINTS(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointNameFieldNumber = 1,
  };
  // repeated string joint_name = 1;
  int joint_name_size() const;
  private:
  int _internal_joint_name_size() const;
  public:
  void clear_joint_name();
  const std::string& joint_name(int index) const;
  std::string* mutable_joint_name(int index);
  void set_joint_name(int index, const std::string& value);
  void set_joint_name(int index, std::string&& value);
  void set_joint_name(int index, const char* value);
  void set_joint_name(int index, const char* value, size_t size);
  std::string* add_joint_name();
  void add_joint_name(const std::string& value);
  void add_joint_name(std::string&& value);
  void add_joint_name(const char* value);
  void add_joint_name(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& joint_name() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_joint_name();
  private:
  const std::string& _internal_joint_name(int index) const;
  std::string* _internal_add_joint_name();
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> joint_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class ModelInfo_Model PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ModelInfo.Model) */ {
 public:
  inline ModelInfo_Model() : ModelInfo_Model(nullptr) {};
  virtual ~ModelInfo_Model();

  ModelInfo_Model(const ModelInfo_Model& from);
  ModelInfo_Model(ModelInfo_Model&& from) noexcept
    : ModelInfo_Model() {
    *this = ::std::move(from);
  }

  inline ModelInfo_Model& operator=(const ModelInfo_Model& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelInfo_Model& operator=(ModelInfo_Model&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelInfo_Model& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelInfo_Model* internal_default_instance() {
    return reinterpret_cast<const ModelInfo_Model*>(
               &_ModelInfo_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ModelInfo_Model& a, ModelInfo_Model& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelInfo_Model* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelInfo_Model* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelInfo_Model* New() const final {
    return CreateMaybeMessage<ModelInfo_Model>(nullptr);
  }

  ModelInfo_Model* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelInfo_Model>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelInfo_Model& from);
  void MergeFrom(const ModelInfo_Model& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInfo_Model* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.ModelInfo.Model";
  }
  protected:
  explicit ModelInfo_Model(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 1,
    kLinksFieldNumber = 2,
    kJointsFieldNumber = 3,
  };
  // required string model_name = 1;
  bool has_model_name() const;
  private:
  bool _internal_has_model_name() const;
  public:
  void clear_model_name();
  const std::string& model_name() const;
  void set_model_name(const std::string& value);
  void set_model_name(std::string&& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  std::string* mutable_model_name();
  std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_model_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_model_name(
      std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // optional .mw.internal.robotics.gazebotransport.ModelInfo.LINKS links = 2;
  bool has_links() const;
  private:
  bool _internal_has_links() const;
  public:
  void clear_links();
  const ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS& links() const;
  ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* release_links();
  ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* mutable_links();
  void set_allocated_links(::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* links);
  private:
  const ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS& _internal_links() const;
  ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* _internal_mutable_links();
  public:
  void unsafe_arena_set_allocated_links(
      ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* links);
  ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* unsafe_arena_release_links();

  // optional .mw.internal.robotics.gazebotransport.ModelInfo.JOINTS joints = 3;
  bool has_joints() const;
  private:
  bool _internal_has_joints() const;
  public:
  void clear_joints();
  const ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS& joints() const;
  ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* release_joints();
  ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* mutable_joints();
  void set_allocated_joints(::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* joints);
  private:
  const ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS& _internal_joints() const;
  ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* _internal_mutable_joints();
  public:
  void unsafe_arena_set_allocated_joints(
      ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* joints);
  ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* unsafe_arena_release_joints();

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ModelInfo.Model)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
  ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* links_;
  ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* joints_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class ModelInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ModelInfo) */ {
 public:
  inline ModelInfo() : ModelInfo(nullptr) {};
  virtual ~ModelInfo();

  ModelInfo(const ModelInfo& from);
  ModelInfo(ModelInfo&& from) noexcept
    : ModelInfo() {
    *this = ::std::move(from);
  }

  inline ModelInfo& operator=(const ModelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelInfo& operator=(ModelInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelInfo* internal_default_instance() {
    return reinterpret_cast<const ModelInfo*>(
               &_ModelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ModelInfo& a, ModelInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelInfo* New() const final {
    return CreateMaybeMessage<ModelInfo>(nullptr);
  }

  ModelInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelInfo& from);
  void MergeFrom(const ModelInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.ModelInfo";
  }
  protected:
  explicit ModelInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ModelInfo_LINKS LINKS;
  typedef ModelInfo_JOINTS JOINTS;
  typedef ModelInfo_Model Model;

  // accessors -------------------------------------------------------

  enum : int {
    kModelDataFieldNumber = 1,
  };
  // repeated .mw.internal.robotics.gazebotransport.ModelInfo.Model model_data = 1;
  int model_data_size() const;
  private:
  int _internal_model_data_size() const;
  public:
  void clear_model_data();
  ::mw::internal::robotics::gazebotransport::ModelInfo_Model* mutable_model_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ModelInfo_Model >*
      mutable_model_data();
  private:
  const ::mw::internal::robotics::gazebotransport::ModelInfo_Model& _internal_model_data(int index) const;
  ::mw::internal::robotics::gazebotransport::ModelInfo_Model* _internal_add_model_data();
  public:
  const ::mw::internal::robotics::gazebotransport::ModelInfo_Model& model_data(int index) const;
  ::mw::internal::robotics::gazebotransport::ModelInfo_Model* add_model_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ModelInfo_Model >&
      model_data() const;

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ModelInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ModelInfo_Model > model_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class MaxStepSize PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.MaxStepSize) */ {
 public:
  inline MaxStepSize() : MaxStepSize(nullptr) {};
  virtual ~MaxStepSize();

  MaxStepSize(const MaxStepSize& from);
  MaxStepSize(MaxStepSize&& from) noexcept
    : MaxStepSize() {
    *this = ::std::move(from);
  }

  inline MaxStepSize& operator=(const MaxStepSize& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaxStepSize& operator=(MaxStepSize&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MaxStepSize& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MaxStepSize* internal_default_instance() {
    return reinterpret_cast<const MaxStepSize*>(
               &_MaxStepSize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(MaxStepSize& a, MaxStepSize& b) {
    a.Swap(&b);
  }
  inline void Swap(MaxStepSize* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MaxStepSize* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MaxStepSize* New() const final {
    return CreateMaybeMessage<MaxStepSize>(nullptr);
  }

  MaxStepSize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MaxStepSize>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MaxStepSize& from);
  void MergeFrom(const MaxStepSize& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaxStepSize* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.MaxStepSize";
  }
  protected:
  explicit MaxStepSize(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef MaxStepSize_TYPE TYPE;
  static constexpr TYPE SET_STEP_SIZE =
    MaxStepSize_TYPE_SET_STEP_SIZE;
  static constexpr TYPE GET_STEP_SIZE =
    MaxStepSize_TYPE_GET_STEP_SIZE;
  static inline bool TYPE_IsValid(int value) {
    return MaxStepSize_TYPE_IsValid(value);
  }
  static constexpr TYPE TYPE_MIN =
    MaxStepSize_TYPE_TYPE_MIN;
  static constexpr TYPE TYPE_MAX =
    MaxStepSize_TYPE_TYPE_MAX;
  static constexpr int TYPE_ARRAYSIZE =
    MaxStepSize_TYPE_TYPE_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TYPE_descriptor() {
    return MaxStepSize_TYPE_descriptor();
  }
  template<typename T>
  static inline const std::string& TYPE_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TYPE>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TYPE_Name.");
    return MaxStepSize_TYPE_Name(enum_t_value);
  }
  static inline bool TYPE_Parse(const std::string& name,
      TYPE* value) {
    return MaxStepSize_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // required double size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  double size() const;
  void set_size(double value);
  private:
  double _internal_size() const;
  void _internal_set_size(double value);
  public:

  // required .mw.internal.robotics.gazebotransport.MaxStepSize.TYPE type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE type() const;
  void set_type(::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE value);
  private:
  ::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE _internal_type() const;
  void _internal_set_type(::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.MaxStepSize)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double size_;
  int type_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class InitCustomPublisher PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.InitCustomPublisher) */ {
 public:
  inline InitCustomPublisher() : InitCustomPublisher(nullptr) {};
  virtual ~InitCustomPublisher();

  InitCustomPublisher(const InitCustomPublisher& from);
  InitCustomPublisher(InitCustomPublisher&& from) noexcept
    : InitCustomPublisher() {
    *this = ::std::move(from);
  }

  inline InitCustomPublisher& operator=(const InitCustomPublisher& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitCustomPublisher& operator=(InitCustomPublisher&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InitCustomPublisher& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitCustomPublisher* internal_default_instance() {
    return reinterpret_cast<const InitCustomPublisher*>(
               &_InitCustomPublisher_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(InitCustomPublisher& a, InitCustomPublisher& b) {
    a.Swap(&b);
  }
  inline void Swap(InitCustomPublisher* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitCustomPublisher* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InitCustomPublisher* New() const final {
    return CreateMaybeMessage<InitCustomPublisher>(nullptr);
  }

  InitCustomPublisher* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InitCustomPublisher>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InitCustomPublisher& from);
  void MergeFrom(const InitCustomPublisher& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitCustomPublisher* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.InitCustomPublisher";
  }
  protected:
  explicit InitCustomPublisher(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicNameFieldNumber = 1,
    kMessageTypeFieldNumber = 2,
  };
  // required string topic_name = 1;
  bool has_topic_name() const;
  private:
  bool _internal_has_topic_name() const;
  public:
  void clear_topic_name();
  const std::string& topic_name() const;
  void set_topic_name(const std::string& value);
  void set_topic_name(std::string&& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  std::string* mutable_topic_name();
  std::string* release_topic_name();
  void set_allocated_topic_name(std::string* topic_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_topic_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_topic_name(
      std::string* topic_name);
  private:
  const std::string& _internal_topic_name() const;
  void _internal_set_topic_name(const std::string& value);
  std::string* _internal_mutable_topic_name();
  public:

  // required string message_type = 2;
  bool has_message_type() const;
  private:
  bool _internal_has_message_type() const;
  public:
  void clear_message_type();
  const std::string& message_type() const;
  void set_message_type(const std::string& value);
  void set_message_type(std::string&& value);
  void set_message_type(const char* value);
  void set_message_type(const char* value, size_t size);
  std::string* mutable_message_type();
  std::string* release_message_type();
  void set_allocated_message_type(std::string* message_type);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message_type();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message_type(
      std::string* message_type);
  private:
  const std::string& _internal_message_type() const;
  void _internal_set_message_type(const std::string& value);
  std::string* _internal_mutable_message_type();
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.InitCustomPublisher)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_type_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class InitCustomSubscriber PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.InitCustomSubscriber) */ {
 public:
  inline InitCustomSubscriber() : InitCustomSubscriber(nullptr) {};
  virtual ~InitCustomSubscriber();

  InitCustomSubscriber(const InitCustomSubscriber& from);
  InitCustomSubscriber(InitCustomSubscriber&& from) noexcept
    : InitCustomSubscriber() {
    *this = ::std::move(from);
  }

  inline InitCustomSubscriber& operator=(const InitCustomSubscriber& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitCustomSubscriber& operator=(InitCustomSubscriber&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InitCustomSubscriber& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitCustomSubscriber* internal_default_instance() {
    return reinterpret_cast<const InitCustomSubscriber*>(
               &_InitCustomSubscriber_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(InitCustomSubscriber& a, InitCustomSubscriber& b) {
    a.Swap(&b);
  }
  inline void Swap(InitCustomSubscriber* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitCustomSubscriber* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InitCustomSubscriber* New() const final {
    return CreateMaybeMessage<InitCustomSubscriber>(nullptr);
  }

  InitCustomSubscriber* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InitCustomSubscriber>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InitCustomSubscriber& from);
  void MergeFrom(const InitCustomSubscriber& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitCustomSubscriber* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.InitCustomSubscriber";
  }
  protected:
  explicit InitCustomSubscriber(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicNameFieldNumber = 1,
    kMessageTypeFieldNumber = 2,
  };
  // required string topic_name = 1;
  bool has_topic_name() const;
  private:
  bool _internal_has_topic_name() const;
  public:
  void clear_topic_name();
  const std::string& topic_name() const;
  void set_topic_name(const std::string& value);
  void set_topic_name(std::string&& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  std::string* mutable_topic_name();
  std::string* release_topic_name();
  void set_allocated_topic_name(std::string* topic_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_topic_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_topic_name(
      std::string* topic_name);
  private:
  const std::string& _internal_topic_name() const;
  void _internal_set_topic_name(const std::string& value);
  std::string* _internal_mutable_topic_name();
  public:

  // required string message_type = 2;
  bool has_message_type() const;
  private:
  bool _internal_has_message_type() const;
  public:
  void clear_message_type();
  const std::string& message_type() const;
  void set_message_type(const std::string& value);
  void set_message_type(std::string&& value);
  void set_message_type(const char* value);
  void set_message_type(const char* value, size_t size);
  std::string* mutable_message_type();
  std::string* release_message_type();
  void set_allocated_message_type(std::string* message_type);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message_type();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message_type(
      std::string* message_type);
  private:
  const std::string& _internal_message_type() const;
  void _internal_set_message_type(const std::string& value);
  std::string* _internal_mutable_message_type();
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_type_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class CustomMessageSupport PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.CustomMessageSupport) */ {
 public:
  inline CustomMessageSupport() : CustomMessageSupport(nullptr) {};
  virtual ~CustomMessageSupport();

  CustomMessageSupport(const CustomMessageSupport& from);
  CustomMessageSupport(CustomMessageSupport&& from) noexcept
    : CustomMessageSupport() {
    *this = ::std::move(from);
  }

  inline CustomMessageSupport& operator=(const CustomMessageSupport& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMessageSupport& operator=(CustomMessageSupport&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CustomMessageSupport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CustomMessageSupport* internal_default_instance() {
    return reinterpret_cast<const CustomMessageSupport*>(
               &_CustomMessageSupport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(CustomMessageSupport& a, CustomMessageSupport& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMessageSupport* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMessageSupport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CustomMessageSupport* New() const final {
    return CreateMaybeMessage<CustomMessageSupport>(nullptr);
  }

  CustomMessageSupport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CustomMessageSupport>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CustomMessageSupport& from);
  void MergeFrom(const CustomMessageSupport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomMessageSupport* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.CustomMessageSupport";
  }
  protected:
  explicit CustomMessageSupport(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicNameFieldNumber = 1,
    kMessageTypeFieldNumber = 2,
    kDataFieldNumber = 3,
    kIsNewFieldNumber = 4,
  };
  // required string topic_name = 1;
  bool has_topic_name() const;
  private:
  bool _internal_has_topic_name() const;
  public:
  void clear_topic_name();
  const std::string& topic_name() const;
  void set_topic_name(const std::string& value);
  void set_topic_name(std::string&& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  std::string* mutable_topic_name();
  std::string* release_topic_name();
  void set_allocated_topic_name(std::string* topic_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_topic_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_topic_name(
      std::string* topic_name);
  private:
  const std::string& _internal_topic_name() const;
  void _internal_set_topic_name(const std::string& value);
  std::string* _internal_mutable_topic_name();
  public:

  // required string message_type = 2;
  bool has_message_type() const;
  private:
  bool _internal_has_message_type() const;
  public:
  void clear_message_type();
  const std::string& message_type() const;
  void set_message_type(const std::string& value);
  void set_message_type(std::string&& value);
  void set_message_type(const char* value);
  void set_message_type(const char* value, size_t size);
  std::string* mutable_message_type();
  std::string* release_message_type();
  void set_allocated_message_type(std::string* message_type);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message_type();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message_type(
      std::string* message_type);
  private:
  const std::string& _internal_message_type() const;
  void _internal_set_message_type(const std::string& value);
  std::string* _internal_mutable_message_type();
  public:

  // required bytes data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_data();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_data(
      std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // optional bool is_new = 4;
  bool has_is_new() const;
  private:
  bool _internal_has_is_new() const;
  public:
  void clear_is_new();
  bool is_new() const;
  void set_is_new(bool value);
  private:
  bool _internal_is_new() const;
  void _internal_set_is_new(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.CustomMessageSupport)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  bool is_new_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class RequestCustomMessageSupport PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport) */ {
 public:
  inline RequestCustomMessageSupport() : RequestCustomMessageSupport(nullptr) {};
  virtual ~RequestCustomMessageSupport();

  RequestCustomMessageSupport(const RequestCustomMessageSupport& from);
  RequestCustomMessageSupport(RequestCustomMessageSupport&& from) noexcept
    : RequestCustomMessageSupport() {
    *this = ::std::move(from);
  }

  inline RequestCustomMessageSupport& operator=(const RequestCustomMessageSupport& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestCustomMessageSupport& operator=(RequestCustomMessageSupport&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestCustomMessageSupport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestCustomMessageSupport* internal_default_instance() {
    return reinterpret_cast<const RequestCustomMessageSupport*>(
               &_RequestCustomMessageSupport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(RequestCustomMessageSupport& a, RequestCustomMessageSupport& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestCustomMessageSupport* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestCustomMessageSupport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestCustomMessageSupport* New() const final {
    return CreateMaybeMessage<RequestCustomMessageSupport>(nullptr);
  }

  RequestCustomMessageSupport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestCustomMessageSupport>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestCustomMessageSupport& from);
  void MergeFrom(const RequestCustomMessageSupport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestCustomMessageSupport* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.RequestCustomMessageSupport";
  }
  protected:
  explicit RequestCustomMessageSupport(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicNameFieldNumber = 1,
    kMessageTypeFieldNumber = 2,
  };
  // required string topic_name = 1;
  bool has_topic_name() const;
  private:
  bool _internal_has_topic_name() const;
  public:
  void clear_topic_name();
  const std::string& topic_name() const;
  void set_topic_name(const std::string& value);
  void set_topic_name(std::string&& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  std::string* mutable_topic_name();
  std::string* release_topic_name();
  void set_allocated_topic_name(std::string* topic_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_topic_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_topic_name(
      std::string* topic_name);
  private:
  const std::string& _internal_topic_name() const;
  void _internal_set_topic_name(const std::string& value);
  std::string* _internal_mutable_topic_name();
  public:

  // required string message_type = 2;
  bool has_message_type() const;
  private:
  bool _internal_has_message_type() const;
  public:
  void clear_message_type();
  const std::string& message_type() const;
  void set_message_type(const std::string& value);
  void set_message_type(std::string&& value);
  void set_message_type(const char* value);
  void set_message_type(const char* value, size_t size);
  std::string* mutable_message_type();
  std::string* release_message_type();
  void set_allocated_message_type(std::string* message_type);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message_type();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message_type(
      std::string* message_type);
  private:
  const std::string& _internal_message_type() const;
  void _internal_set_message_type(const std::string& value);
  std::string* _internal_mutable_message_type();
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_type_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class SetJointPosition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.SetJointPosition) */ {
 public:
  inline SetJointPosition() : SetJointPosition(nullptr) {};
  virtual ~SetJointPosition();

  SetJointPosition(const SetJointPosition& from);
  SetJointPosition(SetJointPosition&& from) noexcept
    : SetJointPosition() {
    *this = ::std::move(from);
  }

  inline SetJointPosition& operator=(const SetJointPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetJointPosition& operator=(SetJointPosition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetJointPosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetJointPosition* internal_default_instance() {
    return reinterpret_cast<const SetJointPosition*>(
               &_SetJointPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(SetJointPosition& a, SetJointPosition& b) {
    a.Swap(&b);
  }
  inline void Swap(SetJointPosition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetJointPosition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetJointPosition* New() const final {
    return CreateMaybeMessage<SetJointPosition>(nullptr);
  }

  SetJointPosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetJointPosition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetJointPosition& from);
  void MergeFrom(const SetJointPosition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetJointPosition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.SetJointPosition";
  }
  protected:
  explicit SetJointPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 1,
    kJointNameFieldNumber = 2,
    kDurationFieldNumber = 5,
    kPositionFieldNumber = 4,
    kIndexFieldNumber = 3,
  };
  // required string model_name = 1;
  bool has_model_name() const;
  private:
  bool _internal_has_model_name() const;
  public:
  void clear_model_name();
  const std::string& model_name() const;
  void set_model_name(const std::string& value);
  void set_model_name(std::string&& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  std::string* mutable_model_name();
  std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_model_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_model_name(
      std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // required string joint_name = 2;
  bool has_joint_name() const;
  private:
  bool _internal_has_joint_name() const;
  public:
  void clear_joint_name();
  const std::string& joint_name() const;
  void set_joint_name(const std::string& value);
  void set_joint_name(std::string&& value);
  void set_joint_name(const char* value);
  void set_joint_name(const char* value, size_t size);
  std::string* mutable_joint_name();
  std::string* release_joint_name();
  void set_allocated_joint_name(std::string* joint_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_joint_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_joint_name(
      std::string* joint_name);
  private:
  const std::string& _internal_joint_name() const;
  void _internal_set_joint_name(const std::string& value);
  std::string* _internal_mutable_joint_name();
  public:

  // required .mw.internal.robotics.gazebotransport.Time duration = 5;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  const ::mw::internal::robotics::gazebotransport::Time& duration() const;
  ::mw::internal::robotics::gazebotransport::Time* release_duration();
  ::mw::internal::robotics::gazebotransport::Time* mutable_duration();
  void set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration);
  private:
  const ::mw::internal::robotics::gazebotransport::Time& _internal_duration() const;
  ::mw::internal::robotics::gazebotransport::Time* _internal_mutable_duration();
  public:
  void unsafe_arena_set_allocated_duration(
      ::mw::internal::robotics::gazebotransport::Time* duration);
  ::mw::internal::robotics::gazebotransport::Time* unsafe_arena_release_duration();

  // required double position = 4;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  double position() const;
  void set_position(double value);
  private:
  double _internal_position() const;
  void _internal_set_position(double value);
  public:

  // required uint32 index = 3;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  ::PROTOBUF_NAMESPACE_ID::uint32 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_index() const;
  void _internal_set_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.SetJointPosition)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr joint_name_;
  ::mw::internal::robotics::gazebotransport::Time* duration_;
  double position_;
  ::PROTOBUF_NAMESPACE_ID::uint32 index_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class SetJointVelocity PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.SetJointVelocity) */ {
 public:
  inline SetJointVelocity() : SetJointVelocity(nullptr) {};
  virtual ~SetJointVelocity();

  SetJointVelocity(const SetJointVelocity& from);
  SetJointVelocity(SetJointVelocity&& from) noexcept
    : SetJointVelocity() {
    *this = ::std::move(from);
  }

  inline SetJointVelocity& operator=(const SetJointVelocity& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetJointVelocity& operator=(SetJointVelocity&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetJointVelocity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetJointVelocity* internal_default_instance() {
    return reinterpret_cast<const SetJointVelocity*>(
               &_SetJointVelocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(SetJointVelocity& a, SetJointVelocity& b) {
    a.Swap(&b);
  }
  inline void Swap(SetJointVelocity* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetJointVelocity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetJointVelocity* New() const final {
    return CreateMaybeMessage<SetJointVelocity>(nullptr);
  }

  SetJointVelocity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetJointVelocity>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetJointVelocity& from);
  void MergeFrom(const SetJointVelocity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetJointVelocity* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.SetJointVelocity";
  }
  protected:
  explicit SetJointVelocity(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 1,
    kJointNameFieldNumber = 2,
    kDurationFieldNumber = 5,
    kVelocityFieldNumber = 4,
    kIndexFieldNumber = 3,
  };
  // required string model_name = 1;
  bool has_model_name() const;
  private:
  bool _internal_has_model_name() const;
  public:
  void clear_model_name();
  const std::string& model_name() const;
  void set_model_name(const std::string& value);
  void set_model_name(std::string&& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  std::string* mutable_model_name();
  std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_model_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_model_name(
      std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // required string joint_name = 2;
  bool has_joint_name() const;
  private:
  bool _internal_has_joint_name() const;
  public:
  void clear_joint_name();
  const std::string& joint_name() const;
  void set_joint_name(const std::string& value);
  void set_joint_name(std::string&& value);
  void set_joint_name(const char* value);
  void set_joint_name(const char* value, size_t size);
  std::string* mutable_joint_name();
  std::string* release_joint_name();
  void set_allocated_joint_name(std::string* joint_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_joint_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_joint_name(
      std::string* joint_name);
  private:
  const std::string& _internal_joint_name() const;
  void _internal_set_joint_name(const std::string& value);
  std::string* _internal_mutable_joint_name();
  public:

  // required .mw.internal.robotics.gazebotransport.Time duration = 5;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  const ::mw::internal::robotics::gazebotransport::Time& duration() const;
  ::mw::internal::robotics::gazebotransport::Time* release_duration();
  ::mw::internal::robotics::gazebotransport::Time* mutable_duration();
  void set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration);
  private:
  const ::mw::internal::robotics::gazebotransport::Time& _internal_duration() const;
  ::mw::internal::robotics::gazebotransport::Time* _internal_mutable_duration();
  public:
  void unsafe_arena_set_allocated_duration(
      ::mw::internal::robotics::gazebotransport::Time* duration);
  ::mw::internal::robotics::gazebotransport::Time* unsafe_arena_release_duration();

  // required double velocity = 4;
  bool has_velocity() const;
  private:
  bool _internal_has_velocity() const;
  public:
  void clear_velocity();
  double velocity() const;
  void set_velocity(double value);
  private:
  double _internal_velocity() const;
  void _internal_set_velocity(double value);
  public:

  // required uint32 index = 3;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  ::PROTOBUF_NAMESPACE_ID::uint32 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_index() const;
  void _internal_set_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.SetJointVelocity)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr joint_name_;
  ::mw::internal::robotics::gazebotransport::Time* duration_;
  double velocity_;
  ::PROTOBUF_NAMESPACE_ID::uint32 index_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class GetJointState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.GetJointState) */ {
 public:
  inline GetJointState() : GetJointState(nullptr) {};
  virtual ~GetJointState();

  GetJointState(const GetJointState& from);
  GetJointState(GetJointState&& from) noexcept
    : GetJointState() {
    *this = ::std::move(from);
  }

  inline GetJointState& operator=(const GetJointState& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetJointState& operator=(GetJointState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetJointState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetJointState* internal_default_instance() {
    return reinterpret_cast<const GetJointState*>(
               &_GetJointState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(GetJointState& a, GetJointState& b) {
    a.Swap(&b);
  }
  inline void Swap(GetJointState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetJointState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetJointState* New() const final {
    return CreateMaybeMessage<GetJointState>(nullptr);
  }

  GetJointState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetJointState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetJointState& from);
  void MergeFrom(const GetJointState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetJointState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.GetJointState";
  }
  protected:
  explicit GetJointState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 1,
    kJointNameFieldNumber = 2,
  };
  // required string model_name = 1;
  bool has_model_name() const;
  private:
  bool _internal_has_model_name() const;
  public:
  void clear_model_name();
  const std::string& model_name() const;
  void set_model_name(const std::string& value);
  void set_model_name(std::string&& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  std::string* mutable_model_name();
  std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_model_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_model_name(
      std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // required string joint_name = 2;
  bool has_joint_name() const;
  private:
  bool _internal_has_joint_name() const;
  public:
  void clear_joint_name();
  const std::string& joint_name() const;
  void set_joint_name(const std::string& value);
  void set_joint_name(std::string&& value);
  void set_joint_name(const char* value);
  void set_joint_name(const char* value, size_t size);
  std::string* mutable_joint_name();
  std::string* release_joint_name();
  void set_allocated_joint_name(std::string* joint_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_joint_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_joint_name(
      std::string* joint_name);
  private:
  const std::string& _internal_joint_name() const;
  void _internal_set_joint_name(const std::string& value);
  std::string* _internal_mutable_joint_name();
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.GetJointState)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr joint_name_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class Axis PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.Axis) */ {
 public:
  inline Axis() : Axis(nullptr) {};
  virtual ~Axis();

  Axis(const Axis& from);
  Axis(Axis&& from) noexcept
    : Axis() {
    *this = ::std::move(from);
  }

  inline Axis& operator=(const Axis& from) {
    CopyFrom(from);
    return *this;
  }
  inline Axis& operator=(Axis&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Axis& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Axis* internal_default_instance() {
    return reinterpret_cast<const Axis*>(
               &_Axis_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(Axis& a, Axis& b) {
    a.Swap(&b);
  }
  inline void Swap(Axis* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Axis* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Axis* New() const final {
    return CreateMaybeMessage<Axis>(nullptr);
  }

  Axis* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Axis>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Axis& from);
  void MergeFrom(const Axis& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Axis* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.Axis";
  }
  protected:
  explicit Axis(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXyzFieldNumber = 1,
    kLimitLowerFieldNumber = 2,
    kLimitUpperFieldNumber = 3,
    kLimitEffortFieldNumber = 4,
    kLimitVelocityFieldNumber = 5,
    kDampingFieldNumber = 6,
    kFrictionFieldNumber = 7,
    kUseParentModelFrameFieldNumber = 8,
  };
  // required .mw.internal.robotics.gazebotransport.Point xyz = 1;
  bool has_xyz() const;
  private:
  bool _internal_has_xyz() const;
  public:
  void clear_xyz();
  const ::mw::internal::robotics::gazebotransport::Point& xyz() const;
  ::mw::internal::robotics::gazebotransport::Point* release_xyz();
  ::mw::internal::robotics::gazebotransport::Point* mutable_xyz();
  void set_allocated_xyz(::mw::internal::robotics::gazebotransport::Point* xyz);
  private:
  const ::mw::internal::robotics::gazebotransport::Point& _internal_xyz() const;
  ::mw::internal::robotics::gazebotransport::Point* _internal_mutable_xyz();
  public:
  void unsafe_arena_set_allocated_xyz(
      ::mw::internal::robotics::gazebotransport::Point* xyz);
  ::mw::internal::robotics::gazebotransport::Point* unsafe_arena_release_xyz();

  // required double limit_lower = 2;
  bool has_limit_lower() const;
  private:
  bool _internal_has_limit_lower() const;
  public:
  void clear_limit_lower();
  double limit_lower() const;
  void set_limit_lower(double value);
  private:
  double _internal_limit_lower() const;
  void _internal_set_limit_lower(double value);
  public:

  // required double limit_upper = 3;
  bool has_limit_upper() const;
  private:
  bool _internal_has_limit_upper() const;
  public:
  void clear_limit_upper();
  double limit_upper() const;
  void set_limit_upper(double value);
  private:
  double _internal_limit_upper() const;
  void _internal_set_limit_upper(double value);
  public:

  // required double limit_effort = 4;
  bool has_limit_effort() const;
  private:
  bool _internal_has_limit_effort() const;
  public:
  void clear_limit_effort();
  double limit_effort() const;
  void set_limit_effort(double value);
  private:
  double _internal_limit_effort() const;
  void _internal_set_limit_effort(double value);
  public:

  // required double limit_velocity = 5;
  bool has_limit_velocity() const;
  private:
  bool _internal_has_limit_velocity() const;
  public:
  void clear_limit_velocity();
  double limit_velocity() const;
  void set_limit_velocity(double value);
  private:
  double _internal_limit_velocity() const;
  void _internal_set_limit_velocity(double value);
  public:

  // required double damping = 6;
  bool has_damping() const;
  private:
  bool _internal_has_damping() const;
  public:
  void clear_damping();
  double damping() const;
  void set_damping(double value);
  private:
  double _internal_damping() const;
  void _internal_set_damping(double value);
  public:

  // required double friction = 7;
  bool has_friction() const;
  private:
  bool _internal_has_friction() const;
  public:
  void clear_friction();
  double friction() const;
  void set_friction(double value);
  private:
  double _internal_friction() const;
  void _internal_set_friction(double value);
  public:

  // required bool use_parent_model_frame = 8;
  bool has_use_parent_model_frame() const;
  private:
  bool _internal_has_use_parent_model_frame() const;
  public:
  void clear_use_parent_model_frame();
  bool use_parent_model_frame() const;
  void set_use_parent_model_frame(bool value);
  private:
  bool _internal_use_parent_model_frame() const;
  void _internal_set_use_parent_model_frame(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.Axis)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::mw::internal::robotics::gazebotransport::Point* xyz_;
  double limit_lower_;
  double limit_upper_;
  double limit_effort_;
  double limit_velocity_;
  double damping_;
  double friction_;
  bool use_parent_model_frame_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class JointState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.JointState) */ {
 public:
  inline JointState() : JointState(nullptr) {};
  virtual ~JointState();

  JointState(const JointState& from);
  JointState(JointState&& from) noexcept
    : JointState() {
    *this = ::std::move(from);
  }

  inline JointState& operator=(const JointState& from) {
    CopyFrom(from);
    return *this;
  }
  inline JointState& operator=(JointState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const JointState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JointState* internal_default_instance() {
    return reinterpret_cast<const JointState*>(
               &_JointState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(JointState& a, JointState& b) {
    a.Swap(&b);
  }
  inline void Swap(JointState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JointState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JointState* New() const final {
    return CreateMaybeMessage<JointState>(nullptr);
  }

  JointState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JointState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const JointState& from);
  void MergeFrom(const JointState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JointState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.JointState";
  }
  protected:
  explicit JointState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef JointState_Joint_Type Joint_Type;
  static constexpr Joint_Type REVOLUTE =
    JointState_Joint_Type_REVOLUTE;
  static constexpr Joint_Type REVOLUTE2 =
    JointState_Joint_Type_REVOLUTE2;
  static constexpr Joint_Type PRISMATIC =
    JointState_Joint_Type_PRISMATIC;
  static constexpr Joint_Type UNIVERSAL =
    JointState_Joint_Type_UNIVERSAL;
  static constexpr Joint_Type BALL =
    JointState_Joint_Type_BALL;
  static constexpr Joint_Type SCREW =
    JointState_Joint_Type_SCREW;
  static constexpr Joint_Type GEARBOX =
    JointState_Joint_Type_GEARBOX;
  static constexpr Joint_Type FIXED =
    JointState_Joint_Type_FIXED;
  static inline bool Joint_Type_IsValid(int value) {
    return JointState_Joint_Type_IsValid(value);
  }
  static constexpr Joint_Type Joint_Type_MIN =
    JointState_Joint_Type_Joint_Type_MIN;
  static constexpr Joint_Type Joint_Type_MAX =
    JointState_Joint_Type_Joint_Type_MAX;
  static constexpr int Joint_Type_ARRAYSIZE =
    JointState_Joint_Type_Joint_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Joint_Type_descriptor() {
    return JointState_Joint_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Joint_Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Joint_Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Joint_Type_Name.");
    return JointState_Joint_Type_Name(enum_t_value);
  }
  static inline bool Joint_Type_Parse(const std::string& name,
      Joint_Type* value) {
    return JointState_Joint_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kJointPositionFieldNumber = 4,
    kJointVelocityFieldNumber = 5,
    kAxisFieldNumber = 14,
    kModelNameFieldNumber = 1,
    kJointNameFieldNumber = 2,
    kParentNameFieldNumber = 7,
    kChildNameFieldNumber = 9,
    kInitialAnchorPoseFieldNumber = 11,
    kWorldPoseFieldNumber = 12,
    kParentWorldPoseFieldNumber = 13,
    kJointIdFieldNumber = 3,
    kParentIdFieldNumber = 8,
    kChildIdFieldNumber = 10,
    kJointTypeFieldNumber = 6,
  };
  // repeated double joint_position = 4;
  int joint_position_size() const;
  private:
  int _internal_joint_position_size() const;
  public:
  void clear_joint_position();
  private:
  double _internal_joint_position(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_joint_position() const;
  void _internal_add_joint_position(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_joint_position();
  public:
  double joint_position(int index) const;
  void set_joint_position(int index, double value);
  void add_joint_position(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      joint_position() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_joint_position();

  // repeated double joint_velocity = 5;
  int joint_velocity_size() const;
  private:
  int _internal_joint_velocity_size() const;
  public:
  void clear_joint_velocity();
  private:
  double _internal_joint_velocity(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_joint_velocity() const;
  void _internal_add_joint_velocity(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_joint_velocity();
  public:
  double joint_velocity(int index) const;
  void set_joint_velocity(int index, double value);
  void add_joint_velocity(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      joint_velocity() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_joint_velocity();

  // repeated .mw.internal.robotics.gazebotransport.Axis axis = 14;
  int axis_size() const;
  private:
  int _internal_axis_size() const;
  public:
  void clear_axis();
  ::mw::internal::robotics::gazebotransport::Axis* mutable_axis(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::Axis >*
      mutable_axis();
  private:
  const ::mw::internal::robotics::gazebotransport::Axis& _internal_axis(int index) const;
  ::mw::internal::robotics::gazebotransport::Axis* _internal_add_axis();
  public:
  const ::mw::internal::robotics::gazebotransport::Axis& axis(int index) const;
  ::mw::internal::robotics::gazebotransport::Axis* add_axis();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::Axis >&
      axis() const;

  // required string model_name = 1;
  bool has_model_name() const;
  private:
  bool _internal_has_model_name() const;
  public:
  void clear_model_name();
  const std::string& model_name() const;
  void set_model_name(const std::string& value);
  void set_model_name(std::string&& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  std::string* mutable_model_name();
  std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_model_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_model_name(
      std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // required string joint_name = 2;
  bool has_joint_name() const;
  private:
  bool _internal_has_joint_name() const;
  public:
  void clear_joint_name();
  const std::string& joint_name() const;
  void set_joint_name(const std::string& value);
  void set_joint_name(std::string&& value);
  void set_joint_name(const char* value);
  void set_joint_name(const char* value, size_t size);
  std::string* mutable_joint_name();
  std::string* release_joint_name();
  void set_allocated_joint_name(std::string* joint_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_joint_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_joint_name(
      std::string* joint_name);
  private:
  const std::string& _internal_joint_name() const;
  void _internal_set_joint_name(const std::string& value);
  std::string* _internal_mutable_joint_name();
  public:

  // optional string parent_name = 7;
  bool has_parent_name() const;
  private:
  bool _internal_has_parent_name() const;
  public:
  void clear_parent_name();
  const std::string& parent_name() const;
  void set_parent_name(const std::string& value);
  void set_parent_name(std::string&& value);
  void set_parent_name(const char* value);
  void set_parent_name(const char* value, size_t size);
  std::string* mutable_parent_name();
  std::string* release_parent_name();
  void set_allocated_parent_name(std::string* parent_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_parent_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_parent_name(
      std::string* parent_name);
  private:
  const std::string& _internal_parent_name() const;
  void _internal_set_parent_name(const std::string& value);
  std::string* _internal_mutable_parent_name();
  public:

  // optional string child_name = 9;
  bool has_child_name() const;
  private:
  bool _internal_has_child_name() const;
  public:
  void clear_child_name();
  const std::string& child_name() const;
  void set_child_name(const std::string& value);
  void set_child_name(std::string&& value);
  void set_child_name(const char* value);
  void set_child_name(const char* value, size_t size);
  std::string* mutable_child_name();
  std::string* release_child_name();
  void set_allocated_child_name(std::string* child_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_child_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_child_name(
      std::string* child_name);
  private:
  const std::string& _internal_child_name() const;
  void _internal_set_child_name(const std::string& value);
  std::string* _internal_mutable_child_name();
  public:

  // optional .mw.internal.robotics.gazebotransport.Pose initial_anchor_pose = 11;
  bool has_initial_anchor_pose() const;
  private:
  bool _internal_has_initial_anchor_pose() const;
  public:
  void clear_initial_anchor_pose();
  const ::mw::internal::robotics::gazebotransport::Pose& initial_anchor_pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* release_initial_anchor_pose();
  ::mw::internal::robotics::gazebotransport::Pose* mutable_initial_anchor_pose();
  void set_allocated_initial_anchor_pose(::mw::internal::robotics::gazebotransport::Pose* initial_anchor_pose);
  private:
  const ::mw::internal::robotics::gazebotransport::Pose& _internal_initial_anchor_pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* _internal_mutable_initial_anchor_pose();
  public:
  void unsafe_arena_set_allocated_initial_anchor_pose(
      ::mw::internal::robotics::gazebotransport::Pose* initial_anchor_pose);
  ::mw::internal::robotics::gazebotransport::Pose* unsafe_arena_release_initial_anchor_pose();

  // optional .mw.internal.robotics.gazebotransport.Pose world_pose = 12;
  bool has_world_pose() const;
  private:
  bool _internal_has_world_pose() const;
  public:
  void clear_world_pose();
  const ::mw::internal::robotics::gazebotransport::Pose& world_pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* release_world_pose();
  ::mw::internal::robotics::gazebotransport::Pose* mutable_world_pose();
  void set_allocated_world_pose(::mw::internal::robotics::gazebotransport::Pose* world_pose);
  private:
  const ::mw::internal::robotics::gazebotransport::Pose& _internal_world_pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* _internal_mutable_world_pose();
  public:
  void unsafe_arena_set_allocated_world_pose(
      ::mw::internal::robotics::gazebotransport::Pose* world_pose);
  ::mw::internal::robotics::gazebotransport::Pose* unsafe_arena_release_world_pose();

  // optional .mw.internal.robotics.gazebotransport.Pose parent_world_pose = 13;
  bool has_parent_world_pose() const;
  private:
  bool _internal_has_parent_world_pose() const;
  public:
  void clear_parent_world_pose();
  const ::mw::internal::robotics::gazebotransport::Pose& parent_world_pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* release_parent_world_pose();
  ::mw::internal::robotics::gazebotransport::Pose* mutable_parent_world_pose();
  void set_allocated_parent_world_pose(::mw::internal::robotics::gazebotransport::Pose* parent_world_pose);
  private:
  const ::mw::internal::robotics::gazebotransport::Pose& _internal_parent_world_pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* _internal_mutable_parent_world_pose();
  public:
  void unsafe_arena_set_allocated_parent_world_pose(
      ::mw::internal::robotics::gazebotransport::Pose* parent_world_pose);
  ::mw::internal::robotics::gazebotransport::Pose* unsafe_arena_release_parent_world_pose();

  // required uint32 joint_id = 3;
  bool has_joint_id() const;
  private:
  bool _internal_has_joint_id() const;
  public:
  void clear_joint_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 joint_id() const;
  void set_joint_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_joint_id() const;
  void _internal_set_joint_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 parent_id = 8;
  bool has_parent_id() const;
  private:
  bool _internal_has_parent_id() const;
  public:
  void clear_parent_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 parent_id() const;
  void set_parent_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_parent_id() const;
  void _internal_set_parent_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 child_id = 10;
  bool has_child_id() const;
  private:
  bool _internal_has_child_id() const;
  public:
  void clear_child_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 child_id() const;
  void set_child_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_child_id() const;
  void _internal_set_child_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .mw.internal.robotics.gazebotransport.JointState.Joint_Type joint_type = 6;
  bool has_joint_type() const;
  private:
  bool _internal_has_joint_type() const;
  public:
  void clear_joint_type();
  ::mw::internal::robotics::gazebotransport::JointState_Joint_Type joint_type() const;
  void set_joint_type(::mw::internal::robotics::gazebotransport::JointState_Joint_Type value);
  private:
  ::mw::internal::robotics::gazebotransport::JointState_Joint_Type _internal_joint_type() const;
  void _internal_set_joint_type(::mw::internal::robotics::gazebotransport::JointState_Joint_Type value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.JointState)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > joint_position_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > joint_velocity_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::Axis > axis_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr joint_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr child_name_;
  ::mw::internal::robotics::gazebotransport::Pose* initial_anchor_pose_;
  ::mw::internal::robotics::gazebotransport::Pose* world_pose_;
  ::mw::internal::robotics::gazebotransport::Pose* parent_world_pose_;
  ::PROTOBUF_NAMESPACE_ID::uint32 joint_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 parent_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 child_id_;
  int joint_type_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class SetLinkWorldPose PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.SetLinkWorldPose) */ {
 public:
  inline SetLinkWorldPose() : SetLinkWorldPose(nullptr) {};
  virtual ~SetLinkWorldPose();

  SetLinkWorldPose(const SetLinkWorldPose& from);
  SetLinkWorldPose(SetLinkWorldPose&& from) noexcept
    : SetLinkWorldPose() {
    *this = ::std::move(from);
  }

  inline SetLinkWorldPose& operator=(const SetLinkWorldPose& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetLinkWorldPose& operator=(SetLinkWorldPose&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetLinkWorldPose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetLinkWorldPose* internal_default_instance() {
    return reinterpret_cast<const SetLinkWorldPose*>(
               &_SetLinkWorldPose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(SetLinkWorldPose& a, SetLinkWorldPose& b) {
    a.Swap(&b);
  }
  inline void Swap(SetLinkWorldPose* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetLinkWorldPose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetLinkWorldPose* New() const final {
    return CreateMaybeMessage<SetLinkWorldPose>(nullptr);
  }

  SetLinkWorldPose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetLinkWorldPose>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetLinkWorldPose& from);
  void MergeFrom(const SetLinkWorldPose& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLinkWorldPose* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.SetLinkWorldPose";
  }
  protected:
  explicit SetLinkWorldPose(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 1,
    kLinkNameFieldNumber = 2,
    kPoseFieldNumber = 3,
    kDurationFieldNumber = 4,
  };
  // required string model_name = 1;
  bool has_model_name() const;
  private:
  bool _internal_has_model_name() const;
  public:
  void clear_model_name();
  const std::string& model_name() const;
  void set_model_name(const std::string& value);
  void set_model_name(std::string&& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  std::string* mutable_model_name();
  std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_model_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_model_name(
      std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // required string link_name = 2;
  bool has_link_name() const;
  private:
  bool _internal_has_link_name() const;
  public:
  void clear_link_name();
  const std::string& link_name() const;
  void set_link_name(const std::string& value);
  void set_link_name(std::string&& value);
  void set_link_name(const char* value);
  void set_link_name(const char* value, size_t size);
  std::string* mutable_link_name();
  std::string* release_link_name();
  void set_allocated_link_name(std::string* link_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_link_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_link_name(
      std::string* link_name);
  private:
  const std::string& _internal_link_name() const;
  void _internal_set_link_name(const std::string& value);
  std::string* _internal_mutable_link_name();
  public:

  // required .mw.internal.robotics.gazebotransport.Pose pose = 3;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::mw::internal::robotics::gazebotransport::Pose& pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* release_pose();
  ::mw::internal::robotics::gazebotransport::Pose* mutable_pose();
  void set_allocated_pose(::mw::internal::robotics::gazebotransport::Pose* pose);
  private:
  const ::mw::internal::robotics::gazebotransport::Pose& _internal_pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::mw::internal::robotics::gazebotransport::Pose* pose);
  ::mw::internal::robotics::gazebotransport::Pose* unsafe_arena_release_pose();

  // required .mw.internal.robotics.gazebotransport.Time duration = 4;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  const ::mw::internal::robotics::gazebotransport::Time& duration() const;
  ::mw::internal::robotics::gazebotransport::Time* release_duration();
  ::mw::internal::robotics::gazebotransport::Time* mutable_duration();
  void set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration);
  private:
  const ::mw::internal::robotics::gazebotransport::Time& _internal_duration() const;
  ::mw::internal::robotics::gazebotransport::Time* _internal_mutable_duration();
  public:
  void unsafe_arena_set_allocated_duration(
      ::mw::internal::robotics::gazebotransport::Time* duration);
  ::mw::internal::robotics::gazebotransport::Time* unsafe_arena_release_duration();

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_name_;
  ::mw::internal::robotics::gazebotransport::Pose* pose_;
  ::mw::internal::robotics::gazebotransport::Time* duration_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class SetLinkLinearVelocity PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity) */ {
 public:
  inline SetLinkLinearVelocity() : SetLinkLinearVelocity(nullptr) {};
  virtual ~SetLinkLinearVelocity();

  SetLinkLinearVelocity(const SetLinkLinearVelocity& from);
  SetLinkLinearVelocity(SetLinkLinearVelocity&& from) noexcept
    : SetLinkLinearVelocity() {
    *this = ::std::move(from);
  }

  inline SetLinkLinearVelocity& operator=(const SetLinkLinearVelocity& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetLinkLinearVelocity& operator=(SetLinkLinearVelocity&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetLinkLinearVelocity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetLinkLinearVelocity* internal_default_instance() {
    return reinterpret_cast<const SetLinkLinearVelocity*>(
               &_SetLinkLinearVelocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(SetLinkLinearVelocity& a, SetLinkLinearVelocity& b) {
    a.Swap(&b);
  }
  inline void Swap(SetLinkLinearVelocity* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetLinkLinearVelocity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetLinkLinearVelocity* New() const final {
    return CreateMaybeMessage<SetLinkLinearVelocity>(nullptr);
  }

  SetLinkLinearVelocity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetLinkLinearVelocity>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetLinkLinearVelocity& from);
  void MergeFrom(const SetLinkLinearVelocity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLinkLinearVelocity* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.SetLinkLinearVelocity";
  }
  protected:
  explicit SetLinkLinearVelocity(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 1,
    kLinkNameFieldNumber = 2,
    kVelocityFieldNumber = 3,
    kDurationFieldNumber = 4,
  };
  // required string model_name = 1;
  bool has_model_name() const;
  private:
  bool _internal_has_model_name() const;
  public:
  void clear_model_name();
  const std::string& model_name() const;
  void set_model_name(const std::string& value);
  void set_model_name(std::string&& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  std::string* mutable_model_name();
  std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_model_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_model_name(
      std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // required string link_name = 2;
  bool has_link_name() const;
  private:
  bool _internal_has_link_name() const;
  public:
  void clear_link_name();
  const std::string& link_name() const;
  void set_link_name(const std::string& value);
  void set_link_name(std::string&& value);
  void set_link_name(const char* value);
  void set_link_name(const char* value, size_t size);
  std::string* mutable_link_name();
  std::string* release_link_name();
  void set_allocated_link_name(std::string* link_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_link_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_link_name(
      std::string* link_name);
  private:
  const std::string& _internal_link_name() const;
  void _internal_set_link_name(const std::string& value);
  std::string* _internal_mutable_link_name();
  public:

  // required .mw.internal.robotics.gazebotransport.Point velocity = 3;
  bool has_velocity() const;
  private:
  bool _internal_has_velocity() const;
  public:
  void clear_velocity();
  const ::mw::internal::robotics::gazebotransport::Point& velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* release_velocity();
  ::mw::internal::robotics::gazebotransport::Point* mutable_velocity();
  void set_allocated_velocity(::mw::internal::robotics::gazebotransport::Point* velocity);
  private:
  const ::mw::internal::robotics::gazebotransport::Point& _internal_velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::mw::internal::robotics::gazebotransport::Point* velocity);
  ::mw::internal::robotics::gazebotransport::Point* unsafe_arena_release_velocity();

  // required .mw.internal.robotics.gazebotransport.Time duration = 4;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  const ::mw::internal::robotics::gazebotransport::Time& duration() const;
  ::mw::internal::robotics::gazebotransport::Time* release_duration();
  ::mw::internal::robotics::gazebotransport::Time* mutable_duration();
  void set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration);
  private:
  const ::mw::internal::robotics::gazebotransport::Time& _internal_duration() const;
  ::mw::internal::robotics::gazebotransport::Time* _internal_mutable_duration();
  public:
  void unsafe_arena_set_allocated_duration(
      ::mw::internal::robotics::gazebotransport::Time* duration);
  ::mw::internal::robotics::gazebotransport::Time* unsafe_arena_release_duration();

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_name_;
  ::mw::internal::robotics::gazebotransport::Point* velocity_;
  ::mw::internal::robotics::gazebotransport::Time* duration_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class SetLinkAngularVelocity PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity) */ {
 public:
  inline SetLinkAngularVelocity() : SetLinkAngularVelocity(nullptr) {};
  virtual ~SetLinkAngularVelocity();

  SetLinkAngularVelocity(const SetLinkAngularVelocity& from);
  SetLinkAngularVelocity(SetLinkAngularVelocity&& from) noexcept
    : SetLinkAngularVelocity() {
    *this = ::std::move(from);
  }

  inline SetLinkAngularVelocity& operator=(const SetLinkAngularVelocity& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetLinkAngularVelocity& operator=(SetLinkAngularVelocity&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetLinkAngularVelocity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetLinkAngularVelocity* internal_default_instance() {
    return reinterpret_cast<const SetLinkAngularVelocity*>(
               &_SetLinkAngularVelocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(SetLinkAngularVelocity& a, SetLinkAngularVelocity& b) {
    a.Swap(&b);
  }
  inline void Swap(SetLinkAngularVelocity* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetLinkAngularVelocity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetLinkAngularVelocity* New() const final {
    return CreateMaybeMessage<SetLinkAngularVelocity>(nullptr);
  }

  SetLinkAngularVelocity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetLinkAngularVelocity>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetLinkAngularVelocity& from);
  void MergeFrom(const SetLinkAngularVelocity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLinkAngularVelocity* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.SetLinkAngularVelocity";
  }
  protected:
  explicit SetLinkAngularVelocity(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 1,
    kLinkNameFieldNumber = 2,
    kVelocityFieldNumber = 3,
    kDurationFieldNumber = 4,
  };
  // required string model_name = 1;
  bool has_model_name() const;
  private:
  bool _internal_has_model_name() const;
  public:
  void clear_model_name();
  const std::string& model_name() const;
  void set_model_name(const std::string& value);
  void set_model_name(std::string&& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  std::string* mutable_model_name();
  std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_model_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_model_name(
      std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // required string link_name = 2;
  bool has_link_name() const;
  private:
  bool _internal_has_link_name() const;
  public:
  void clear_link_name();
  const std::string& link_name() const;
  void set_link_name(const std::string& value);
  void set_link_name(std::string&& value);
  void set_link_name(const char* value);
  void set_link_name(const char* value, size_t size);
  std::string* mutable_link_name();
  std::string* release_link_name();
  void set_allocated_link_name(std::string* link_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_link_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_link_name(
      std::string* link_name);
  private:
  const std::string& _internal_link_name() const;
  void _internal_set_link_name(const std::string& value);
  std::string* _internal_mutable_link_name();
  public:

  // required .mw.internal.robotics.gazebotransport.Point velocity = 3;
  bool has_velocity() const;
  private:
  bool _internal_has_velocity() const;
  public:
  void clear_velocity();
  const ::mw::internal::robotics::gazebotransport::Point& velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* release_velocity();
  ::mw::internal::robotics::gazebotransport::Point* mutable_velocity();
  void set_allocated_velocity(::mw::internal::robotics::gazebotransport::Point* velocity);
  private:
  const ::mw::internal::robotics::gazebotransport::Point& _internal_velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::mw::internal::robotics::gazebotransport::Point* velocity);
  ::mw::internal::robotics::gazebotransport::Point* unsafe_arena_release_velocity();

  // required .mw.internal.robotics.gazebotransport.Time duration = 4;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  const ::mw::internal::robotics::gazebotransport::Time& duration() const;
  ::mw::internal::robotics::gazebotransport::Time* release_duration();
  ::mw::internal::robotics::gazebotransport::Time* mutable_duration();
  void set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration);
  private:
  const ::mw::internal::robotics::gazebotransport::Time& _internal_duration() const;
  ::mw::internal::robotics::gazebotransport::Time* _internal_mutable_duration();
  public:
  void unsafe_arena_set_allocated_duration(
      ::mw::internal::robotics::gazebotransport::Time* duration);
  ::mw::internal::robotics::gazebotransport::Time* unsafe_arena_release_duration();

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_name_;
  ::mw::internal::robotics::gazebotransport::Point* velocity_;
  ::mw::internal::robotics::gazebotransport::Time* duration_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class GetLinkState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.GetLinkState) */ {
 public:
  inline GetLinkState() : GetLinkState(nullptr) {};
  virtual ~GetLinkState();

  GetLinkState(const GetLinkState& from);
  GetLinkState(GetLinkState&& from) noexcept
    : GetLinkState() {
    *this = ::std::move(from);
  }

  inline GetLinkState& operator=(const GetLinkState& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLinkState& operator=(GetLinkState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetLinkState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetLinkState* internal_default_instance() {
    return reinterpret_cast<const GetLinkState*>(
               &_GetLinkState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(GetLinkState& a, GetLinkState& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLinkState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLinkState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetLinkState* New() const final {
    return CreateMaybeMessage<GetLinkState>(nullptr);
  }

  GetLinkState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetLinkState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetLinkState& from);
  void MergeFrom(const GetLinkState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLinkState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.GetLinkState";
  }
  protected:
  explicit GetLinkState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 1,
    kLinkNameFieldNumber = 2,
  };
  // required string model_name = 1;
  bool has_model_name() const;
  private:
  bool _internal_has_model_name() const;
  public:
  void clear_model_name();
  const std::string& model_name() const;
  void set_model_name(const std::string& value);
  void set_model_name(std::string&& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  std::string* mutable_model_name();
  std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_model_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_model_name(
      std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // required string link_name = 2;
  bool has_link_name() const;
  private:
  bool _internal_has_link_name() const;
  public:
  void clear_link_name();
  const std::string& link_name() const;
  void set_link_name(const std::string& value);
  void set_link_name(std::string&& value);
  void set_link_name(const char* value);
  void set_link_name(const char* value, size_t size);
  std::string* mutable_link_name();
  std::string* release_link_name();
  void set_allocated_link_name(std::string* link_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_link_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_link_name(
      std::string* link_name);
  private:
  const std::string& _internal_link_name() const;
  void _internal_set_link_name(const std::string& value);
  std::string* _internal_mutable_link_name();
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.GetLinkState)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_name_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class LinkState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.LinkState) */ {
 public:
  inline LinkState() : LinkState(nullptr) {};
  virtual ~LinkState();

  LinkState(const LinkState& from);
  LinkState(LinkState&& from) noexcept
    : LinkState() {
    *this = ::std::move(from);
  }

  inline LinkState& operator=(const LinkState& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinkState& operator=(LinkState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LinkState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LinkState* internal_default_instance() {
    return reinterpret_cast<const LinkState*>(
               &_LinkState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(LinkState& a, LinkState& b) {
    a.Swap(&b);
  }
  inline void Swap(LinkState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinkState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LinkState* New() const final {
    return CreateMaybeMessage<LinkState>(nullptr);
  }

  LinkState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LinkState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LinkState& from);
  void MergeFrom(const LinkState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinkState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.LinkState";
  }
  protected:
  explicit LinkState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 1,
    kLinkNameFieldNumber = 2,
    kWorldLinearVelocityFieldNumber = 4,
    kWorldAngularVelocityFieldNumber = 5,
    kRelativeLinearVelocityFieldNumber = 6,
    kRelativeAngularVelocityFieldNumber = 7,
    kWorldPoseFieldNumber = 8,
    kRelativePoseFieldNumber = 9,
    kLinkIdFieldNumber = 3,
    kSelfCollideFieldNumber = 10,
    kGravityFieldNumber = 11,
    kKinematicFieldNumber = 12,
    kEnableWindFieldNumber = 13,
    kCanonicalFieldNumber = 14,
  };
  // required string model_name = 1;
  bool has_model_name() const;
  private:
  bool _internal_has_model_name() const;
  public:
  void clear_model_name();
  const std::string& model_name() const;
  void set_model_name(const std::string& value);
  void set_model_name(std::string&& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  std::string* mutable_model_name();
  std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_model_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_model_name(
      std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // required string link_name = 2;
  bool has_link_name() const;
  private:
  bool _internal_has_link_name() const;
  public:
  void clear_link_name();
  const std::string& link_name() const;
  void set_link_name(const std::string& value);
  void set_link_name(std::string&& value);
  void set_link_name(const char* value);
  void set_link_name(const char* value, size_t size);
  std::string* mutable_link_name();
  std::string* release_link_name();
  void set_allocated_link_name(std::string* link_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_link_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_link_name(
      std::string* link_name);
  private:
  const std::string& _internal_link_name() const;
  void _internal_set_link_name(const std::string& value);
  std::string* _internal_mutable_link_name();
  public:

  // required .mw.internal.robotics.gazebotransport.Point world_linear_velocity = 4;
  bool has_world_linear_velocity() const;
  private:
  bool _internal_has_world_linear_velocity() const;
  public:
  void clear_world_linear_velocity();
  const ::mw::internal::robotics::gazebotransport::Point& world_linear_velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* release_world_linear_velocity();
  ::mw::internal::robotics::gazebotransport::Point* mutable_world_linear_velocity();
  void set_allocated_world_linear_velocity(::mw::internal::robotics::gazebotransport::Point* world_linear_velocity);
  private:
  const ::mw::internal::robotics::gazebotransport::Point& _internal_world_linear_velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* _internal_mutable_world_linear_velocity();
  public:
  void unsafe_arena_set_allocated_world_linear_velocity(
      ::mw::internal::robotics::gazebotransport::Point* world_linear_velocity);
  ::mw::internal::robotics::gazebotransport::Point* unsafe_arena_release_world_linear_velocity();

  // required .mw.internal.robotics.gazebotransport.Point world_angular_velocity = 5;
  bool has_world_angular_velocity() const;
  private:
  bool _internal_has_world_angular_velocity() const;
  public:
  void clear_world_angular_velocity();
  const ::mw::internal::robotics::gazebotransport::Point& world_angular_velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* release_world_angular_velocity();
  ::mw::internal::robotics::gazebotransport::Point* mutable_world_angular_velocity();
  void set_allocated_world_angular_velocity(::mw::internal::robotics::gazebotransport::Point* world_angular_velocity);
  private:
  const ::mw::internal::robotics::gazebotransport::Point& _internal_world_angular_velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* _internal_mutable_world_angular_velocity();
  public:
  void unsafe_arena_set_allocated_world_angular_velocity(
      ::mw::internal::robotics::gazebotransport::Point* world_angular_velocity);
  ::mw::internal::robotics::gazebotransport::Point* unsafe_arena_release_world_angular_velocity();

  // required .mw.internal.robotics.gazebotransport.Point relative_linear_velocity = 6;
  bool has_relative_linear_velocity() const;
  private:
  bool _internal_has_relative_linear_velocity() const;
  public:
  void clear_relative_linear_velocity();
  const ::mw::internal::robotics::gazebotransport::Point& relative_linear_velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* release_relative_linear_velocity();
  ::mw::internal::robotics::gazebotransport::Point* mutable_relative_linear_velocity();
  void set_allocated_relative_linear_velocity(::mw::internal::robotics::gazebotransport::Point* relative_linear_velocity);
  private:
  const ::mw::internal::robotics::gazebotransport::Point& _internal_relative_linear_velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* _internal_mutable_relative_linear_velocity();
  public:
  void unsafe_arena_set_allocated_relative_linear_velocity(
      ::mw::internal::robotics::gazebotransport::Point* relative_linear_velocity);
  ::mw::internal::robotics::gazebotransport::Point* unsafe_arena_release_relative_linear_velocity();

  // required .mw.internal.robotics.gazebotransport.Point relative_angular_velocity = 7;
  bool has_relative_angular_velocity() const;
  private:
  bool _internal_has_relative_angular_velocity() const;
  public:
  void clear_relative_angular_velocity();
  const ::mw::internal::robotics::gazebotransport::Point& relative_angular_velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* release_relative_angular_velocity();
  ::mw::internal::robotics::gazebotransport::Point* mutable_relative_angular_velocity();
  void set_allocated_relative_angular_velocity(::mw::internal::robotics::gazebotransport::Point* relative_angular_velocity);
  private:
  const ::mw::internal::robotics::gazebotransport::Point& _internal_relative_angular_velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* _internal_mutable_relative_angular_velocity();
  public:
  void unsafe_arena_set_allocated_relative_angular_velocity(
      ::mw::internal::robotics::gazebotransport::Point* relative_angular_velocity);
  ::mw::internal::robotics::gazebotransport::Point* unsafe_arena_release_relative_angular_velocity();

  // optional .mw.internal.robotics.gazebotransport.Pose world_pose = 8;
  bool has_world_pose() const;
  private:
  bool _internal_has_world_pose() const;
  public:
  void clear_world_pose();
  const ::mw::internal::robotics::gazebotransport::Pose& world_pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* release_world_pose();
  ::mw::internal::robotics::gazebotransport::Pose* mutable_world_pose();
  void set_allocated_world_pose(::mw::internal::robotics::gazebotransport::Pose* world_pose);
  private:
  const ::mw::internal::robotics::gazebotransport::Pose& _internal_world_pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* _internal_mutable_world_pose();
  public:
  void unsafe_arena_set_allocated_world_pose(
      ::mw::internal::robotics::gazebotransport::Pose* world_pose);
  ::mw::internal::robotics::gazebotransport::Pose* unsafe_arena_release_world_pose();

  // optional .mw.internal.robotics.gazebotransport.Pose relative_pose = 9;
  bool has_relative_pose() const;
  private:
  bool _internal_has_relative_pose() const;
  public:
  void clear_relative_pose();
  const ::mw::internal::robotics::gazebotransport::Pose& relative_pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* release_relative_pose();
  ::mw::internal::robotics::gazebotransport::Pose* mutable_relative_pose();
  void set_allocated_relative_pose(::mw::internal::robotics::gazebotransport::Pose* relative_pose);
  private:
  const ::mw::internal::robotics::gazebotransport::Pose& _internal_relative_pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* _internal_mutable_relative_pose();
  public:
  void unsafe_arena_set_allocated_relative_pose(
      ::mw::internal::robotics::gazebotransport::Pose* relative_pose);
  ::mw::internal::robotics::gazebotransport::Pose* unsafe_arena_release_relative_pose();

  // required uint32 link_id = 3;
  bool has_link_id() const;
  private:
  bool _internal_has_link_id() const;
  public:
  void clear_link_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 link_id() const;
  void set_link_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_link_id() const;
  void _internal_set_link_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool self_collide = 10;
  bool has_self_collide() const;
  private:
  bool _internal_has_self_collide() const;
  public:
  void clear_self_collide();
  bool self_collide() const;
  void set_self_collide(bool value);
  private:
  bool _internal_self_collide() const;
  void _internal_set_self_collide(bool value);
  public:

  // optional bool gravity = 11;
  bool has_gravity() const;
  private:
  bool _internal_has_gravity() const;
  public:
  void clear_gravity();
  bool gravity() const;
  void set_gravity(bool value);
  private:
  bool _internal_gravity() const;
  void _internal_set_gravity(bool value);
  public:

  // optional bool kinematic = 12;
  bool has_kinematic() const;
  private:
  bool _internal_has_kinematic() const;
  public:
  void clear_kinematic();
  bool kinematic() const;
  void set_kinematic(bool value);
  private:
  bool _internal_kinematic() const;
  void _internal_set_kinematic(bool value);
  public:

  // optional bool enable_wind = 13;
  bool has_enable_wind() const;
  private:
  bool _internal_has_enable_wind() const;
  public:
  void clear_enable_wind();
  bool enable_wind() const;
  void set_enable_wind(bool value);
  private:
  bool _internal_enable_wind() const;
  void _internal_set_enable_wind(bool value);
  public:

  // optional bool canonical = 14;
  bool has_canonical() const;
  private:
  bool _internal_has_canonical() const;
  public:
  void clear_canonical();
  bool canonical() const;
  void set_canonical(bool value);
  private:
  bool _internal_canonical() const;
  void _internal_set_canonical(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.LinkState)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_name_;
  ::mw::internal::robotics::gazebotransport::Point* world_linear_velocity_;
  ::mw::internal::robotics::gazebotransport::Point* world_angular_velocity_;
  ::mw::internal::robotics::gazebotransport::Point* relative_linear_velocity_;
  ::mw::internal::robotics::gazebotransport::Point* relative_angular_velocity_;
  ::mw::internal::robotics::gazebotransport::Pose* world_pose_;
  ::mw::internal::robotics::gazebotransport::Pose* relative_pose_;
  ::PROTOBUF_NAMESPACE_ID::uint32 link_id_;
  bool self_collide_;
  bool gravity_;
  bool kinematic_;
  bool enable_wind_;
  bool canonical_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class ML_Cord PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ML_Cord) */ {
 public:
  inline ML_Cord() : ML_Cord(nullptr) {};
  virtual ~ML_Cord();

  ML_Cord(const ML_Cord& from);
  ML_Cord(ML_Cord&& from) noexcept
    : ML_Cord() {
    *this = ::std::move(from);
  }

  inline ML_Cord& operator=(const ML_Cord& from) {
    CopyFrom(from);
    return *this;
  }
  inline ML_Cord& operator=(ML_Cord&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ML_Cord& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ML_Cord* internal_default_instance() {
    return reinterpret_cast<const ML_Cord*>(
               &_ML_Cord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(ML_Cord& a, ML_Cord& b) {
    a.Swap(&b);
  }
  inline void Swap(ML_Cord* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ML_Cord* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ML_Cord* New() const final {
    return CreateMaybeMessage<ML_Cord>(nullptr);
  }

  ML_Cord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ML_Cord>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ML_Cord& from);
  void MergeFrom(const ML_Cord& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ML_Cord* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.ML_Cord";
  }
  protected:
  explicit ML_Cord(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // optional double x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // optional double y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ML_Cord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double x_;
  double y_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class ML_Point PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ML_Point) */ {
 public:
  inline ML_Point() : ML_Point(nullptr) {};
  virtual ~ML_Point();

  ML_Point(const ML_Point& from);
  ML_Point(ML_Point&& from) noexcept
    : ML_Point() {
    *this = ::std::move(from);
  }

  inline ML_Point& operator=(const ML_Point& from) {
    CopyFrom(from);
    return *this;
  }
  inline ML_Point& operator=(ML_Point&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ML_Point& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ML_Point* internal_default_instance() {
    return reinterpret_cast<const ML_Point*>(
               &_ML_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(ML_Point& a, ML_Point& b) {
    a.Swap(&b);
  }
  inline void Swap(ML_Point* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ML_Point* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ML_Point* New() const final {
    return CreateMaybeMessage<ML_Point>(nullptr);
  }

  ML_Point* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ML_Point>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ML_Point& from);
  void MergeFrom(const ML_Point& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ML_Point* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.ML_Point";
  }
  protected:
  explicit ML_Point(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // optional double x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // optional double y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // optional double z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ML_Point)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double x_;
  double y_;
  double z_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class ML_Quat PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ML_Quat) */ {
 public:
  inline ML_Quat() : ML_Quat(nullptr) {};
  virtual ~ML_Quat();

  ML_Quat(const ML_Quat& from);
  ML_Quat(ML_Quat&& from) noexcept
    : ML_Quat() {
    *this = ::std::move(from);
  }

  inline ML_Quat& operator=(const ML_Quat& from) {
    CopyFrom(from);
    return *this;
  }
  inline ML_Quat& operator=(ML_Quat&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ML_Quat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ML_Quat* internal_default_instance() {
    return reinterpret_cast<const ML_Quat*>(
               &_ML_Quat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(ML_Quat& a, ML_Quat& b) {
    a.Swap(&b);
  }
  inline void Swap(ML_Quat* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ML_Quat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ML_Quat* New() const final {
    return CreateMaybeMessage<ML_Quat>(nullptr);
  }

  ML_Quat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ML_Quat>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ML_Quat& from);
  void MergeFrom(const ML_Quat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ML_Quat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.ML_Quat";
  }
  protected:
  explicit ML_Quat(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // optional double x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // optional double y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // optional double z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // optional double w = 4;
  bool has_w() const;
  private:
  bool _internal_has_w() const;
  public:
  void clear_w();
  double w() const;
  void set_w(double value);
  private:
  double _internal_w() const;
  void _internal_set_w(double value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ML_Quat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double x_;
  double y_;
  double z_;
  double w_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class ML_Pose PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ML_Pose) */ {
 public:
  inline ML_Pose() : ML_Pose(nullptr) {};
  virtual ~ML_Pose();

  ML_Pose(const ML_Pose& from);
  ML_Pose(ML_Pose&& from) noexcept
    : ML_Pose() {
    *this = ::std::move(from);
  }

  inline ML_Pose& operator=(const ML_Pose& from) {
    CopyFrom(from);
    return *this;
  }
  inline ML_Pose& operator=(ML_Pose&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ML_Pose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ML_Pose* internal_default_instance() {
    return reinterpret_cast<const ML_Pose*>(
               &_ML_Pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(ML_Pose& a, ML_Pose& b) {
    a.Swap(&b);
  }
  inline void Swap(ML_Pose* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ML_Pose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ML_Pose* New() const final {
    return CreateMaybeMessage<ML_Pose>(nullptr);
  }

  ML_Pose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ML_Pose>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ML_Pose& from);
  void MergeFrom(const ML_Pose& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ML_Pose* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.ML_Pose";
  }
  protected:
  explicit ML_Pose(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kOrientationFieldNumber = 2,
  };
  // optional .mw.internal.robotics.gazebotransport.ML_Point position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::mw::internal::robotics::gazebotransport::ML_Point& position() const;
  ::mw::internal::robotics::gazebotransport::ML_Point* release_position();
  ::mw::internal::robotics::gazebotransport::ML_Point* mutable_position();
  void set_allocated_position(::mw::internal::robotics::gazebotransport::ML_Point* position);
  private:
  const ::mw::internal::robotics::gazebotransport::ML_Point& _internal_position() const;
  ::mw::internal::robotics::gazebotransport::ML_Point* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::mw::internal::robotics::gazebotransport::ML_Point* position);
  ::mw::internal::robotics::gazebotransport::ML_Point* unsafe_arena_release_position();

  // optional .mw.internal.robotics.gazebotransport.ML_Quat orientation = 2;
  bool has_orientation() const;
  private:
  bool _internal_has_orientation() const;
  public:
  void clear_orientation();
  const ::mw::internal::robotics::gazebotransport::ML_Quat& orientation() const;
  ::mw::internal::robotics::gazebotransport::ML_Quat* release_orientation();
  ::mw::internal::robotics::gazebotransport::ML_Quat* mutable_orientation();
  void set_allocated_orientation(::mw::internal::robotics::gazebotransport::ML_Quat* orientation);
  private:
  const ::mw::internal::robotics::gazebotransport::ML_Quat& _internal_orientation() const;
  ::mw::internal::robotics::gazebotransport::ML_Quat* _internal_mutable_orientation();
  public:
  void unsafe_arena_set_allocated_orientation(
      ::mw::internal::robotics::gazebotransport::ML_Quat* orientation);
  ::mw::internal::robotics::gazebotransport::ML_Quat* unsafe_arena_release_orientation();

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ML_Pose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::mw::internal::robotics::gazebotransport::ML_Point* position_;
  ::mw::internal::robotics::gazebotransport::ML_Quat* orientation_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class ML_Inertial PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ML_Inertial) */ {
 public:
  inline ML_Inertial() : ML_Inertial(nullptr) {};
  virtual ~ML_Inertial();

  ML_Inertial(const ML_Inertial& from);
  ML_Inertial(ML_Inertial&& from) noexcept
    : ML_Inertial() {
    *this = ::std::move(from);
  }

  inline ML_Inertial& operator=(const ML_Inertial& from) {
    CopyFrom(from);
    return *this;
  }
  inline ML_Inertial& operator=(ML_Inertial&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ML_Inertial& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ML_Inertial* internal_default_instance() {
    return reinterpret_cast<const ML_Inertial*>(
               &_ML_Inertial_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(ML_Inertial& a, ML_Inertial& b) {
    a.Swap(&b);
  }
  inline void Swap(ML_Inertial* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ML_Inertial* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ML_Inertial* New() const final {
    return CreateMaybeMessage<ML_Inertial>(nullptr);
  }

  ML_Inertial* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ML_Inertial>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ML_Inertial& from);
  void MergeFrom(const ML_Inertial& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ML_Inertial* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.ML_Inertial";
  }
  protected:
  explicit ML_Inertial(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMassFieldNumber = 1,
    kIxxFieldNumber = 2,
    kIxyFieldNumber = 3,
    kIxzFieldNumber = 4,
    kIyyFieldNumber = 5,
    kIyzFieldNumber = 6,
    kIzzFieldNumber = 7,
  };
  // optional double mass = 1;
  bool has_mass() const;
  private:
  bool _internal_has_mass() const;
  public:
  void clear_mass();
  double mass() const;
  void set_mass(double value);
  private:
  double _internal_mass() const;
  void _internal_set_mass(double value);
  public:

  // optional double ixx = 2;
  bool has_ixx() const;
  private:
  bool _internal_has_ixx() const;
  public:
  void clear_ixx();
  double ixx() const;
  void set_ixx(double value);
  private:
  double _internal_ixx() const;
  void _internal_set_ixx(double value);
  public:

  // optional double ixy = 3;
  bool has_ixy() const;
  private:
  bool _internal_has_ixy() const;
  public:
  void clear_ixy();
  double ixy() const;
  void set_ixy(double value);
  private:
  double _internal_ixy() const;
  void _internal_set_ixy(double value);
  public:

  // optional double ixz = 4;
  bool has_ixz() const;
  private:
  bool _internal_has_ixz() const;
  public:
  void clear_ixz();
  double ixz() const;
  void set_ixz(double value);
  private:
  double _internal_ixz() const;
  void _internal_set_ixz(double value);
  public:

  // optional double iyy = 5;
  bool has_iyy() const;
  private:
  bool _internal_has_iyy() const;
  public:
  void clear_iyy();
  double iyy() const;
  void set_iyy(double value);
  private:
  double _internal_iyy() const;
  void _internal_set_iyy(double value);
  public:

  // optional double iyz = 6;
  bool has_iyz() const;
  private:
  bool _internal_has_iyz() const;
  public:
  void clear_iyz();
  double iyz() const;
  void set_iyz(double value);
  private:
  double _internal_iyz() const;
  void _internal_set_iyz(double value);
  public:

  // optional double izz = 7;
  bool has_izz() const;
  private:
  bool _internal_has_izz() const;
  public:
  void clear_izz();
  double izz() const;
  void set_izz(double value);
  private:
  double _internal_izz() const;
  void _internal_set_izz(double value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ML_Inertial)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double mass_;
  double ixx_;
  double ixy_;
  double ixz_;
  double iyy_;
  double iyz_;
  double izz_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class ML_Links PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ML_Links) */ {
 public:
  inline ML_Links() : ML_Links(nullptr) {};
  virtual ~ML_Links();

  ML_Links(const ML_Links& from);
  ML_Links(ML_Links&& from) noexcept
    : ML_Links() {
    *this = ::std::move(from);
  }

  inline ML_Links& operator=(const ML_Links& from) {
    CopyFrom(from);
    return *this;
  }
  inline ML_Links& operator=(ML_Links&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ML_Links& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ML_Links* internal_default_instance() {
    return reinterpret_cast<const ML_Links*>(
               &_ML_Links_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(ML_Links& a, ML_Links& b) {
    a.Swap(&b);
  }
  inline void Swap(ML_Links* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ML_Links* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ML_Links* New() const final {
    return CreateMaybeMessage<ML_Links>(nullptr);
  }

  ML_Links* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ML_Links>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ML_Links& from);
  void MergeFrom(const ML_Links& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ML_Links* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.ML_Links";
  }
  protected:
  explicit ML_Links(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPoseFieldNumber = 2,
    kInertialFieldNumber = 3,
    kSelfCollideFieldNumber = 4,
    kGravityFieldNumber = 5,
    kKinematicFieldNumber = 6,
    kEnabledWindFieldNumber = 7,
    kIsStaticFieldNumber = 8,
    kCanonicalFieldNumber = 9,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 2;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::mw::internal::robotics::gazebotransport::ML_Pose& pose() const;
  ::mw::internal::robotics::gazebotransport::ML_Pose* release_pose();
  ::mw::internal::robotics::gazebotransport::ML_Pose* mutable_pose();
  void set_allocated_pose(::mw::internal::robotics::gazebotransport::ML_Pose* pose);
  private:
  const ::mw::internal::robotics::gazebotransport::ML_Pose& _internal_pose() const;
  ::mw::internal::robotics::gazebotransport::ML_Pose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::mw::internal::robotics::gazebotransport::ML_Pose* pose);
  ::mw::internal::robotics::gazebotransport::ML_Pose* unsafe_arena_release_pose();

  // optional .mw.internal.robotics.gazebotransport.ML_Inertial inertial = 3;
  bool has_inertial() const;
  private:
  bool _internal_has_inertial() const;
  public:
  void clear_inertial();
  const ::mw::internal::robotics::gazebotransport::ML_Inertial& inertial() const;
  ::mw::internal::robotics::gazebotransport::ML_Inertial* release_inertial();
  ::mw::internal::robotics::gazebotransport::ML_Inertial* mutable_inertial();
  void set_allocated_inertial(::mw::internal::robotics::gazebotransport::ML_Inertial* inertial);
  private:
  const ::mw::internal::robotics::gazebotransport::ML_Inertial& _internal_inertial() const;
  ::mw::internal::robotics::gazebotransport::ML_Inertial* _internal_mutable_inertial();
  public:
  void unsafe_arena_set_allocated_inertial(
      ::mw::internal::robotics::gazebotransport::ML_Inertial* inertial);
  ::mw::internal::robotics::gazebotransport::ML_Inertial* unsafe_arena_release_inertial();

  // optional bool self_collide = 4;
  bool has_self_collide() const;
  private:
  bool _internal_has_self_collide() const;
  public:
  void clear_self_collide();
  bool self_collide() const;
  void set_self_collide(bool value);
  private:
  bool _internal_self_collide() const;
  void _internal_set_self_collide(bool value);
  public:

  // optional bool gravity = 5;
  bool has_gravity() const;
  private:
  bool _internal_has_gravity() const;
  public:
  void clear_gravity();
  bool gravity() const;
  void set_gravity(bool value);
  private:
  bool _internal_gravity() const;
  void _internal_set_gravity(bool value);
  public:

  // optional bool kinematic = 6;
  bool has_kinematic() const;
  private:
  bool _internal_has_kinematic() const;
  public:
  void clear_kinematic();
  bool kinematic() const;
  void set_kinematic(bool value);
  private:
  bool _internal_kinematic() const;
  void _internal_set_kinematic(bool value);
  public:

  // optional bool enabled_wind = 7;
  bool has_enabled_wind() const;
  private:
  bool _internal_has_enabled_wind() const;
  public:
  void clear_enabled_wind();
  bool enabled_wind() const;
  void set_enabled_wind(bool value);
  private:
  bool _internal_enabled_wind() const;
  void _internal_set_enabled_wind(bool value);
  public:

  // optional bool is_static = 8;
  bool has_is_static() const;
  private:
  bool _internal_has_is_static() const;
  public:
  void clear_is_static();
  bool is_static() const;
  void set_is_static(bool value);
  private:
  bool _internal_is_static() const;
  void _internal_set_is_static(bool value);
  public:

  // optional bool canonical = 9;
  bool has_canonical() const;
  private:
  bool _internal_has_canonical() const;
  public:
  void clear_canonical();
  bool canonical() const;
  void set_canonical(bool value);
  private:
  bool _internal_canonical() const;
  void _internal_set_canonical(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ML_Links)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::mw::internal::robotics::gazebotransport::ML_Pose* pose_;
  ::mw::internal::robotics::gazebotransport::ML_Inertial* inertial_;
  bool self_collide_;
  bool gravity_;
  bool kinematic_;
  bool enabled_wind_;
  bool is_static_;
  bool canonical_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class ML_Axis PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ML_Axis) */ {
 public:
  inline ML_Axis() : ML_Axis(nullptr) {};
  virtual ~ML_Axis();

  ML_Axis(const ML_Axis& from);
  ML_Axis(ML_Axis&& from) noexcept
    : ML_Axis() {
    *this = ::std::move(from);
  }

  inline ML_Axis& operator=(const ML_Axis& from) {
    CopyFrom(from);
    return *this;
  }
  inline ML_Axis& operator=(ML_Axis&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ML_Axis& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ML_Axis* internal_default_instance() {
    return reinterpret_cast<const ML_Axis*>(
               &_ML_Axis_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(ML_Axis& a, ML_Axis& b) {
    a.Swap(&b);
  }
  inline void Swap(ML_Axis* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ML_Axis* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ML_Axis* New() const final {
    return CreateMaybeMessage<ML_Axis>(nullptr);
  }

  ML_Axis* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ML_Axis>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ML_Axis& from);
  void MergeFrom(const ML_Axis& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ML_Axis* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.ML_Axis";
  }
  protected:
  explicit ML_Axis(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXyzFieldNumber = 1,
    kDampingFieldNumber = 2,
    kFrictionFieldNumber = 3,
    kAngleFieldNumber = 4,
  };
  // optional .mw.internal.robotics.gazebotransport.ML_Point xyz = 1;
  bool has_xyz() const;
  private:
  bool _internal_has_xyz() const;
  public:
  void clear_xyz();
  const ::mw::internal::robotics::gazebotransport::ML_Point& xyz() const;
  ::mw::internal::robotics::gazebotransport::ML_Point* release_xyz();
  ::mw::internal::robotics::gazebotransport::ML_Point* mutable_xyz();
  void set_allocated_xyz(::mw::internal::robotics::gazebotransport::ML_Point* xyz);
  private:
  const ::mw::internal::robotics::gazebotransport::ML_Point& _internal_xyz() const;
  ::mw::internal::robotics::gazebotransport::ML_Point* _internal_mutable_xyz();
  public:
  void unsafe_arena_set_allocated_xyz(
      ::mw::internal::robotics::gazebotransport::ML_Point* xyz);
  ::mw::internal::robotics::gazebotransport::ML_Point* unsafe_arena_release_xyz();

  // optional double damping = 2;
  bool has_damping() const;
  private:
  bool _internal_has_damping() const;
  public:
  void clear_damping();
  double damping() const;
  void set_damping(double value);
  private:
  double _internal_damping() const;
  void _internal_set_damping(double value);
  public:

  // optional double friction = 3;
  bool has_friction() const;
  private:
  bool _internal_has_friction() const;
  public:
  void clear_friction();
  double friction() const;
  void set_friction(double value);
  private:
  double _internal_friction() const;
  void _internal_set_friction(double value);
  public:

  // optional double angle = 4;
  bool has_angle() const;
  private:
  bool _internal_has_angle() const;
  public:
  void clear_angle();
  double angle() const;
  void set_angle(double value);
  private:
  double _internal_angle() const;
  void _internal_set_angle(double value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ML_Axis)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::mw::internal::robotics::gazebotransport::ML_Point* xyz_;
  double damping_;
  double friction_;
  double angle_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class ML_Joints PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ML_Joints) */ {
 public:
  inline ML_Joints() : ML_Joints(nullptr) {};
  virtual ~ML_Joints();

  ML_Joints(const ML_Joints& from);
  ML_Joints(ML_Joints&& from) noexcept
    : ML_Joints() {
    *this = ::std::move(from);
  }

  inline ML_Joints& operator=(const ML_Joints& from) {
    CopyFrom(from);
    return *this;
  }
  inline ML_Joints& operator=(ML_Joints&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ML_Joints& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ML_Joints* internal_default_instance() {
    return reinterpret_cast<const ML_Joints*>(
               &_ML_Joints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(ML_Joints& a, ML_Joints& b) {
    a.Swap(&b);
  }
  inline void Swap(ML_Joints* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ML_Joints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ML_Joints* New() const final {
    return CreateMaybeMessage<ML_Joints>(nullptr);
  }

  ML_Joints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ML_Joints>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ML_Joints& from);
  void MergeFrom(const ML_Joints& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ML_Joints* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.ML_Joints";
  }
  protected:
  explicit ML_Joints(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPoseFieldNumber = 2,
    kAxis1FieldNumber = 3,
    kAxis2FieldNumber = 4,
    kCfmFieldNumber = 5,
    kFudgeFactorFieldNumber = 6,
    kSuspensionCfmFieldNumber = 7,
    kSuspensionErpFieldNumber = 8,
    kDofFieldNumber = 9,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 2;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::mw::internal::robotics::gazebotransport::ML_Pose& pose() const;
  ::mw::internal::robotics::gazebotransport::ML_Pose* release_pose();
  ::mw::internal::robotics::gazebotransport::ML_Pose* mutable_pose();
  void set_allocated_pose(::mw::internal::robotics::gazebotransport::ML_Pose* pose);
  private:
  const ::mw::internal::robotics::gazebotransport::ML_Pose& _internal_pose() const;
  ::mw::internal::robotics::gazebotransport::ML_Pose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::mw::internal::robotics::gazebotransport::ML_Pose* pose);
  ::mw::internal::robotics::gazebotransport::ML_Pose* unsafe_arena_release_pose();

  // optional .mw.internal.robotics.gazebotransport.ML_Axis axis1 = 3;
  bool has_axis1() const;
  private:
  bool _internal_has_axis1() const;
  public:
  void clear_axis1();
  const ::mw::internal::robotics::gazebotransport::ML_Axis& axis1() const;
  ::mw::internal::robotics::gazebotransport::ML_Axis* release_axis1();
  ::mw::internal::robotics::gazebotransport::ML_Axis* mutable_axis1();
  void set_allocated_axis1(::mw::internal::robotics::gazebotransport::ML_Axis* axis1);
  private:
  const ::mw::internal::robotics::gazebotransport::ML_Axis& _internal_axis1() const;
  ::mw::internal::robotics::gazebotransport::ML_Axis* _internal_mutable_axis1();
  public:
  void unsafe_arena_set_allocated_axis1(
      ::mw::internal::robotics::gazebotransport::ML_Axis* axis1);
  ::mw::internal::robotics::gazebotransport::ML_Axis* unsafe_arena_release_axis1();

  // optional .mw.internal.robotics.gazebotransport.ML_Axis axis2 = 4;
  bool has_axis2() const;
  private:
  bool _internal_has_axis2() const;
  public:
  void clear_axis2();
  const ::mw::internal::robotics::gazebotransport::ML_Axis& axis2() const;
  ::mw::internal::robotics::gazebotransport::ML_Axis* release_axis2();
  ::mw::internal::robotics::gazebotransport::ML_Axis* mutable_axis2();
  void set_allocated_axis2(::mw::internal::robotics::gazebotransport::ML_Axis* axis2);
  private:
  const ::mw::internal::robotics::gazebotransport::ML_Axis& _internal_axis2() const;
  ::mw::internal::robotics::gazebotransport::ML_Axis* _internal_mutable_axis2();
  public:
  void unsafe_arena_set_allocated_axis2(
      ::mw::internal::robotics::gazebotransport::ML_Axis* axis2);
  ::mw::internal::robotics::gazebotransport::ML_Axis* unsafe_arena_release_axis2();

  // optional double cfm = 5;
  bool has_cfm() const;
  private:
  bool _internal_has_cfm() const;
  public:
  void clear_cfm();
  double cfm() const;
  void set_cfm(double value);
  private:
  double _internal_cfm() const;
  void _internal_set_cfm(double value);
  public:

  // optional double fudge_factor = 6;
  bool has_fudge_factor() const;
  private:
  bool _internal_has_fudge_factor() const;
  public:
  void clear_fudge_factor();
  double fudge_factor() const;
  void set_fudge_factor(double value);
  private:
  double _internal_fudge_factor() const;
  void _internal_set_fudge_factor(double value);
  public:

  // optional double suspension_cfm = 7;
  bool has_suspension_cfm() const;
  private:
  bool _internal_has_suspension_cfm() const;
  public:
  void clear_suspension_cfm();
  double suspension_cfm() const;
  void set_suspension_cfm(double value);
  private:
  double _internal_suspension_cfm() const;
  void _internal_set_suspension_cfm(double value);
  public:

  // optional double suspension_erp = 8;
  bool has_suspension_erp() const;
  private:
  bool _internal_has_suspension_erp() const;
  public:
  void clear_suspension_erp();
  double suspension_erp() const;
  void set_suspension_erp(double value);
  private:
  double _internal_suspension_erp() const;
  void _internal_set_suspension_erp(double value);
  public:

  // optional uint32 dof = 9;
  bool has_dof() const;
  private:
  bool _internal_has_dof() const;
  public:
  void clear_dof();
  ::PROTOBUF_NAMESPACE_ID::uint32 dof() const;
  void set_dof(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_dof() const;
  void _internal_set_dof(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ML_Joints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::mw::internal::robotics::gazebotransport::ML_Pose* pose_;
  ::mw::internal::robotics::gazebotransport::ML_Axis* axis1_;
  ::mw::internal::robotics::gazebotransport::ML_Axis* axis2_;
  double cfm_;
  double fudge_factor_;
  double suspension_cfm_;
  double suspension_erp_;
  ::PROTOBUF_NAMESPACE_ID::uint32 dof_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class Gazebomodel PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.Gazebomodel) */ {
 public:
  inline Gazebomodel() : Gazebomodel(nullptr) {};
  virtual ~Gazebomodel();

  Gazebomodel(const Gazebomodel& from);
  Gazebomodel(Gazebomodel&& from) noexcept
    : Gazebomodel() {
    *this = ::std::move(from);
  }

  inline Gazebomodel& operator=(const Gazebomodel& from) {
    CopyFrom(from);
    return *this;
  }
  inline Gazebomodel& operator=(Gazebomodel&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Gazebomodel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Gazebomodel* internal_default_instance() {
    return reinterpret_cast<const Gazebomodel*>(
               &_Gazebomodel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(Gazebomodel& a, Gazebomodel& b) {
    a.Swap(&b);
  }
  inline void Swap(Gazebomodel* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Gazebomodel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Gazebomodel* New() const final {
    return CreateMaybeMessage<Gazebomodel>(nullptr);
  }

  Gazebomodel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Gazebomodel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Gazebomodel& from);
  void MergeFrom(const Gazebomodel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Gazebomodel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.Gazebomodel";
  }
  protected:
  explicit Gazebomodel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinksFieldNumber = 2,
    kJointsFieldNumber = 3,
    kNameFieldNumber = 1,
    kPoseFieldNumber = 4,
    kEnableWindFieldNumber = 5,
    kSelfCollideFieldNumber = 6,
    kIsStaticFieldNumber = 7,
  };
  // repeated .mw.internal.robotics.gazebotransport.ML_Links links = 2;
  int links_size() const;
  private:
  int _internal_links_size() const;
  public:
  void clear_links();
  ::mw::internal::robotics::gazebotransport::ML_Links* mutable_links(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ML_Links >*
      mutable_links();
  private:
  const ::mw::internal::robotics::gazebotransport::ML_Links& _internal_links(int index) const;
  ::mw::internal::robotics::gazebotransport::ML_Links* _internal_add_links();
  public:
  const ::mw::internal::robotics::gazebotransport::ML_Links& links(int index) const;
  ::mw::internal::robotics::gazebotransport::ML_Links* add_links();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ML_Links >&
      links() const;

  // repeated .mw.internal.robotics.gazebotransport.ML_Joints joints = 3;
  int joints_size() const;
  private:
  int _internal_joints_size() const;
  public:
  void clear_joints();
  ::mw::internal::robotics::gazebotransport::ML_Joints* mutable_joints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ML_Joints >*
      mutable_joints();
  private:
  const ::mw::internal::robotics::gazebotransport::ML_Joints& _internal_joints(int index) const;
  ::mw::internal::robotics::gazebotransport::ML_Joints* _internal_add_joints();
  public:
  const ::mw::internal::robotics::gazebotransport::ML_Joints& joints(int index) const;
  ::mw::internal::robotics::gazebotransport::ML_Joints* add_joints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ML_Joints >&
      joints() const;

  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 4;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::mw::internal::robotics::gazebotransport::ML_Pose& pose() const;
  ::mw::internal::robotics::gazebotransport::ML_Pose* release_pose();
  ::mw::internal::robotics::gazebotransport::ML_Pose* mutable_pose();
  void set_allocated_pose(::mw::internal::robotics::gazebotransport::ML_Pose* pose);
  private:
  const ::mw::internal::robotics::gazebotransport::ML_Pose& _internal_pose() const;
  ::mw::internal::robotics::gazebotransport::ML_Pose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::mw::internal::robotics::gazebotransport::ML_Pose* pose);
  ::mw::internal::robotics::gazebotransport::ML_Pose* unsafe_arena_release_pose();

  // optional bool enable_wind = 5;
  bool has_enable_wind() const;
  private:
  bool _internal_has_enable_wind() const;
  public:
  void clear_enable_wind();
  bool enable_wind() const;
  void set_enable_wind(bool value);
  private:
  bool _internal_enable_wind() const;
  void _internal_set_enable_wind(bool value);
  public:

  // optional bool self_collide = 6;
  bool has_self_collide() const;
  private:
  bool _internal_has_self_collide() const;
  public:
  void clear_self_collide();
  bool self_collide() const;
  void set_self_collide(bool value);
  private:
  bool _internal_self_collide() const;
  void _internal_set_self_collide(bool value);
  public:

  // optional bool is_static = 7;
  bool has_is_static() const;
  private:
  bool _internal_has_is_static() const;
  public:
  void clear_is_static();
  bool is_static() const;
  void set_is_static(bool value);
  private:
  bool _internal_is_static() const;
  void _internal_set_is_static(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.Gazebomodel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ML_Links > links_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ML_Joints > joints_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::mw::internal::robotics::gazebotransport::ML_Pose* pose_;
  bool enable_wind_;
  bool self_collide_;
  bool is_static_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class GetGazeboModelParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.GetGazeboModelParam) */ {
 public:
  inline GetGazeboModelParam() : GetGazeboModelParam(nullptr) {};
  virtual ~GetGazeboModelParam();

  GetGazeboModelParam(const GetGazeboModelParam& from);
  GetGazeboModelParam(GetGazeboModelParam&& from) noexcept
    : GetGazeboModelParam() {
    *this = ::std::move(from);
  }

  inline GetGazeboModelParam& operator=(const GetGazeboModelParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetGazeboModelParam& operator=(GetGazeboModelParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetGazeboModelParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetGazeboModelParam* internal_default_instance() {
    return reinterpret_cast<const GetGazeboModelParam*>(
               &_GetGazeboModelParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(GetGazeboModelParam& a, GetGazeboModelParam& b) {
    a.Swap(&b);
  }
  inline void Swap(GetGazeboModelParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetGazeboModelParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetGazeboModelParam* New() const final {
    return CreateMaybeMessage<GetGazeboModelParam>(nullptr);
  }

  GetGazeboModelParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetGazeboModelParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetGazeboModelParam& from);
  void MergeFrom(const GetGazeboModelParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetGazeboModelParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.GetGazeboModelParam";
  }
  protected:
  explicit GetGazeboModelParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 1,
    kLinkJointNameFieldNumber = 3,
    kIsLinkFieldNumber = 2,
  };
  // required string model_name = 1;
  bool has_model_name() const;
  private:
  bool _internal_has_model_name() const;
  public:
  void clear_model_name();
  const std::string& model_name() const;
  void set_model_name(const std::string& value);
  void set_model_name(std::string&& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  std::string* mutable_model_name();
  std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_model_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_model_name(
      std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // optional string link_joint_name = 3;
  bool has_link_joint_name() const;
  private:
  bool _internal_has_link_joint_name() const;
  public:
  void clear_link_joint_name();
  const std::string& link_joint_name() const;
  void set_link_joint_name(const std::string& value);
  void set_link_joint_name(std::string&& value);
  void set_link_joint_name(const char* value);
  void set_link_joint_name(const char* value, size_t size);
  std::string* mutable_link_joint_name();
  std::string* release_link_joint_name();
  void set_allocated_link_joint_name(std::string* link_joint_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_link_joint_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_link_joint_name(
      std::string* link_joint_name);
  private:
  const std::string& _internal_link_joint_name() const;
  void _internal_set_link_joint_name(const std::string& value);
  std::string* _internal_mutable_link_joint_name();
  public:

  // optional bool is_link = 2;
  bool has_is_link() const;
  private:
  bool _internal_has_is_link() const;
  public:
  void clear_is_link();
  bool is_link() const;
  void set_is_link(bool value);
  private:
  bool _internal_is_link() const;
  void _internal_set_is_link(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_joint_name_;
  bool is_link_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class GazeboModelSDF PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.GazeboModelSDF) */ {
 public:
  inline GazeboModelSDF() : GazeboModelSDF(nullptr) {};
  virtual ~GazeboModelSDF();

  GazeboModelSDF(const GazeboModelSDF& from);
  GazeboModelSDF(GazeboModelSDF&& from) noexcept
    : GazeboModelSDF() {
    *this = ::std::move(from);
  }

  inline GazeboModelSDF& operator=(const GazeboModelSDF& from) {
    CopyFrom(from);
    return *this;
  }
  inline GazeboModelSDF& operator=(GazeboModelSDF&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GazeboModelSDF& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GazeboModelSDF* internal_default_instance() {
    return reinterpret_cast<const GazeboModelSDF*>(
               &_GazeboModelSDF_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(GazeboModelSDF& a, GazeboModelSDF& b) {
    a.Swap(&b);
  }
  inline void Swap(GazeboModelSDF* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GazeboModelSDF* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GazeboModelSDF* New() const final {
    return CreateMaybeMessage<GazeboModelSDF>(nullptr);
  }

  GazeboModelSDF* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GazeboModelSDF>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GazeboModelSDF& from);
  void MergeFrom(const GazeboModelSDF& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GazeboModelSDF* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.GazeboModelSDF";
  }
  protected:
  explicit GazeboModelSDF(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 1,
    kSdfStringFieldNumber = 2,
  };
  // required string model_name = 1;
  bool has_model_name() const;
  private:
  bool _internal_has_model_name() const;
  public:
  void clear_model_name();
  const std::string& model_name() const;
  void set_model_name(const std::string& value);
  void set_model_name(std::string&& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  std::string* mutable_model_name();
  std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_model_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_model_name(
      std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // required string sdf_string = 2;
  bool has_sdf_string() const;
  private:
  bool _internal_has_sdf_string() const;
  public:
  void clear_sdf_string();
  const std::string& sdf_string() const;
  void set_sdf_string(const std::string& value);
  void set_sdf_string(std::string&& value);
  void set_sdf_string(const char* value);
  void set_sdf_string(const char* value, size_t size);
  std::string* mutable_sdf_string();
  std::string* release_sdf_string();
  void set_allocated_sdf_string(std::string* sdf_string);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_sdf_string();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_sdf_string(
      std::string* sdf_string);
  private:
  const std::string& _internal_sdf_string() const;
  void _internal_set_sdf_string(const std::string& value);
  std::string* _internal_mutable_sdf_string();
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.GazeboModelSDF)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdf_string_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// -------------------------------------------------------------------

class GetGazeboModelSDF PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.GetGazeboModelSDF) */ {
 public:
  inline GetGazeboModelSDF() : GetGazeboModelSDF(nullptr) {};
  virtual ~GetGazeboModelSDF();

  GetGazeboModelSDF(const GetGazeboModelSDF& from);
  GetGazeboModelSDF(GetGazeboModelSDF&& from) noexcept
    : GetGazeboModelSDF() {
    *this = ::std::move(from);
  }

  inline GetGazeboModelSDF& operator=(const GetGazeboModelSDF& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetGazeboModelSDF& operator=(GetGazeboModelSDF&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetGazeboModelSDF& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetGazeboModelSDF* internal_default_instance() {
    return reinterpret_cast<const GetGazeboModelSDF*>(
               &_GetGazeboModelSDF_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(GetGazeboModelSDF& a, GetGazeboModelSDF& b) {
    a.Swap(&b);
  }
  inline void Swap(GetGazeboModelSDF* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetGazeboModelSDF* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetGazeboModelSDF* New() const final {
    return CreateMaybeMessage<GetGazeboModelSDF>(nullptr);
  }

  GetGazeboModelSDF* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetGazeboModelSDF>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetGazeboModelSDF& from);
  void MergeFrom(const GetGazeboModelSDF& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetGazeboModelSDF* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.GetGazeboModelSDF";
  }
  protected:
  explicit GetGazeboModelSDF(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 1,
  };
  // required string model_name = 1;
  bool has_model_name() const;
  private:
  bool _internal_has_model_name() const;
  public:
  void clear_model_name();
  const std::string& model_name() const;
  void set_model_name(const std::string& value);
  void set_model_name(std::string&& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  std::string* mutable_model_name();
  std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_model_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_model_name(
      std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PluginVersion

// required string version = 1 [default = "R2022b"];
inline bool PluginVersion::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PluginVersion::has_version() const {
  return _internal_has_version();
}
inline void PluginVersion::clear_version() {
  version_.ClearToDefault(&::mw::internal::robotics::gazebotransport::PluginVersion::_i_give_permission_to_break_this_code_default_version_.get(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PluginVersion::version() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.PluginVersion.version)
  return _internal_version();
}
inline void PluginVersion::set_version(const std::string& value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.PluginVersion.version)
}
inline std::string* PluginVersion::mutable_version() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.PluginVersion.version)
  return _internal_mutable_version();
}
inline const std::string& PluginVersion::_internal_version() const {
  return version_.Get();
}
inline void PluginVersion::_internal_set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  version_.Set(&::mw::internal::robotics::gazebotransport::PluginVersion::_i_give_permission_to_break_this_code_default_version_.get(), value, GetArena());
}
inline void PluginVersion::set_version(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  version_.Set(
    &::mw::internal::robotics::gazebotransport::PluginVersion::_i_give_permission_to_break_this_code_default_version_.get(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.PluginVersion.version)
}
inline void PluginVersion::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  version_.Set(&::mw::internal::robotics::gazebotransport::PluginVersion::_i_give_permission_to_break_this_code_default_version_.get(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.PluginVersion.version)
}
inline void PluginVersion::set_version(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  version_.Set(&::mw::internal::robotics::gazebotransport::PluginVersion::_i_give_permission_to_break_this_code_default_version_.get(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.PluginVersion.version)
}
inline std::string* PluginVersion::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000001u;
  return version_.Mutable(&::mw::internal::robotics::gazebotransport::PluginVersion::_i_give_permission_to_break_this_code_default_version_.get(), GetArena());
}
inline std::string* PluginVersion::release_version() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.PluginVersion.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return version_.ReleaseNonDefault(&::mw::internal::robotics::gazebotransport::PluginVersion::_i_give_permission_to_break_this_code_default_version_.get(), GetArena());
}
inline void PluginVersion::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  version_.SetAllocated(&::mw::internal::robotics::gazebotransport::PluginVersion::_i_give_permission_to_break_this_code_default_version_.get(), version,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.PluginVersion.version)
}
inline std::string* PluginVersion::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.PluginVersion.version)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return version_.UnsafeArenaRelease(&::mw::internal::robotics::gazebotransport::PluginVersion::_i_give_permission_to_break_this_code_default_version_.get(),
      GetArena());
}
inline void PluginVersion::unsafe_arena_set_allocated_version(
    std::string* version) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  version_.UnsafeArenaSetAllocated(&::mw::internal::robotics::gazebotransport::PluginVersion::_i_give_permission_to_break_this_code_default_version_.get(),
      version, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.PluginVersion.version)
}

// -------------------------------------------------------------------

// Time

// required uint64 seconds = 1;
inline bool Time::_internal_has_seconds() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Time::has_seconds() const {
  return _internal_has_seconds();
}
inline void Time::clear_seconds() {
  seconds_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Time::_internal_seconds() const {
  return seconds_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Time::seconds() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Time.seconds)
  return _internal_seconds();
}
inline void Time::_internal_set_seconds(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  seconds_ = value;
}
inline void Time::set_seconds(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Time.seconds)
}

// required uint64 nano_seconds = 2;
inline bool Time::_internal_has_nano_seconds() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Time::has_nano_seconds() const {
  return _internal_has_nano_seconds();
}
inline void Time::clear_nano_seconds() {
  nano_seconds_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Time::_internal_nano_seconds() const {
  return nano_seconds_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Time::nano_seconds() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Time.nano_seconds)
  return _internal_nano_seconds();
}
inline void Time::_internal_set_nano_seconds(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  nano_seconds_ = value;
}
inline void Time::set_nano_seconds(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_nano_seconds(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Time.nano_seconds)
}

// -------------------------------------------------------------------

// PacketHeader

// required .mw.internal.robotics.gazebotransport.PacketHeader.MsgID id = 1;
inline bool PacketHeader::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PacketHeader::has_id() const {
  return _internal_has_id();
}
inline void PacketHeader::clear_id() {
  id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::mw::internal::robotics::gazebotransport::PacketHeader_MsgID PacketHeader::_internal_id() const {
  return static_cast< ::mw::internal::robotics::gazebotransport::PacketHeader_MsgID >(id_);
}
inline ::mw::internal::robotics::gazebotransport::PacketHeader_MsgID PacketHeader::id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.PacketHeader.id)
  return _internal_id();
}
inline void PacketHeader::_internal_set_id(::mw::internal::robotics::gazebotransport::PacketHeader_MsgID value) {
  assert(::mw::internal::robotics::gazebotransport::PacketHeader_MsgID_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  id_ = value;
}
inline void PacketHeader::set_id(::mw::internal::robotics::gazebotransport::PacketHeader_MsgID value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.PacketHeader.id)
}

// required .mw.internal.robotics.gazebotransport.Time time_stamp = 2;
inline bool PacketHeader::_internal_has_time_stamp() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || time_stamp_ != nullptr);
  return value;
}
inline bool PacketHeader::has_time_stamp() const {
  return _internal_has_time_stamp();
}
inline void PacketHeader::clear_time_stamp() {
  if (time_stamp_ != nullptr) time_stamp_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mw::internal::robotics::gazebotransport::Time& PacketHeader::_internal_time_stamp() const {
  const ::mw::internal::robotics::gazebotransport::Time* p = time_stamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Time*>(
      &::mw::internal::robotics::gazebotransport::_Time_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Time& PacketHeader::time_stamp() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.PacketHeader.time_stamp)
  return _internal_time_stamp();
}
inline void PacketHeader::unsafe_arena_set_allocated_time_stamp(
    ::mw::internal::robotics::gazebotransport::Time* time_stamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_stamp_);
  }
  time_stamp_ = time_stamp;
  if (time_stamp) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.PacketHeader.time_stamp)
}
inline ::mw::internal::robotics::gazebotransport::Time* PacketHeader::release_time_stamp() {
  auto temp = unsafe_arena_release_time_stamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Time* PacketHeader::unsafe_arena_release_time_stamp() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.PacketHeader.time_stamp)
  _has_bits_[0] &= ~0x00000001u;
  ::mw::internal::robotics::gazebotransport::Time* temp = time_stamp_;
  time_stamp_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Time* PacketHeader::_internal_mutable_time_stamp() {
  _has_bits_[0] |= 0x00000001u;
  if (time_stamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Time>(GetArena());
    time_stamp_ = p;
  }
  return time_stamp_;
}
inline ::mw::internal::robotics::gazebotransport::Time* PacketHeader::mutable_time_stamp() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.PacketHeader.time_stamp)
  return _internal_mutable_time_stamp();
}
inline void PacketHeader::set_allocated_time_stamp(::mw::internal::robotics::gazebotransport::Time* time_stamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete time_stamp_;
  }
  if (time_stamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(time_stamp);
    if (message_arena != submessage_arena) {
      time_stamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_stamp, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  time_stamp_ = time_stamp;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.PacketHeader.time_stamp)
}

// -------------------------------------------------------------------

// Packet

// required .mw.internal.robotics.gazebotransport.PacketHeader header = 1;
inline bool Packet::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool Packet::has_header() const {
  return _internal_has_header();
}
inline void Packet::clear_header() {
  if (header_ != nullptr) header_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mw::internal::robotics::gazebotransport::PacketHeader& Packet::_internal_header() const {
  const ::mw::internal::robotics::gazebotransport::PacketHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::PacketHeader*>(
      &::mw::internal::robotics::gazebotransport::_PacketHeader_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::PacketHeader& Packet::header() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.header)
  return _internal_header();
}
inline void Packet::unsafe_arena_set_allocated_header(
    ::mw::internal::robotics::gazebotransport::PacketHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.header)
}
inline ::mw::internal::robotics::gazebotransport::PacketHeader* Packet::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::PacketHeader* Packet::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.header)
  _has_bits_[0] &= ~0x00000002u;
  ::mw::internal::robotics::gazebotransport::PacketHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::PacketHeader* Packet::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000002u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::PacketHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::mw::internal::robotics::gazebotransport::PacketHeader* Packet::mutable_header() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.header)
  return _internal_mutable_header();
}
inline void Packet::set_allocated_header(::mw::internal::robotics::gazebotransport::PacketHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.header)
}

// .mw.internal.robotics.gazebotransport.Packet.CoSimError status = 2;
inline bool Packet::_internal_has_status() const {
  return payload_case() == kStatus;
}
inline bool Packet::has_status() const {
  return _internal_has_status();
}
inline void Packet::set_has_status() {
  _oneof_case_[0] = kStatus;
}
inline void Packet::clear_status() {
  if (_internal_has_status()) {
    payload_.status_ = 0;
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::Packet_CoSimError Packet::_internal_status() const {
  if (_internal_has_status()) {
    return static_cast< ::mw::internal::robotics::gazebotransport::Packet_CoSimError >(payload_.status_);
  }
  return static_cast< ::mw::internal::robotics::gazebotransport::Packet_CoSimError >(0);
}
inline ::mw::internal::robotics::gazebotransport::Packet_CoSimError Packet::status() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.status)
  return _internal_status();
}
inline void Packet::_internal_set_status(::mw::internal::robotics::gazebotransport::Packet_CoSimError value) {
  assert(::mw::internal::robotics::gazebotransport::Packet_CoSimError_IsValid(value));
  if (!_internal_has_status()) {
    clear_payload();
    set_has_status();
  }
  payload_.status_ = value;
}
inline void Packet::set_status(::mw::internal::robotics::gazebotransport::Packet_CoSimError value) {
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Packet.status)
  _internal_set_status(value);
}

// .mw.internal.robotics.gazebotransport.StepSimulation step_simulation = 3;
inline bool Packet::_internal_has_step_simulation() const {
  return payload_case() == kStepSimulation;
}
inline bool Packet::has_step_simulation() const {
  return _internal_has_step_simulation();
}
inline void Packet::set_has_step_simulation() {
  _oneof_case_[0] = kStepSimulation;
}
inline void Packet::clear_step_simulation() {
  if (_internal_has_step_simulation()) {
    if (GetArena() == nullptr) {
      delete payload_.step_simulation_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::StepSimulation* Packet::release_step_simulation() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.step_simulation)
  if (_internal_has_step_simulation()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::StepSimulation* temp = payload_.step_simulation_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.step_simulation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::StepSimulation& Packet::_internal_step_simulation() const {
  return _internal_has_step_simulation()
      ? *payload_.step_simulation_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::StepSimulation*>(&::mw::internal::robotics::gazebotransport::_StepSimulation_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::StepSimulation& Packet::step_simulation() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.step_simulation)
  return _internal_step_simulation();
}
inline ::mw::internal::robotics::gazebotransport::StepSimulation* Packet::unsafe_arena_release_step_simulation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.step_simulation)
  if (_internal_has_step_simulation()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::StepSimulation* temp = payload_.step_simulation_;
    payload_.step_simulation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_step_simulation(::mw::internal::robotics::gazebotransport::StepSimulation* step_simulation) {
  clear_payload();
  if (step_simulation) {
    set_has_step_simulation();
    payload_.step_simulation_ = step_simulation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.step_simulation)
}
inline ::mw::internal::robotics::gazebotransport::StepSimulation* Packet::_internal_mutable_step_simulation() {
  if (!_internal_has_step_simulation()) {
    clear_payload();
    set_has_step_simulation();
    payload_.step_simulation_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::StepSimulation >(GetArena());
  }
  return payload_.step_simulation_;
}
inline ::mw::internal::robotics::gazebotransport::StepSimulation* Packet::mutable_step_simulation() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.step_simulation)
  return _internal_mutable_step_simulation();
}

// .mw.internal.robotics.gazebotransport.ResetSimulation reset_simulation = 4;
inline bool Packet::_internal_has_reset_simulation() const {
  return payload_case() == kResetSimulation;
}
inline bool Packet::has_reset_simulation() const {
  return _internal_has_reset_simulation();
}
inline void Packet::set_has_reset_simulation() {
  _oneof_case_[0] = kResetSimulation;
}
inline void Packet::clear_reset_simulation() {
  if (_internal_has_reset_simulation()) {
    if (GetArena() == nullptr) {
      delete payload_.reset_simulation_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::ResetSimulation* Packet::release_reset_simulation() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.reset_simulation)
  if (_internal_has_reset_simulation()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::ResetSimulation* temp = payload_.reset_simulation_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.reset_simulation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::ResetSimulation& Packet::_internal_reset_simulation() const {
  return _internal_has_reset_simulation()
      ? *payload_.reset_simulation_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::ResetSimulation*>(&::mw::internal::robotics::gazebotransport::_ResetSimulation_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::ResetSimulation& Packet::reset_simulation() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.reset_simulation)
  return _internal_reset_simulation();
}
inline ::mw::internal::robotics::gazebotransport::ResetSimulation* Packet::unsafe_arena_release_reset_simulation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.reset_simulation)
  if (_internal_has_reset_simulation()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::ResetSimulation* temp = payload_.reset_simulation_;
    payload_.reset_simulation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_reset_simulation(::mw::internal::robotics::gazebotransport::ResetSimulation* reset_simulation) {
  clear_payload();
  if (reset_simulation) {
    set_has_reset_simulation();
    payload_.reset_simulation_ = reset_simulation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.reset_simulation)
}
inline ::mw::internal::robotics::gazebotransport::ResetSimulation* Packet::_internal_mutable_reset_simulation() {
  if (!_internal_has_reset_simulation()) {
    clear_payload();
    set_has_reset_simulation();
    payload_.reset_simulation_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::ResetSimulation >(GetArena());
  }
  return payload_.reset_simulation_;
}
inline ::mw::internal::robotics::gazebotransport::ResetSimulation* Packet::mutable_reset_simulation() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.reset_simulation)
  return _internal_mutable_reset_simulation();
}

// .mw.internal.robotics.gazebotransport.Image image = 5;
inline bool Packet::_internal_has_image() const {
  return payload_case() == kImage;
}
inline bool Packet::has_image() const {
  return _internal_has_image();
}
inline void Packet::set_has_image() {
  _oneof_case_[0] = kImage;
}
inline void Packet::clear_image() {
  if (_internal_has_image()) {
    if (GetArena() == nullptr) {
      delete payload_.image_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::Image* Packet::release_image() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.image)
  if (_internal_has_image()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::Image* temp = payload_.image_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::Image& Packet::_internal_image() const {
  return _internal_has_image()
      ? *payload_.image_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::Image*>(&::mw::internal::robotics::gazebotransport::_Image_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Image& Packet::image() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.image)
  return _internal_image();
}
inline ::mw::internal::robotics::gazebotransport::Image* Packet::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.image)
  if (_internal_has_image()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::Image* temp = payload_.image_;
    payload_.image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_image(::mw::internal::robotics::gazebotransport::Image* image) {
  clear_payload();
  if (image) {
    set_has_image();
    payload_.image_ = image;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.image)
}
inline ::mw::internal::robotics::gazebotransport::Image* Packet::_internal_mutable_image() {
  if (!_internal_has_image()) {
    clear_payload();
    set_has_image();
    payload_.image_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::Image >(GetArena());
  }
  return payload_.image_;
}
inline ::mw::internal::robotics::gazebotransport::Image* Packet::mutable_image() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.image)
  return _internal_mutable_image();
}

// .mw.internal.robotics.gazebotransport.RequestImage request_image = 6;
inline bool Packet::_internal_has_request_image() const {
  return payload_case() == kRequestImage;
}
inline bool Packet::has_request_image() const {
  return _internal_has_request_image();
}
inline void Packet::set_has_request_image() {
  _oneof_case_[0] = kRequestImage;
}
inline void Packet::clear_request_image() {
  if (_internal_has_request_image()) {
    if (GetArena() == nullptr) {
      delete payload_.request_image_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::RequestImage* Packet::release_request_image() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.request_image)
  if (_internal_has_request_image()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::RequestImage* temp = payload_.request_image_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.request_image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::RequestImage& Packet::_internal_request_image() const {
  return _internal_has_request_image()
      ? *payload_.request_image_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::RequestImage*>(&::mw::internal::robotics::gazebotransport::_RequestImage_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::RequestImage& Packet::request_image() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.request_image)
  return _internal_request_image();
}
inline ::mw::internal::robotics::gazebotransport::RequestImage* Packet::unsafe_arena_release_request_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.request_image)
  if (_internal_has_request_image()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::RequestImage* temp = payload_.request_image_;
    payload_.request_image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_request_image(::mw::internal::robotics::gazebotransport::RequestImage* request_image) {
  clear_payload();
  if (request_image) {
    set_has_request_image();
    payload_.request_image_ = request_image;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.request_image)
}
inline ::mw::internal::robotics::gazebotransport::RequestImage* Packet::_internal_mutable_request_image() {
  if (!_internal_has_request_image()) {
    clear_payload();
    set_has_request_image();
    payload_.request_image_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::RequestImage >(GetArena());
  }
  return payload_.request_image_;
}
inline ::mw::internal::robotics::gazebotransport::RequestImage* Packet::mutable_request_image() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.request_image)
  return _internal_mutable_request_image();
}

// .mw.internal.robotics.gazebotransport.RequestCoSim request_cosim = 7;
inline bool Packet::_internal_has_request_cosim() const {
  return payload_case() == kRequestCosim;
}
inline bool Packet::has_request_cosim() const {
  return _internal_has_request_cosim();
}
inline void Packet::set_has_request_cosim() {
  _oneof_case_[0] = kRequestCosim;
}
inline void Packet::clear_request_cosim() {
  if (_internal_has_request_cosim()) {
    if (GetArena() == nullptr) {
      delete payload_.request_cosim_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::RequestCoSim* Packet::release_request_cosim() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.request_cosim)
  if (_internal_has_request_cosim()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::RequestCoSim* temp = payload_.request_cosim_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.request_cosim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::RequestCoSim& Packet::_internal_request_cosim() const {
  return _internal_has_request_cosim()
      ? *payload_.request_cosim_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::RequestCoSim*>(&::mw::internal::robotics::gazebotransport::_RequestCoSim_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::RequestCoSim& Packet::request_cosim() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.request_cosim)
  return _internal_request_cosim();
}
inline ::mw::internal::robotics::gazebotransport::RequestCoSim* Packet::unsafe_arena_release_request_cosim() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.request_cosim)
  if (_internal_has_request_cosim()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::RequestCoSim* temp = payload_.request_cosim_;
    payload_.request_cosim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_request_cosim(::mw::internal::robotics::gazebotransport::RequestCoSim* request_cosim) {
  clear_payload();
  if (request_cosim) {
    set_has_request_cosim();
    payload_.request_cosim_ = request_cosim;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.request_cosim)
}
inline ::mw::internal::robotics::gazebotransport::RequestCoSim* Packet::_internal_mutable_request_cosim() {
  if (!_internal_has_request_cosim()) {
    clear_payload();
    set_has_request_cosim();
    payload_.request_cosim_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::RequestCoSim >(GetArena());
  }
  return payload_.request_cosim_;
}
inline ::mw::internal::robotics::gazebotransport::RequestCoSim* Packet::mutable_request_cosim() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.request_cosim)
  return _internal_mutable_request_cosim();
}

// .mw.internal.robotics.gazebotransport.StopCoSim stop_cosim = 8;
inline bool Packet::_internal_has_stop_cosim() const {
  return payload_case() == kStopCosim;
}
inline bool Packet::has_stop_cosim() const {
  return _internal_has_stop_cosim();
}
inline void Packet::set_has_stop_cosim() {
  _oneof_case_[0] = kStopCosim;
}
inline void Packet::clear_stop_cosim() {
  if (_internal_has_stop_cosim()) {
    if (GetArena() == nullptr) {
      delete payload_.stop_cosim_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::StopCoSim* Packet::release_stop_cosim() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.stop_cosim)
  if (_internal_has_stop_cosim()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::StopCoSim* temp = payload_.stop_cosim_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.stop_cosim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::StopCoSim& Packet::_internal_stop_cosim() const {
  return _internal_has_stop_cosim()
      ? *payload_.stop_cosim_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::StopCoSim*>(&::mw::internal::robotics::gazebotransport::_StopCoSim_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::StopCoSim& Packet::stop_cosim() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.stop_cosim)
  return _internal_stop_cosim();
}
inline ::mw::internal::robotics::gazebotransport::StopCoSim* Packet::unsafe_arena_release_stop_cosim() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.stop_cosim)
  if (_internal_has_stop_cosim()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::StopCoSim* temp = payload_.stop_cosim_;
    payload_.stop_cosim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_stop_cosim(::mw::internal::robotics::gazebotransport::StopCoSim* stop_cosim) {
  clear_payload();
  if (stop_cosim) {
    set_has_stop_cosim();
    payload_.stop_cosim_ = stop_cosim;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.stop_cosim)
}
inline ::mw::internal::robotics::gazebotransport::StopCoSim* Packet::_internal_mutable_stop_cosim() {
  if (!_internal_has_stop_cosim()) {
    clear_payload();
    set_has_stop_cosim();
    payload_.stop_cosim_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::StopCoSim >(GetArena());
  }
  return payload_.stop_cosim_;
}
inline ::mw::internal::robotics::gazebotransport::StopCoSim* Packet::mutable_stop_cosim() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.stop_cosim)
  return _internal_mutable_stop_cosim();
}

// .mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose get_ground_truth_world_pose = 9;
inline bool Packet::_internal_has_get_ground_truth_world_pose() const {
  return payload_case() == kGetGroundTruthWorldPose;
}
inline bool Packet::has_get_ground_truth_world_pose() const {
  return _internal_has_get_ground_truth_world_pose();
}
inline void Packet::set_has_get_ground_truth_world_pose() {
  _oneof_case_[0] = kGetGroundTruthWorldPose;
}
inline void Packet::clear_get_ground_truth_world_pose() {
  if (_internal_has_get_ground_truth_world_pose()) {
    if (GetArena() == nullptr) {
      delete payload_.get_ground_truth_world_pose_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* Packet::release_get_ground_truth_world_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_ground_truth_world_pose)
  if (_internal_has_get_ground_truth_world_pose()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* temp = payload_.get_ground_truth_world_pose_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.get_ground_truth_world_pose_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose& Packet::_internal_get_ground_truth_world_pose() const {
  return _internal_has_get_ground_truth_world_pose()
      ? *payload_.get_ground_truth_world_pose_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose*>(&::mw::internal::robotics::gazebotransport::_GetGroundTruthWorldPose_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose& Packet::get_ground_truth_world_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_ground_truth_world_pose)
  return _internal_get_ground_truth_world_pose();
}
inline ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* Packet::unsafe_arena_release_get_ground_truth_world_pose() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.get_ground_truth_world_pose)
  if (_internal_has_get_ground_truth_world_pose()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* temp = payload_.get_ground_truth_world_pose_;
    payload_.get_ground_truth_world_pose_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_get_ground_truth_world_pose(::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* get_ground_truth_world_pose) {
  clear_payload();
  if (get_ground_truth_world_pose) {
    set_has_get_ground_truth_world_pose();
    payload_.get_ground_truth_world_pose_ = get_ground_truth_world_pose;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_ground_truth_world_pose)
}
inline ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* Packet::_internal_mutable_get_ground_truth_world_pose() {
  if (!_internal_has_get_ground_truth_world_pose()) {
    clear_payload();
    set_has_get_ground_truth_world_pose();
    payload_.get_ground_truth_world_pose_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose >(GetArena());
  }
  return payload_.get_ground_truth_world_pose_;
}
inline ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* Packet::mutable_get_ground_truth_world_pose() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_ground_truth_world_pose)
  return _internal_mutable_get_ground_truth_world_pose();
}

// .mw.internal.robotics.gazebotransport.Pose pose = 10;
inline bool Packet::_internal_has_pose() const {
  return payload_case() == kPose;
}
inline bool Packet::has_pose() const {
  return _internal_has_pose();
}
inline void Packet::set_has_pose() {
  _oneof_case_[0] = kPose;
}
inline void Packet::clear_pose() {
  if (_internal_has_pose()) {
    if (GetArena() == nullptr) {
      delete payload_.pose_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::Pose* Packet::release_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.pose)
  if (_internal_has_pose()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::Pose* temp = payload_.pose_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.pose_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::Pose& Packet::_internal_pose() const {
  return _internal_has_pose()
      ? *payload_.pose_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::Pose*>(&::mw::internal::robotics::gazebotransport::_Pose_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Pose& Packet::pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.pose)
  return _internal_pose();
}
inline ::mw::internal::robotics::gazebotransport::Pose* Packet::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.pose)
  if (_internal_has_pose()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::Pose* temp = payload_.pose_;
    payload_.pose_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_pose(::mw::internal::robotics::gazebotransport::Pose* pose) {
  clear_payload();
  if (pose) {
    set_has_pose();
    payload_.pose_ = pose;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.pose)
}
inline ::mw::internal::robotics::gazebotransport::Pose* Packet::_internal_mutable_pose() {
  if (!_internal_has_pose()) {
    clear_payload();
    set_has_pose();
    payload_.pose_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::Pose >(GetArena());
  }
  return payload_.pose_;
}
inline ::mw::internal::robotics::gazebotransport::Pose* Packet::mutable_pose() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.pose)
  return _internal_mutable_pose();
}

// .mw.internal.robotics.gazebotransport.StopSimulation stop_simulation = 11;
inline bool Packet::_internal_has_stop_simulation() const {
  return payload_case() == kStopSimulation;
}
inline bool Packet::has_stop_simulation() const {
  return _internal_has_stop_simulation();
}
inline void Packet::set_has_stop_simulation() {
  _oneof_case_[0] = kStopSimulation;
}
inline void Packet::clear_stop_simulation() {
  if (_internal_has_stop_simulation()) {
    if (GetArena() == nullptr) {
      delete payload_.stop_simulation_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::StopSimulation* Packet::release_stop_simulation() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.stop_simulation)
  if (_internal_has_stop_simulation()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::StopSimulation* temp = payload_.stop_simulation_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.stop_simulation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::StopSimulation& Packet::_internal_stop_simulation() const {
  return _internal_has_stop_simulation()
      ? *payload_.stop_simulation_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::StopSimulation*>(&::mw::internal::robotics::gazebotransport::_StopSimulation_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::StopSimulation& Packet::stop_simulation() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.stop_simulation)
  return _internal_stop_simulation();
}
inline ::mw::internal::robotics::gazebotransport::StopSimulation* Packet::unsafe_arena_release_stop_simulation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.stop_simulation)
  if (_internal_has_stop_simulation()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::StopSimulation* temp = payload_.stop_simulation_;
    payload_.stop_simulation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_stop_simulation(::mw::internal::robotics::gazebotransport::StopSimulation* stop_simulation) {
  clear_payload();
  if (stop_simulation) {
    set_has_stop_simulation();
    payload_.stop_simulation_ = stop_simulation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.stop_simulation)
}
inline ::mw::internal::robotics::gazebotransport::StopSimulation* Packet::_internal_mutable_stop_simulation() {
  if (!_internal_has_stop_simulation()) {
    clear_payload();
    set_has_stop_simulation();
    payload_.stop_simulation_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::StopSimulation >(GetArena());
  }
  return payload_.stop_simulation_;
}
inline ::mw::internal::robotics::gazebotransport::StopSimulation* Packet::mutable_stop_simulation() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.stop_simulation)
  return _internal_mutable_stop_simulation();
}

// .mw.internal.robotics.gazebotransport.LaserData laser_data = 12;
inline bool Packet::_internal_has_laser_data() const {
  return payload_case() == kLaserData;
}
inline bool Packet::has_laser_data() const {
  return _internal_has_laser_data();
}
inline void Packet::set_has_laser_data() {
  _oneof_case_[0] = kLaserData;
}
inline void Packet::clear_laser_data() {
  if (_internal_has_laser_data()) {
    if (GetArena() == nullptr) {
      delete payload_.laser_data_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::LaserData* Packet::release_laser_data() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.laser_data)
  if (_internal_has_laser_data()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::LaserData* temp = payload_.laser_data_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.laser_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::LaserData& Packet::_internal_laser_data() const {
  return _internal_has_laser_data()
      ? *payload_.laser_data_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::LaserData*>(&::mw::internal::robotics::gazebotransport::_LaserData_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::LaserData& Packet::laser_data() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.laser_data)
  return _internal_laser_data();
}
inline ::mw::internal::robotics::gazebotransport::LaserData* Packet::unsafe_arena_release_laser_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.laser_data)
  if (_internal_has_laser_data()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::LaserData* temp = payload_.laser_data_;
    payload_.laser_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_laser_data(::mw::internal::robotics::gazebotransport::LaserData* laser_data) {
  clear_payload();
  if (laser_data) {
    set_has_laser_data();
    payload_.laser_data_ = laser_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.laser_data)
}
inline ::mw::internal::robotics::gazebotransport::LaserData* Packet::_internal_mutable_laser_data() {
  if (!_internal_has_laser_data()) {
    clear_payload();
    set_has_laser_data();
    payload_.laser_data_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::LaserData >(GetArena());
  }
  return payload_.laser_data_;
}
inline ::mw::internal::robotics::gazebotransport::LaserData* Packet::mutable_laser_data() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.laser_data)
  return _internal_mutable_laser_data();
}

// .mw.internal.robotics.gazebotransport.RequestLaser request_laser = 13;
inline bool Packet::_internal_has_request_laser() const {
  return payload_case() == kRequestLaser;
}
inline bool Packet::has_request_laser() const {
  return _internal_has_request_laser();
}
inline void Packet::set_has_request_laser() {
  _oneof_case_[0] = kRequestLaser;
}
inline void Packet::clear_request_laser() {
  if (_internal_has_request_laser()) {
    if (GetArena() == nullptr) {
      delete payload_.request_laser_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::RequestLaser* Packet::release_request_laser() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.request_laser)
  if (_internal_has_request_laser()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::RequestLaser* temp = payload_.request_laser_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.request_laser_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::RequestLaser& Packet::_internal_request_laser() const {
  return _internal_has_request_laser()
      ? *payload_.request_laser_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::RequestLaser*>(&::mw::internal::robotics::gazebotransport::_RequestLaser_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::RequestLaser& Packet::request_laser() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.request_laser)
  return _internal_request_laser();
}
inline ::mw::internal::robotics::gazebotransport::RequestLaser* Packet::unsafe_arena_release_request_laser() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.request_laser)
  if (_internal_has_request_laser()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::RequestLaser* temp = payload_.request_laser_;
    payload_.request_laser_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_request_laser(::mw::internal::robotics::gazebotransport::RequestLaser* request_laser) {
  clear_payload();
  if (request_laser) {
    set_has_request_laser();
    payload_.request_laser_ = request_laser;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.request_laser)
}
inline ::mw::internal::robotics::gazebotransport::RequestLaser* Packet::_internal_mutable_request_laser() {
  if (!_internal_has_request_laser()) {
    clear_payload();
    set_has_request_laser();
    payload_.request_laser_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::RequestLaser >(GetArena());
  }
  return payload_.request_laser_;
}
inline ::mw::internal::robotics::gazebotransport::RequestLaser* Packet::mutable_request_laser() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.request_laser)
  return _internal_mutable_request_laser();
}

// .mw.internal.robotics.gazebotransport.ImuData imu_data = 14;
inline bool Packet::_internal_has_imu_data() const {
  return payload_case() == kImuData;
}
inline bool Packet::has_imu_data() const {
  return _internal_has_imu_data();
}
inline void Packet::set_has_imu_data() {
  _oneof_case_[0] = kImuData;
}
inline void Packet::clear_imu_data() {
  if (_internal_has_imu_data()) {
    if (GetArena() == nullptr) {
      delete payload_.imu_data_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::ImuData* Packet::release_imu_data() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.imu_data)
  if (_internal_has_imu_data()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::ImuData* temp = payload_.imu_data_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.imu_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::ImuData& Packet::_internal_imu_data() const {
  return _internal_has_imu_data()
      ? *payload_.imu_data_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::ImuData*>(&::mw::internal::robotics::gazebotransport::_ImuData_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::ImuData& Packet::imu_data() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.imu_data)
  return _internal_imu_data();
}
inline ::mw::internal::robotics::gazebotransport::ImuData* Packet::unsafe_arena_release_imu_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.imu_data)
  if (_internal_has_imu_data()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::ImuData* temp = payload_.imu_data_;
    payload_.imu_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_imu_data(::mw::internal::robotics::gazebotransport::ImuData* imu_data) {
  clear_payload();
  if (imu_data) {
    set_has_imu_data();
    payload_.imu_data_ = imu_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.imu_data)
}
inline ::mw::internal::robotics::gazebotransport::ImuData* Packet::_internal_mutable_imu_data() {
  if (!_internal_has_imu_data()) {
    clear_payload();
    set_has_imu_data();
    payload_.imu_data_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::ImuData >(GetArena());
  }
  return payload_.imu_data_;
}
inline ::mw::internal::robotics::gazebotransport::ImuData* Packet::mutable_imu_data() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.imu_data)
  return _internal_mutable_imu_data();
}

// .mw.internal.robotics.gazebotransport.RequestImu request_imu = 15;
inline bool Packet::_internal_has_request_imu() const {
  return payload_case() == kRequestImu;
}
inline bool Packet::has_request_imu() const {
  return _internal_has_request_imu();
}
inline void Packet::set_has_request_imu() {
  _oneof_case_[0] = kRequestImu;
}
inline void Packet::clear_request_imu() {
  if (_internal_has_request_imu()) {
    if (GetArena() == nullptr) {
      delete payload_.request_imu_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::RequestImu* Packet::release_request_imu() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.request_imu)
  if (_internal_has_request_imu()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::RequestImu* temp = payload_.request_imu_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.request_imu_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::RequestImu& Packet::_internal_request_imu() const {
  return _internal_has_request_imu()
      ? *payload_.request_imu_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::RequestImu*>(&::mw::internal::robotics::gazebotransport::_RequestImu_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::RequestImu& Packet::request_imu() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.request_imu)
  return _internal_request_imu();
}
inline ::mw::internal::robotics::gazebotransport::RequestImu* Packet::unsafe_arena_release_request_imu() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.request_imu)
  if (_internal_has_request_imu()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::RequestImu* temp = payload_.request_imu_;
    payload_.request_imu_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_request_imu(::mw::internal::robotics::gazebotransport::RequestImu* request_imu) {
  clear_payload();
  if (request_imu) {
    set_has_request_imu();
    payload_.request_imu_ = request_imu;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.request_imu)
}
inline ::mw::internal::robotics::gazebotransport::RequestImu* Packet::_internal_mutable_request_imu() {
  if (!_internal_has_request_imu()) {
    clear_payload();
    set_has_request_imu();
    payload_.request_imu_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::RequestImu >(GetArena());
  }
  return payload_.request_imu_;
}
inline ::mw::internal::robotics::gazebotransport::RequestImu* Packet::mutable_request_imu() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.request_imu)
  return _internal_mutable_request_imu();
}

// .mw.internal.robotics.gazebotransport.SubscribeImage subscribe_image = 16;
inline bool Packet::_internal_has_subscribe_image() const {
  return payload_case() == kSubscribeImage;
}
inline bool Packet::has_subscribe_image() const {
  return _internal_has_subscribe_image();
}
inline void Packet::set_has_subscribe_image() {
  _oneof_case_[0] = kSubscribeImage;
}
inline void Packet::clear_subscribe_image() {
  if (_internal_has_subscribe_image()) {
    if (GetArena() == nullptr) {
      delete payload_.subscribe_image_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::SubscribeImage* Packet::release_subscribe_image() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.subscribe_image)
  if (_internal_has_subscribe_image()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::SubscribeImage* temp = payload_.subscribe_image_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.subscribe_image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::SubscribeImage& Packet::_internal_subscribe_image() const {
  return _internal_has_subscribe_image()
      ? *payload_.subscribe_image_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::SubscribeImage*>(&::mw::internal::robotics::gazebotransport::_SubscribeImage_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::SubscribeImage& Packet::subscribe_image() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.subscribe_image)
  return _internal_subscribe_image();
}
inline ::mw::internal::robotics::gazebotransport::SubscribeImage* Packet::unsafe_arena_release_subscribe_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.subscribe_image)
  if (_internal_has_subscribe_image()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::SubscribeImage* temp = payload_.subscribe_image_;
    payload_.subscribe_image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_subscribe_image(::mw::internal::robotics::gazebotransport::SubscribeImage* subscribe_image) {
  clear_payload();
  if (subscribe_image) {
    set_has_subscribe_image();
    payload_.subscribe_image_ = subscribe_image;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.subscribe_image)
}
inline ::mw::internal::robotics::gazebotransport::SubscribeImage* Packet::_internal_mutable_subscribe_image() {
  if (!_internal_has_subscribe_image()) {
    clear_payload();
    set_has_subscribe_image();
    payload_.subscribe_image_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::SubscribeImage >(GetArena());
  }
  return payload_.subscribe_image_;
}
inline ::mw::internal::robotics::gazebotransport::SubscribeImage* Packet::mutable_subscribe_image() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.subscribe_image)
  return _internal_mutable_subscribe_image();
}

// .mw.internal.robotics.gazebotransport.SubscribeLaser subscribe_laser = 17;
inline bool Packet::_internal_has_subscribe_laser() const {
  return payload_case() == kSubscribeLaser;
}
inline bool Packet::has_subscribe_laser() const {
  return _internal_has_subscribe_laser();
}
inline void Packet::set_has_subscribe_laser() {
  _oneof_case_[0] = kSubscribeLaser;
}
inline void Packet::clear_subscribe_laser() {
  if (_internal_has_subscribe_laser()) {
    if (GetArena() == nullptr) {
      delete payload_.subscribe_laser_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::SubscribeLaser* Packet::release_subscribe_laser() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.subscribe_laser)
  if (_internal_has_subscribe_laser()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::SubscribeLaser* temp = payload_.subscribe_laser_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.subscribe_laser_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::SubscribeLaser& Packet::_internal_subscribe_laser() const {
  return _internal_has_subscribe_laser()
      ? *payload_.subscribe_laser_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::SubscribeLaser*>(&::mw::internal::robotics::gazebotransport::_SubscribeLaser_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::SubscribeLaser& Packet::subscribe_laser() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.subscribe_laser)
  return _internal_subscribe_laser();
}
inline ::mw::internal::robotics::gazebotransport::SubscribeLaser* Packet::unsafe_arena_release_subscribe_laser() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.subscribe_laser)
  if (_internal_has_subscribe_laser()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::SubscribeLaser* temp = payload_.subscribe_laser_;
    payload_.subscribe_laser_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_subscribe_laser(::mw::internal::robotics::gazebotransport::SubscribeLaser* subscribe_laser) {
  clear_payload();
  if (subscribe_laser) {
    set_has_subscribe_laser();
    payload_.subscribe_laser_ = subscribe_laser;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.subscribe_laser)
}
inline ::mw::internal::robotics::gazebotransport::SubscribeLaser* Packet::_internal_mutable_subscribe_laser() {
  if (!_internal_has_subscribe_laser()) {
    clear_payload();
    set_has_subscribe_laser();
    payload_.subscribe_laser_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::SubscribeLaser >(GetArena());
  }
  return payload_.subscribe_laser_;
}
inline ::mw::internal::robotics::gazebotransport::SubscribeLaser* Packet::mutable_subscribe_laser() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.subscribe_laser)
  return _internal_mutable_subscribe_laser();
}

// .mw.internal.robotics.gazebotransport.SubscribeImu subscribe_imu = 18;
inline bool Packet::_internal_has_subscribe_imu() const {
  return payload_case() == kSubscribeImu;
}
inline bool Packet::has_subscribe_imu() const {
  return _internal_has_subscribe_imu();
}
inline void Packet::set_has_subscribe_imu() {
  _oneof_case_[0] = kSubscribeImu;
}
inline void Packet::clear_subscribe_imu() {
  if (_internal_has_subscribe_imu()) {
    if (GetArena() == nullptr) {
      delete payload_.subscribe_imu_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::SubscribeImu* Packet::release_subscribe_imu() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.subscribe_imu)
  if (_internal_has_subscribe_imu()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::SubscribeImu* temp = payload_.subscribe_imu_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.subscribe_imu_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::SubscribeImu& Packet::_internal_subscribe_imu() const {
  return _internal_has_subscribe_imu()
      ? *payload_.subscribe_imu_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::SubscribeImu*>(&::mw::internal::robotics::gazebotransport::_SubscribeImu_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::SubscribeImu& Packet::subscribe_imu() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.subscribe_imu)
  return _internal_subscribe_imu();
}
inline ::mw::internal::robotics::gazebotransport::SubscribeImu* Packet::unsafe_arena_release_subscribe_imu() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.subscribe_imu)
  if (_internal_has_subscribe_imu()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::SubscribeImu* temp = payload_.subscribe_imu_;
    payload_.subscribe_imu_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_subscribe_imu(::mw::internal::robotics::gazebotransport::SubscribeImu* subscribe_imu) {
  clear_payload();
  if (subscribe_imu) {
    set_has_subscribe_imu();
    payload_.subscribe_imu_ = subscribe_imu;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.subscribe_imu)
}
inline ::mw::internal::robotics::gazebotransport::SubscribeImu* Packet::_internal_mutable_subscribe_imu() {
  if (!_internal_has_subscribe_imu()) {
    clear_payload();
    set_has_subscribe_imu();
    payload_.subscribe_imu_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::SubscribeImu >(GetArena());
  }
  return payload_.subscribe_imu_;
}
inline ::mw::internal::robotics::gazebotransport::SubscribeImu* Packet::mutable_subscribe_imu() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.subscribe_imu)
  return _internal_mutable_subscribe_imu();
}

// .mw.internal.robotics.gazebotransport.ApplyJointTorque apply_joint_torque = 19;
inline bool Packet::_internal_has_apply_joint_torque() const {
  return payload_case() == kApplyJointTorque;
}
inline bool Packet::has_apply_joint_torque() const {
  return _internal_has_apply_joint_torque();
}
inline void Packet::set_has_apply_joint_torque() {
  _oneof_case_[0] = kApplyJointTorque;
}
inline void Packet::clear_apply_joint_torque() {
  if (_internal_has_apply_joint_torque()) {
    if (GetArena() == nullptr) {
      delete payload_.apply_joint_torque_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::ApplyJointTorque* Packet::release_apply_joint_torque() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.apply_joint_torque)
  if (_internal_has_apply_joint_torque()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::ApplyJointTorque* temp = payload_.apply_joint_torque_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.apply_joint_torque_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::ApplyJointTorque& Packet::_internal_apply_joint_torque() const {
  return _internal_has_apply_joint_torque()
      ? *payload_.apply_joint_torque_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::ApplyJointTorque*>(&::mw::internal::robotics::gazebotransport::_ApplyJointTorque_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::ApplyJointTorque& Packet::apply_joint_torque() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.apply_joint_torque)
  return _internal_apply_joint_torque();
}
inline ::mw::internal::robotics::gazebotransport::ApplyJointTorque* Packet::unsafe_arena_release_apply_joint_torque() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.apply_joint_torque)
  if (_internal_has_apply_joint_torque()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::ApplyJointTorque* temp = payload_.apply_joint_torque_;
    payload_.apply_joint_torque_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_apply_joint_torque(::mw::internal::robotics::gazebotransport::ApplyJointTorque* apply_joint_torque) {
  clear_payload();
  if (apply_joint_torque) {
    set_has_apply_joint_torque();
    payload_.apply_joint_torque_ = apply_joint_torque;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.apply_joint_torque)
}
inline ::mw::internal::robotics::gazebotransport::ApplyJointTorque* Packet::_internal_mutable_apply_joint_torque() {
  if (!_internal_has_apply_joint_torque()) {
    clear_payload();
    set_has_apply_joint_torque();
    payload_.apply_joint_torque_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::ApplyJointTorque >(GetArena());
  }
  return payload_.apply_joint_torque_;
}
inline ::mw::internal::robotics::gazebotransport::ApplyJointTorque* Packet::mutable_apply_joint_torque() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.apply_joint_torque)
  return _internal_mutable_apply_joint_torque();
}

// .mw.internal.robotics.gazebotransport.GetPose get_pose = 20;
inline bool Packet::_internal_has_get_pose() const {
  return payload_case() == kGetPose;
}
inline bool Packet::has_get_pose() const {
  return _internal_has_get_pose();
}
inline void Packet::set_has_get_pose() {
  _oneof_case_[0] = kGetPose;
}
inline void Packet::clear_get_pose() {
  if (_internal_has_get_pose()) {
    if (GetArena() == nullptr) {
      delete payload_.get_pose_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::GetPose* Packet::release_get_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_pose)
  if (_internal_has_get_pose()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::GetPose* temp = payload_.get_pose_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.get_pose_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::GetPose& Packet::_internal_get_pose() const {
  return _internal_has_get_pose()
      ? *payload_.get_pose_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::GetPose*>(&::mw::internal::robotics::gazebotransport::_GetPose_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::GetPose& Packet::get_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_pose)
  return _internal_get_pose();
}
inline ::mw::internal::robotics::gazebotransport::GetPose* Packet::unsafe_arena_release_get_pose() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.get_pose)
  if (_internal_has_get_pose()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GetPose* temp = payload_.get_pose_;
    payload_.get_pose_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_get_pose(::mw::internal::robotics::gazebotransport::GetPose* get_pose) {
  clear_payload();
  if (get_pose) {
    set_has_get_pose();
    payload_.get_pose_ = get_pose;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_pose)
}
inline ::mw::internal::robotics::gazebotransport::GetPose* Packet::_internal_mutable_get_pose() {
  if (!_internal_has_get_pose()) {
    clear_payload();
    set_has_get_pose();
    payload_.get_pose_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::GetPose >(GetArena());
  }
  return payload_.get_pose_;
}
inline ::mw::internal::robotics::gazebotransport::GetPose* Packet::mutable_get_pose() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_pose)
  return _internal_mutable_get_pose();
}

// .mw.internal.robotics.gazebotransport.GetTopicList get_topic_list = 21;
inline bool Packet::_internal_has_get_topic_list() const {
  return payload_case() == kGetTopicList;
}
inline bool Packet::has_get_topic_list() const {
  return _internal_has_get_topic_list();
}
inline void Packet::set_has_get_topic_list() {
  _oneof_case_[0] = kGetTopicList;
}
inline void Packet::clear_get_topic_list() {
  if (_internal_has_get_topic_list()) {
    if (GetArena() == nullptr) {
      delete payload_.get_topic_list_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::GetTopicList* Packet::release_get_topic_list() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_topic_list)
  if (_internal_has_get_topic_list()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::GetTopicList* temp = payload_.get_topic_list_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.get_topic_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::GetTopicList& Packet::_internal_get_topic_list() const {
  return _internal_has_get_topic_list()
      ? *payload_.get_topic_list_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::GetTopicList*>(&::mw::internal::robotics::gazebotransport::_GetTopicList_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::GetTopicList& Packet::get_topic_list() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_topic_list)
  return _internal_get_topic_list();
}
inline ::mw::internal::robotics::gazebotransport::GetTopicList* Packet::unsafe_arena_release_get_topic_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.get_topic_list)
  if (_internal_has_get_topic_list()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GetTopicList* temp = payload_.get_topic_list_;
    payload_.get_topic_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_get_topic_list(::mw::internal::robotics::gazebotransport::GetTopicList* get_topic_list) {
  clear_payload();
  if (get_topic_list) {
    set_has_get_topic_list();
    payload_.get_topic_list_ = get_topic_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_topic_list)
}
inline ::mw::internal::robotics::gazebotransport::GetTopicList* Packet::_internal_mutable_get_topic_list() {
  if (!_internal_has_get_topic_list()) {
    clear_payload();
    set_has_get_topic_list();
    payload_.get_topic_list_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::GetTopicList >(GetArena());
  }
  return payload_.get_topic_list_;
}
inline ::mw::internal::robotics::gazebotransport::GetTopicList* Packet::mutable_get_topic_list() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_topic_list)
  return _internal_mutable_get_topic_list();
}

// .mw.internal.robotics.gazebotransport.TopicList topic_list = 22;
inline bool Packet::_internal_has_topic_list() const {
  return payload_case() == kTopicList;
}
inline bool Packet::has_topic_list() const {
  return _internal_has_topic_list();
}
inline void Packet::set_has_topic_list() {
  _oneof_case_[0] = kTopicList;
}
inline void Packet::clear_topic_list() {
  if (_internal_has_topic_list()) {
    if (GetArena() == nullptr) {
      delete payload_.topic_list_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::TopicList* Packet::release_topic_list() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.topic_list)
  if (_internal_has_topic_list()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::TopicList* temp = payload_.topic_list_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.topic_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::TopicList& Packet::_internal_topic_list() const {
  return _internal_has_topic_list()
      ? *payload_.topic_list_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::TopicList*>(&::mw::internal::robotics::gazebotransport::_TopicList_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::TopicList& Packet::topic_list() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.topic_list)
  return _internal_topic_list();
}
inline ::mw::internal::robotics::gazebotransport::TopicList* Packet::unsafe_arena_release_topic_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.topic_list)
  if (_internal_has_topic_list()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::TopicList* temp = payload_.topic_list_;
    payload_.topic_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_topic_list(::mw::internal::robotics::gazebotransport::TopicList* topic_list) {
  clear_payload();
  if (topic_list) {
    set_has_topic_list();
    payload_.topic_list_ = topic_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.topic_list)
}
inline ::mw::internal::robotics::gazebotransport::TopicList* Packet::_internal_mutable_topic_list() {
  if (!_internal_has_topic_list()) {
    clear_payload();
    set_has_topic_list();
    payload_.topic_list_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::TopicList >(GetArena());
  }
  return payload_.topic_list_;
}
inline ::mw::internal::robotics::gazebotransport::TopicList* Packet::mutable_topic_list() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.topic_list)
  return _internal_mutable_topic_list();
}

// .mw.internal.robotics.gazebotransport.GetModelInfo get_model_info = 23;
inline bool Packet::_internal_has_get_model_info() const {
  return payload_case() == kGetModelInfo;
}
inline bool Packet::has_get_model_info() const {
  return _internal_has_get_model_info();
}
inline void Packet::set_has_get_model_info() {
  _oneof_case_[0] = kGetModelInfo;
}
inline void Packet::clear_get_model_info() {
  if (_internal_has_get_model_info()) {
    if (GetArena() == nullptr) {
      delete payload_.get_model_info_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::GetModelInfo* Packet::release_get_model_info() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_model_info)
  if (_internal_has_get_model_info()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::GetModelInfo* temp = payload_.get_model_info_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.get_model_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::GetModelInfo& Packet::_internal_get_model_info() const {
  return _internal_has_get_model_info()
      ? *payload_.get_model_info_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::GetModelInfo*>(&::mw::internal::robotics::gazebotransport::_GetModelInfo_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::GetModelInfo& Packet::get_model_info() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_model_info)
  return _internal_get_model_info();
}
inline ::mw::internal::robotics::gazebotransport::GetModelInfo* Packet::unsafe_arena_release_get_model_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.get_model_info)
  if (_internal_has_get_model_info()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GetModelInfo* temp = payload_.get_model_info_;
    payload_.get_model_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_get_model_info(::mw::internal::robotics::gazebotransport::GetModelInfo* get_model_info) {
  clear_payload();
  if (get_model_info) {
    set_has_get_model_info();
    payload_.get_model_info_ = get_model_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_model_info)
}
inline ::mw::internal::robotics::gazebotransport::GetModelInfo* Packet::_internal_mutable_get_model_info() {
  if (!_internal_has_get_model_info()) {
    clear_payload();
    set_has_get_model_info();
    payload_.get_model_info_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::GetModelInfo >(GetArena());
  }
  return payload_.get_model_info_;
}
inline ::mw::internal::robotics::gazebotransport::GetModelInfo* Packet::mutable_get_model_info() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_model_info)
  return _internal_mutable_get_model_info();
}

// .mw.internal.robotics.gazebotransport.ModelInfo model_info = 24;
inline bool Packet::_internal_has_model_info() const {
  return payload_case() == kModelInfo;
}
inline bool Packet::has_model_info() const {
  return _internal_has_model_info();
}
inline void Packet::set_has_model_info() {
  _oneof_case_[0] = kModelInfo;
}
inline void Packet::clear_model_info() {
  if (_internal_has_model_info()) {
    if (GetArena() == nullptr) {
      delete payload_.model_info_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo* Packet::release_model_info() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.model_info)
  if (_internal_has_model_info()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::ModelInfo* temp = payload_.model_info_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.model_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::ModelInfo& Packet::_internal_model_info() const {
  return _internal_has_model_info()
      ? *payload_.model_info_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::ModelInfo*>(&::mw::internal::robotics::gazebotransport::_ModelInfo_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::ModelInfo& Packet::model_info() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.model_info)
  return _internal_model_info();
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo* Packet::unsafe_arena_release_model_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.model_info)
  if (_internal_has_model_info()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::ModelInfo* temp = payload_.model_info_;
    payload_.model_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_model_info(::mw::internal::robotics::gazebotransport::ModelInfo* model_info) {
  clear_payload();
  if (model_info) {
    set_has_model_info();
    payload_.model_info_ = model_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.model_info)
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo* Packet::_internal_mutable_model_info() {
  if (!_internal_has_model_info()) {
    clear_payload();
    set_has_model_info();
    payload_.model_info_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::ModelInfo >(GetArena());
  }
  return payload_.model_info_;
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo* Packet::mutable_model_info() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.model_info)
  return _internal_mutable_model_info();
}

// .mw.internal.robotics.gazebotransport.ApplyLinkWrench apply_link_wrench = 25;
inline bool Packet::_internal_has_apply_link_wrench() const {
  return payload_case() == kApplyLinkWrench;
}
inline bool Packet::has_apply_link_wrench() const {
  return _internal_has_apply_link_wrench();
}
inline void Packet::set_has_apply_link_wrench() {
  _oneof_case_[0] = kApplyLinkWrench;
}
inline void Packet::clear_apply_link_wrench() {
  if (_internal_has_apply_link_wrench()) {
    if (GetArena() == nullptr) {
      delete payload_.apply_link_wrench_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* Packet::release_apply_link_wrench() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.apply_link_wrench)
  if (_internal_has_apply_link_wrench()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* temp = payload_.apply_link_wrench_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.apply_link_wrench_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::ApplyLinkWrench& Packet::_internal_apply_link_wrench() const {
  return _internal_has_apply_link_wrench()
      ? *payload_.apply_link_wrench_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::ApplyLinkWrench*>(&::mw::internal::robotics::gazebotransport::_ApplyLinkWrench_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::ApplyLinkWrench& Packet::apply_link_wrench() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.apply_link_wrench)
  return _internal_apply_link_wrench();
}
inline ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* Packet::unsafe_arena_release_apply_link_wrench() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.apply_link_wrench)
  if (_internal_has_apply_link_wrench()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* temp = payload_.apply_link_wrench_;
    payload_.apply_link_wrench_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_apply_link_wrench(::mw::internal::robotics::gazebotransport::ApplyLinkWrench* apply_link_wrench) {
  clear_payload();
  if (apply_link_wrench) {
    set_has_apply_link_wrench();
    payload_.apply_link_wrench_ = apply_link_wrench;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.apply_link_wrench)
}
inline ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* Packet::_internal_mutable_apply_link_wrench() {
  if (!_internal_has_apply_link_wrench()) {
    clear_payload();
    set_has_apply_link_wrench();
    payload_.apply_link_wrench_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::ApplyLinkWrench >(GetArena());
  }
  return payload_.apply_link_wrench_;
}
inline ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* Packet::mutable_apply_link_wrench() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.apply_link_wrench)
  return _internal_mutable_apply_link_wrench();
}

// .mw.internal.robotics.gazebotransport.MaxStepSize max_step_size = 26;
inline bool Packet::_internal_has_max_step_size() const {
  return payload_case() == kMaxStepSize;
}
inline bool Packet::has_max_step_size() const {
  return _internal_has_max_step_size();
}
inline void Packet::set_has_max_step_size() {
  _oneof_case_[0] = kMaxStepSize;
}
inline void Packet::clear_max_step_size() {
  if (_internal_has_max_step_size()) {
    if (GetArena() == nullptr) {
      delete payload_.max_step_size_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::MaxStepSize* Packet::release_max_step_size() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.max_step_size)
  if (_internal_has_max_step_size()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::MaxStepSize* temp = payload_.max_step_size_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.max_step_size_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::MaxStepSize& Packet::_internal_max_step_size() const {
  return _internal_has_max_step_size()
      ? *payload_.max_step_size_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::MaxStepSize*>(&::mw::internal::robotics::gazebotransport::_MaxStepSize_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::MaxStepSize& Packet::max_step_size() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.max_step_size)
  return _internal_max_step_size();
}
inline ::mw::internal::robotics::gazebotransport::MaxStepSize* Packet::unsafe_arena_release_max_step_size() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.max_step_size)
  if (_internal_has_max_step_size()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::MaxStepSize* temp = payload_.max_step_size_;
    payload_.max_step_size_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_max_step_size(::mw::internal::robotics::gazebotransport::MaxStepSize* max_step_size) {
  clear_payload();
  if (max_step_size) {
    set_has_max_step_size();
    payload_.max_step_size_ = max_step_size;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.max_step_size)
}
inline ::mw::internal::robotics::gazebotransport::MaxStepSize* Packet::_internal_mutable_max_step_size() {
  if (!_internal_has_max_step_size()) {
    clear_payload();
    set_has_max_step_size();
    payload_.max_step_size_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::MaxStepSize >(GetArena());
  }
  return payload_.max_step_size_;
}
inline ::mw::internal::robotics::gazebotransport::MaxStepSize* Packet::mutable_max_step_size() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.max_step_size)
  return _internal_mutable_max_step_size();
}

// .mw.internal.robotics.gazebotransport.CustomMessageSupport custom_message_support = 27;
inline bool Packet::_internal_has_custom_message_support() const {
  return payload_case() == kCustomMessageSupport;
}
inline bool Packet::has_custom_message_support() const {
  return _internal_has_custom_message_support();
}
inline void Packet::set_has_custom_message_support() {
  _oneof_case_[0] = kCustomMessageSupport;
}
inline void Packet::clear_custom_message_support() {
  if (_internal_has_custom_message_support()) {
    if (GetArena() == nullptr) {
      delete payload_.custom_message_support_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::CustomMessageSupport* Packet::release_custom_message_support() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.custom_message_support)
  if (_internal_has_custom_message_support()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::CustomMessageSupport* temp = payload_.custom_message_support_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.custom_message_support_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::CustomMessageSupport& Packet::_internal_custom_message_support() const {
  return _internal_has_custom_message_support()
      ? *payload_.custom_message_support_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::CustomMessageSupport*>(&::mw::internal::robotics::gazebotransport::_CustomMessageSupport_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::CustomMessageSupport& Packet::custom_message_support() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.custom_message_support)
  return _internal_custom_message_support();
}
inline ::mw::internal::robotics::gazebotransport::CustomMessageSupport* Packet::unsafe_arena_release_custom_message_support() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.custom_message_support)
  if (_internal_has_custom_message_support()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::CustomMessageSupport* temp = payload_.custom_message_support_;
    payload_.custom_message_support_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_custom_message_support(::mw::internal::robotics::gazebotransport::CustomMessageSupport* custom_message_support) {
  clear_payload();
  if (custom_message_support) {
    set_has_custom_message_support();
    payload_.custom_message_support_ = custom_message_support;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.custom_message_support)
}
inline ::mw::internal::robotics::gazebotransport::CustomMessageSupport* Packet::_internal_mutable_custom_message_support() {
  if (!_internal_has_custom_message_support()) {
    clear_payload();
    set_has_custom_message_support();
    payload_.custom_message_support_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::CustomMessageSupport >(GetArena());
  }
  return payload_.custom_message_support_;
}
inline ::mw::internal::robotics::gazebotransport::CustomMessageSupport* Packet::mutable_custom_message_support() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.custom_message_support)
  return _internal_mutable_custom_message_support();
}

// .mw.internal.robotics.gazebotransport.InitCustomPublisher init_custom_publisher = 28;
inline bool Packet::_internal_has_init_custom_publisher() const {
  return payload_case() == kInitCustomPublisher;
}
inline bool Packet::has_init_custom_publisher() const {
  return _internal_has_init_custom_publisher();
}
inline void Packet::set_has_init_custom_publisher() {
  _oneof_case_[0] = kInitCustomPublisher;
}
inline void Packet::clear_init_custom_publisher() {
  if (_internal_has_init_custom_publisher()) {
    if (GetArena() == nullptr) {
      delete payload_.init_custom_publisher_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::InitCustomPublisher* Packet::release_init_custom_publisher() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.init_custom_publisher)
  if (_internal_has_init_custom_publisher()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::InitCustomPublisher* temp = payload_.init_custom_publisher_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.init_custom_publisher_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::InitCustomPublisher& Packet::_internal_init_custom_publisher() const {
  return _internal_has_init_custom_publisher()
      ? *payload_.init_custom_publisher_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::InitCustomPublisher*>(&::mw::internal::robotics::gazebotransport::_InitCustomPublisher_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::InitCustomPublisher& Packet::init_custom_publisher() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.init_custom_publisher)
  return _internal_init_custom_publisher();
}
inline ::mw::internal::robotics::gazebotransport::InitCustomPublisher* Packet::unsafe_arena_release_init_custom_publisher() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.init_custom_publisher)
  if (_internal_has_init_custom_publisher()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::InitCustomPublisher* temp = payload_.init_custom_publisher_;
    payload_.init_custom_publisher_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_init_custom_publisher(::mw::internal::robotics::gazebotransport::InitCustomPublisher* init_custom_publisher) {
  clear_payload();
  if (init_custom_publisher) {
    set_has_init_custom_publisher();
    payload_.init_custom_publisher_ = init_custom_publisher;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.init_custom_publisher)
}
inline ::mw::internal::robotics::gazebotransport::InitCustomPublisher* Packet::_internal_mutable_init_custom_publisher() {
  if (!_internal_has_init_custom_publisher()) {
    clear_payload();
    set_has_init_custom_publisher();
    payload_.init_custom_publisher_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::InitCustomPublisher >(GetArena());
  }
  return payload_.init_custom_publisher_;
}
inline ::mw::internal::robotics::gazebotransport::InitCustomPublisher* Packet::mutable_init_custom_publisher() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.init_custom_publisher)
  return _internal_mutable_init_custom_publisher();
}

// .mw.internal.robotics.gazebotransport.InitCustomSubscriber init_custom_subscriber = 29;
inline bool Packet::_internal_has_init_custom_subscriber() const {
  return payload_case() == kInitCustomSubscriber;
}
inline bool Packet::has_init_custom_subscriber() const {
  return _internal_has_init_custom_subscriber();
}
inline void Packet::set_has_init_custom_subscriber() {
  _oneof_case_[0] = kInitCustomSubscriber;
}
inline void Packet::clear_init_custom_subscriber() {
  if (_internal_has_init_custom_subscriber()) {
    if (GetArena() == nullptr) {
      delete payload_.init_custom_subscriber_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* Packet::release_init_custom_subscriber() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.init_custom_subscriber)
  if (_internal_has_init_custom_subscriber()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* temp = payload_.init_custom_subscriber_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.init_custom_subscriber_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::InitCustomSubscriber& Packet::_internal_init_custom_subscriber() const {
  return _internal_has_init_custom_subscriber()
      ? *payload_.init_custom_subscriber_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::InitCustomSubscriber*>(&::mw::internal::robotics::gazebotransport::_InitCustomSubscriber_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::InitCustomSubscriber& Packet::init_custom_subscriber() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.init_custom_subscriber)
  return _internal_init_custom_subscriber();
}
inline ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* Packet::unsafe_arena_release_init_custom_subscriber() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.init_custom_subscriber)
  if (_internal_has_init_custom_subscriber()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* temp = payload_.init_custom_subscriber_;
    payload_.init_custom_subscriber_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_init_custom_subscriber(::mw::internal::robotics::gazebotransport::InitCustomSubscriber* init_custom_subscriber) {
  clear_payload();
  if (init_custom_subscriber) {
    set_has_init_custom_subscriber();
    payload_.init_custom_subscriber_ = init_custom_subscriber;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.init_custom_subscriber)
}
inline ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* Packet::_internal_mutable_init_custom_subscriber() {
  if (!_internal_has_init_custom_subscriber()) {
    clear_payload();
    set_has_init_custom_subscriber();
    payload_.init_custom_subscriber_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::InitCustomSubscriber >(GetArena());
  }
  return payload_.init_custom_subscriber_;
}
inline ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* Packet::mutable_init_custom_subscriber() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.init_custom_subscriber)
  return _internal_mutable_init_custom_subscriber();
}

// .mw.internal.robotics.gazebotransport.RequestCustomMessageSupport request_custom_message_support = 30;
inline bool Packet::_internal_has_request_custom_message_support() const {
  return payload_case() == kRequestCustomMessageSupport;
}
inline bool Packet::has_request_custom_message_support() const {
  return _internal_has_request_custom_message_support();
}
inline void Packet::set_has_request_custom_message_support() {
  _oneof_case_[0] = kRequestCustomMessageSupport;
}
inline void Packet::clear_request_custom_message_support() {
  if (_internal_has_request_custom_message_support()) {
    if (GetArena() == nullptr) {
      delete payload_.request_custom_message_support_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* Packet::release_request_custom_message_support() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.request_custom_message_support)
  if (_internal_has_request_custom_message_support()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* temp = payload_.request_custom_message_support_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.request_custom_message_support_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport& Packet::_internal_request_custom_message_support() const {
  return _internal_has_request_custom_message_support()
      ? *payload_.request_custom_message_support_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport*>(&::mw::internal::robotics::gazebotransport::_RequestCustomMessageSupport_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport& Packet::request_custom_message_support() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.request_custom_message_support)
  return _internal_request_custom_message_support();
}
inline ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* Packet::unsafe_arena_release_request_custom_message_support() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.request_custom_message_support)
  if (_internal_has_request_custom_message_support()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* temp = payload_.request_custom_message_support_;
    payload_.request_custom_message_support_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_request_custom_message_support(::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* request_custom_message_support) {
  clear_payload();
  if (request_custom_message_support) {
    set_has_request_custom_message_support();
    payload_.request_custom_message_support_ = request_custom_message_support;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.request_custom_message_support)
}
inline ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* Packet::_internal_mutable_request_custom_message_support() {
  if (!_internal_has_request_custom_message_support()) {
    clear_payload();
    set_has_request_custom_message_support();
    payload_.request_custom_message_support_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport >(GetArena());
  }
  return payload_.request_custom_message_support_;
}
inline ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* Packet::mutable_request_custom_message_support() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.request_custom_message_support)
  return _internal_mutable_request_custom_message_support();
}

// .mw.internal.robotics.gazebotransport.SetJointPosition set_joint_position = 31;
inline bool Packet::_internal_has_set_joint_position() const {
  return payload_case() == kSetJointPosition;
}
inline bool Packet::has_set_joint_position() const {
  return _internal_has_set_joint_position();
}
inline void Packet::set_has_set_joint_position() {
  _oneof_case_[0] = kSetJointPosition;
}
inline void Packet::clear_set_joint_position() {
  if (_internal_has_set_joint_position()) {
    if (GetArena() == nullptr) {
      delete payload_.set_joint_position_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::SetJointPosition* Packet::release_set_joint_position() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.set_joint_position)
  if (_internal_has_set_joint_position()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::SetJointPosition* temp = payload_.set_joint_position_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.set_joint_position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::SetJointPosition& Packet::_internal_set_joint_position() const {
  return _internal_has_set_joint_position()
      ? *payload_.set_joint_position_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::SetJointPosition*>(&::mw::internal::robotics::gazebotransport::_SetJointPosition_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::SetJointPosition& Packet::set_joint_position() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.set_joint_position)
  return _internal_set_joint_position();
}
inline ::mw::internal::robotics::gazebotransport::SetJointPosition* Packet::unsafe_arena_release_set_joint_position() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.set_joint_position)
  if (_internal_has_set_joint_position()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::SetJointPosition* temp = payload_.set_joint_position_;
    payload_.set_joint_position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_set_joint_position(::mw::internal::robotics::gazebotransport::SetJointPosition* set_joint_position) {
  clear_payload();
  if (set_joint_position) {
    set_has_set_joint_position();
    payload_.set_joint_position_ = set_joint_position;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.set_joint_position)
}
inline ::mw::internal::robotics::gazebotransport::SetJointPosition* Packet::_internal_mutable_set_joint_position() {
  if (!_internal_has_set_joint_position()) {
    clear_payload();
    set_has_set_joint_position();
    payload_.set_joint_position_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::SetJointPosition >(GetArena());
  }
  return payload_.set_joint_position_;
}
inline ::mw::internal::robotics::gazebotransport::SetJointPosition* Packet::mutable_set_joint_position() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.set_joint_position)
  return _internal_mutable_set_joint_position();
}

// .mw.internal.robotics.gazebotransport.SetJointVelocity set_joint_velocity = 32;
inline bool Packet::_internal_has_set_joint_velocity() const {
  return payload_case() == kSetJointVelocity;
}
inline bool Packet::has_set_joint_velocity() const {
  return _internal_has_set_joint_velocity();
}
inline void Packet::set_has_set_joint_velocity() {
  _oneof_case_[0] = kSetJointVelocity;
}
inline void Packet::clear_set_joint_velocity() {
  if (_internal_has_set_joint_velocity()) {
    if (GetArena() == nullptr) {
      delete payload_.set_joint_velocity_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::SetJointVelocity* Packet::release_set_joint_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.set_joint_velocity)
  if (_internal_has_set_joint_velocity()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::SetJointVelocity* temp = payload_.set_joint_velocity_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.set_joint_velocity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::SetJointVelocity& Packet::_internal_set_joint_velocity() const {
  return _internal_has_set_joint_velocity()
      ? *payload_.set_joint_velocity_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::SetJointVelocity*>(&::mw::internal::robotics::gazebotransport::_SetJointVelocity_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::SetJointVelocity& Packet::set_joint_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.set_joint_velocity)
  return _internal_set_joint_velocity();
}
inline ::mw::internal::robotics::gazebotransport::SetJointVelocity* Packet::unsafe_arena_release_set_joint_velocity() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.set_joint_velocity)
  if (_internal_has_set_joint_velocity()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::SetJointVelocity* temp = payload_.set_joint_velocity_;
    payload_.set_joint_velocity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_set_joint_velocity(::mw::internal::robotics::gazebotransport::SetJointVelocity* set_joint_velocity) {
  clear_payload();
  if (set_joint_velocity) {
    set_has_set_joint_velocity();
    payload_.set_joint_velocity_ = set_joint_velocity;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.set_joint_velocity)
}
inline ::mw::internal::robotics::gazebotransport::SetJointVelocity* Packet::_internal_mutable_set_joint_velocity() {
  if (!_internal_has_set_joint_velocity()) {
    clear_payload();
    set_has_set_joint_velocity();
    payload_.set_joint_velocity_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::SetJointVelocity >(GetArena());
  }
  return payload_.set_joint_velocity_;
}
inline ::mw::internal::robotics::gazebotransport::SetJointVelocity* Packet::mutable_set_joint_velocity() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.set_joint_velocity)
  return _internal_mutable_set_joint_velocity();
}

// .mw.internal.robotics.gazebotransport.GetJointState get_joint_state = 33;
inline bool Packet::_internal_has_get_joint_state() const {
  return payload_case() == kGetJointState;
}
inline bool Packet::has_get_joint_state() const {
  return _internal_has_get_joint_state();
}
inline void Packet::set_has_get_joint_state() {
  _oneof_case_[0] = kGetJointState;
}
inline void Packet::clear_get_joint_state() {
  if (_internal_has_get_joint_state()) {
    if (GetArena() == nullptr) {
      delete payload_.get_joint_state_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::GetJointState* Packet::release_get_joint_state() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_joint_state)
  if (_internal_has_get_joint_state()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::GetJointState* temp = payload_.get_joint_state_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.get_joint_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::GetJointState& Packet::_internal_get_joint_state() const {
  return _internal_has_get_joint_state()
      ? *payload_.get_joint_state_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::GetJointState*>(&::mw::internal::robotics::gazebotransport::_GetJointState_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::GetJointState& Packet::get_joint_state() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_joint_state)
  return _internal_get_joint_state();
}
inline ::mw::internal::robotics::gazebotransport::GetJointState* Packet::unsafe_arena_release_get_joint_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.get_joint_state)
  if (_internal_has_get_joint_state()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GetJointState* temp = payload_.get_joint_state_;
    payload_.get_joint_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_get_joint_state(::mw::internal::robotics::gazebotransport::GetJointState* get_joint_state) {
  clear_payload();
  if (get_joint_state) {
    set_has_get_joint_state();
    payload_.get_joint_state_ = get_joint_state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_joint_state)
}
inline ::mw::internal::robotics::gazebotransport::GetJointState* Packet::_internal_mutable_get_joint_state() {
  if (!_internal_has_get_joint_state()) {
    clear_payload();
    set_has_get_joint_state();
    payload_.get_joint_state_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::GetJointState >(GetArena());
  }
  return payload_.get_joint_state_;
}
inline ::mw::internal::robotics::gazebotransport::GetJointState* Packet::mutable_get_joint_state() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_joint_state)
  return _internal_mutable_get_joint_state();
}

// .mw.internal.robotics.gazebotransport.JointState joint_state = 34;
inline bool Packet::_internal_has_joint_state() const {
  return payload_case() == kJointState;
}
inline bool Packet::has_joint_state() const {
  return _internal_has_joint_state();
}
inline void Packet::set_has_joint_state() {
  _oneof_case_[0] = kJointState;
}
inline void Packet::clear_joint_state() {
  if (_internal_has_joint_state()) {
    if (GetArena() == nullptr) {
      delete payload_.joint_state_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::JointState* Packet::release_joint_state() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.joint_state)
  if (_internal_has_joint_state()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::JointState* temp = payload_.joint_state_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.joint_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::JointState& Packet::_internal_joint_state() const {
  return _internal_has_joint_state()
      ? *payload_.joint_state_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::JointState*>(&::mw::internal::robotics::gazebotransport::_JointState_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::JointState& Packet::joint_state() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.joint_state)
  return _internal_joint_state();
}
inline ::mw::internal::robotics::gazebotransport::JointState* Packet::unsafe_arena_release_joint_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.joint_state)
  if (_internal_has_joint_state()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::JointState* temp = payload_.joint_state_;
    payload_.joint_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_joint_state(::mw::internal::robotics::gazebotransport::JointState* joint_state) {
  clear_payload();
  if (joint_state) {
    set_has_joint_state();
    payload_.joint_state_ = joint_state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.joint_state)
}
inline ::mw::internal::robotics::gazebotransport::JointState* Packet::_internal_mutable_joint_state() {
  if (!_internal_has_joint_state()) {
    clear_payload();
    set_has_joint_state();
    payload_.joint_state_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::JointState >(GetArena());
  }
  return payload_.joint_state_;
}
inline ::mw::internal::robotics::gazebotransport::JointState* Packet::mutable_joint_state() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.joint_state)
  return _internal_mutable_joint_state();
}

// .mw.internal.robotics.gazebotransport.SetLinkWorldPose set_link_world_pose = 35;
inline bool Packet::_internal_has_set_link_world_pose() const {
  return payload_case() == kSetLinkWorldPose;
}
inline bool Packet::has_set_link_world_pose() const {
  return _internal_has_set_link_world_pose();
}
inline void Packet::set_has_set_link_world_pose() {
  _oneof_case_[0] = kSetLinkWorldPose;
}
inline void Packet::clear_set_link_world_pose() {
  if (_internal_has_set_link_world_pose()) {
    if (GetArena() == nullptr) {
      delete payload_.set_link_world_pose_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* Packet::release_set_link_world_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.set_link_world_pose)
  if (_internal_has_set_link_world_pose()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* temp = payload_.set_link_world_pose_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.set_link_world_pose_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::SetLinkWorldPose& Packet::_internal_set_link_world_pose() const {
  return _internal_has_set_link_world_pose()
      ? *payload_.set_link_world_pose_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::SetLinkWorldPose*>(&::mw::internal::robotics::gazebotransport::_SetLinkWorldPose_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::SetLinkWorldPose& Packet::set_link_world_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.set_link_world_pose)
  return _internal_set_link_world_pose();
}
inline ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* Packet::unsafe_arena_release_set_link_world_pose() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.set_link_world_pose)
  if (_internal_has_set_link_world_pose()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* temp = payload_.set_link_world_pose_;
    payload_.set_link_world_pose_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_set_link_world_pose(::mw::internal::robotics::gazebotransport::SetLinkWorldPose* set_link_world_pose) {
  clear_payload();
  if (set_link_world_pose) {
    set_has_set_link_world_pose();
    payload_.set_link_world_pose_ = set_link_world_pose;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.set_link_world_pose)
}
inline ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* Packet::_internal_mutable_set_link_world_pose() {
  if (!_internal_has_set_link_world_pose()) {
    clear_payload();
    set_has_set_link_world_pose();
    payload_.set_link_world_pose_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::SetLinkWorldPose >(GetArena());
  }
  return payload_.set_link_world_pose_;
}
inline ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* Packet::mutable_set_link_world_pose() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.set_link_world_pose)
  return _internal_mutable_set_link_world_pose();
}

// .mw.internal.robotics.gazebotransport.SetLinkLinearVelocity set_link_linear_velocity = 36;
inline bool Packet::_internal_has_set_link_linear_velocity() const {
  return payload_case() == kSetLinkLinearVelocity;
}
inline bool Packet::has_set_link_linear_velocity() const {
  return _internal_has_set_link_linear_velocity();
}
inline void Packet::set_has_set_link_linear_velocity() {
  _oneof_case_[0] = kSetLinkLinearVelocity;
}
inline void Packet::clear_set_link_linear_velocity() {
  if (_internal_has_set_link_linear_velocity()) {
    if (GetArena() == nullptr) {
      delete payload_.set_link_linear_velocity_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* Packet::release_set_link_linear_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.set_link_linear_velocity)
  if (_internal_has_set_link_linear_velocity()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* temp = payload_.set_link_linear_velocity_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.set_link_linear_velocity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity& Packet::_internal_set_link_linear_velocity() const {
  return _internal_has_set_link_linear_velocity()
      ? *payload_.set_link_linear_velocity_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity*>(&::mw::internal::robotics::gazebotransport::_SetLinkLinearVelocity_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity& Packet::set_link_linear_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.set_link_linear_velocity)
  return _internal_set_link_linear_velocity();
}
inline ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* Packet::unsafe_arena_release_set_link_linear_velocity() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.set_link_linear_velocity)
  if (_internal_has_set_link_linear_velocity()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* temp = payload_.set_link_linear_velocity_;
    payload_.set_link_linear_velocity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_set_link_linear_velocity(::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* set_link_linear_velocity) {
  clear_payload();
  if (set_link_linear_velocity) {
    set_has_set_link_linear_velocity();
    payload_.set_link_linear_velocity_ = set_link_linear_velocity;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.set_link_linear_velocity)
}
inline ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* Packet::_internal_mutable_set_link_linear_velocity() {
  if (!_internal_has_set_link_linear_velocity()) {
    clear_payload();
    set_has_set_link_linear_velocity();
    payload_.set_link_linear_velocity_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity >(GetArena());
  }
  return payload_.set_link_linear_velocity_;
}
inline ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* Packet::mutable_set_link_linear_velocity() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.set_link_linear_velocity)
  return _internal_mutable_set_link_linear_velocity();
}

// .mw.internal.robotics.gazebotransport.SetLinkAngularVelocity set_link_angular_velocity = 37;
inline bool Packet::_internal_has_set_link_angular_velocity() const {
  return payload_case() == kSetLinkAngularVelocity;
}
inline bool Packet::has_set_link_angular_velocity() const {
  return _internal_has_set_link_angular_velocity();
}
inline void Packet::set_has_set_link_angular_velocity() {
  _oneof_case_[0] = kSetLinkAngularVelocity;
}
inline void Packet::clear_set_link_angular_velocity() {
  if (_internal_has_set_link_angular_velocity()) {
    if (GetArena() == nullptr) {
      delete payload_.set_link_angular_velocity_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* Packet::release_set_link_angular_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.set_link_angular_velocity)
  if (_internal_has_set_link_angular_velocity()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* temp = payload_.set_link_angular_velocity_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.set_link_angular_velocity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity& Packet::_internal_set_link_angular_velocity() const {
  return _internal_has_set_link_angular_velocity()
      ? *payload_.set_link_angular_velocity_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity*>(&::mw::internal::robotics::gazebotransport::_SetLinkAngularVelocity_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity& Packet::set_link_angular_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.set_link_angular_velocity)
  return _internal_set_link_angular_velocity();
}
inline ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* Packet::unsafe_arena_release_set_link_angular_velocity() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.set_link_angular_velocity)
  if (_internal_has_set_link_angular_velocity()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* temp = payload_.set_link_angular_velocity_;
    payload_.set_link_angular_velocity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_set_link_angular_velocity(::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* set_link_angular_velocity) {
  clear_payload();
  if (set_link_angular_velocity) {
    set_has_set_link_angular_velocity();
    payload_.set_link_angular_velocity_ = set_link_angular_velocity;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.set_link_angular_velocity)
}
inline ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* Packet::_internal_mutable_set_link_angular_velocity() {
  if (!_internal_has_set_link_angular_velocity()) {
    clear_payload();
    set_has_set_link_angular_velocity();
    payload_.set_link_angular_velocity_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity >(GetArena());
  }
  return payload_.set_link_angular_velocity_;
}
inline ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* Packet::mutable_set_link_angular_velocity() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.set_link_angular_velocity)
  return _internal_mutable_set_link_angular_velocity();
}

// .mw.internal.robotics.gazebotransport.GetLinkState get_link_state = 38;
inline bool Packet::_internal_has_get_link_state() const {
  return payload_case() == kGetLinkState;
}
inline bool Packet::has_get_link_state() const {
  return _internal_has_get_link_state();
}
inline void Packet::set_has_get_link_state() {
  _oneof_case_[0] = kGetLinkState;
}
inline void Packet::clear_get_link_state() {
  if (_internal_has_get_link_state()) {
    if (GetArena() == nullptr) {
      delete payload_.get_link_state_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::GetLinkState* Packet::release_get_link_state() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_link_state)
  if (_internal_has_get_link_state()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::GetLinkState* temp = payload_.get_link_state_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.get_link_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::GetLinkState& Packet::_internal_get_link_state() const {
  return _internal_has_get_link_state()
      ? *payload_.get_link_state_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::GetLinkState*>(&::mw::internal::robotics::gazebotransport::_GetLinkState_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::GetLinkState& Packet::get_link_state() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_link_state)
  return _internal_get_link_state();
}
inline ::mw::internal::robotics::gazebotransport::GetLinkState* Packet::unsafe_arena_release_get_link_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.get_link_state)
  if (_internal_has_get_link_state()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GetLinkState* temp = payload_.get_link_state_;
    payload_.get_link_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_get_link_state(::mw::internal::robotics::gazebotransport::GetLinkState* get_link_state) {
  clear_payload();
  if (get_link_state) {
    set_has_get_link_state();
    payload_.get_link_state_ = get_link_state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_link_state)
}
inline ::mw::internal::robotics::gazebotransport::GetLinkState* Packet::_internal_mutable_get_link_state() {
  if (!_internal_has_get_link_state()) {
    clear_payload();
    set_has_get_link_state();
    payload_.get_link_state_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::GetLinkState >(GetArena());
  }
  return payload_.get_link_state_;
}
inline ::mw::internal::robotics::gazebotransport::GetLinkState* Packet::mutable_get_link_state() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_link_state)
  return _internal_mutable_get_link_state();
}

// .mw.internal.robotics.gazebotransport.LinkState link_state = 39;
inline bool Packet::_internal_has_link_state() const {
  return payload_case() == kLinkState;
}
inline bool Packet::has_link_state() const {
  return _internal_has_link_state();
}
inline void Packet::set_has_link_state() {
  _oneof_case_[0] = kLinkState;
}
inline void Packet::clear_link_state() {
  if (_internal_has_link_state()) {
    if (GetArena() == nullptr) {
      delete payload_.link_state_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::LinkState* Packet::release_link_state() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.link_state)
  if (_internal_has_link_state()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::LinkState* temp = payload_.link_state_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.link_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::LinkState& Packet::_internal_link_state() const {
  return _internal_has_link_state()
      ? *payload_.link_state_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::LinkState*>(&::mw::internal::robotics::gazebotransport::_LinkState_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::LinkState& Packet::link_state() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.link_state)
  return _internal_link_state();
}
inline ::mw::internal::robotics::gazebotransport::LinkState* Packet::unsafe_arena_release_link_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.link_state)
  if (_internal_has_link_state()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::LinkState* temp = payload_.link_state_;
    payload_.link_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_link_state(::mw::internal::robotics::gazebotransport::LinkState* link_state) {
  clear_payload();
  if (link_state) {
    set_has_link_state();
    payload_.link_state_ = link_state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.link_state)
}
inline ::mw::internal::robotics::gazebotransport::LinkState* Packet::_internal_mutable_link_state() {
  if (!_internal_has_link_state()) {
    clear_payload();
    set_has_link_state();
    payload_.link_state_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::LinkState >(GetArena());
  }
  return payload_.link_state_;
}
inline ::mw::internal::robotics::gazebotransport::LinkState* Packet::mutable_link_state() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.link_state)
  return _internal_mutable_link_state();
}

// .mw.internal.robotics.gazebotransport.Gazebomodel gazebo_model = 40;
inline bool Packet::_internal_has_gazebo_model() const {
  return payload_case() == kGazeboModel;
}
inline bool Packet::has_gazebo_model() const {
  return _internal_has_gazebo_model();
}
inline void Packet::set_has_gazebo_model() {
  _oneof_case_[0] = kGazeboModel;
}
inline void Packet::clear_gazebo_model() {
  if (_internal_has_gazebo_model()) {
    if (GetArena() == nullptr) {
      delete payload_.gazebo_model_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::Gazebomodel* Packet::release_gazebo_model() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.gazebo_model)
  if (_internal_has_gazebo_model()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::Gazebomodel* temp = payload_.gazebo_model_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.gazebo_model_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::Gazebomodel& Packet::_internal_gazebo_model() const {
  return _internal_has_gazebo_model()
      ? *payload_.gazebo_model_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::Gazebomodel*>(&::mw::internal::robotics::gazebotransport::_Gazebomodel_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Gazebomodel& Packet::gazebo_model() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.gazebo_model)
  return _internal_gazebo_model();
}
inline ::mw::internal::robotics::gazebotransport::Gazebomodel* Packet::unsafe_arena_release_gazebo_model() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.gazebo_model)
  if (_internal_has_gazebo_model()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::Gazebomodel* temp = payload_.gazebo_model_;
    payload_.gazebo_model_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_gazebo_model(::mw::internal::robotics::gazebotransport::Gazebomodel* gazebo_model) {
  clear_payload();
  if (gazebo_model) {
    set_has_gazebo_model();
    payload_.gazebo_model_ = gazebo_model;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.gazebo_model)
}
inline ::mw::internal::robotics::gazebotransport::Gazebomodel* Packet::_internal_mutable_gazebo_model() {
  if (!_internal_has_gazebo_model()) {
    clear_payload();
    set_has_gazebo_model();
    payload_.gazebo_model_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::Gazebomodel >(GetArena());
  }
  return payload_.gazebo_model_;
}
inline ::mw::internal::robotics::gazebotransport::Gazebomodel* Packet::mutable_gazebo_model() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.gazebo_model)
  return _internal_mutable_gazebo_model();
}

// .mw.internal.robotics.gazebotransport.GetGazeboModelParam get_gazebo_model_param = 41;
inline bool Packet::_internal_has_get_gazebo_model_param() const {
  return payload_case() == kGetGazeboModelParam;
}
inline bool Packet::has_get_gazebo_model_param() const {
  return _internal_has_get_gazebo_model_param();
}
inline void Packet::set_has_get_gazebo_model_param() {
  _oneof_case_[0] = kGetGazeboModelParam;
}
inline void Packet::clear_get_gazebo_model_param() {
  if (_internal_has_get_gazebo_model_param()) {
    if (GetArena() == nullptr) {
      delete payload_.get_gazebo_model_param_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::GetGazeboModelParam* Packet::release_get_gazebo_model_param() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_param)
  if (_internal_has_get_gazebo_model_param()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::GetGazeboModelParam* temp = payload_.get_gazebo_model_param_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.get_gazebo_model_param_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::GetGazeboModelParam& Packet::_internal_get_gazebo_model_param() const {
  return _internal_has_get_gazebo_model_param()
      ? *payload_.get_gazebo_model_param_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::GetGazeboModelParam*>(&::mw::internal::robotics::gazebotransport::_GetGazeboModelParam_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::GetGazeboModelParam& Packet::get_gazebo_model_param() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_param)
  return _internal_get_gazebo_model_param();
}
inline ::mw::internal::robotics::gazebotransport::GetGazeboModelParam* Packet::unsafe_arena_release_get_gazebo_model_param() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_param)
  if (_internal_has_get_gazebo_model_param()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GetGazeboModelParam* temp = payload_.get_gazebo_model_param_;
    payload_.get_gazebo_model_param_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_get_gazebo_model_param(::mw::internal::robotics::gazebotransport::GetGazeboModelParam* get_gazebo_model_param) {
  clear_payload();
  if (get_gazebo_model_param) {
    set_has_get_gazebo_model_param();
    payload_.get_gazebo_model_param_ = get_gazebo_model_param;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_param)
}
inline ::mw::internal::robotics::gazebotransport::GetGazeboModelParam* Packet::_internal_mutable_get_gazebo_model_param() {
  if (!_internal_has_get_gazebo_model_param()) {
    clear_payload();
    set_has_get_gazebo_model_param();
    payload_.get_gazebo_model_param_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::GetGazeboModelParam >(GetArena());
  }
  return payload_.get_gazebo_model_param_;
}
inline ::mw::internal::robotics::gazebotransport::GetGazeboModelParam* Packet::mutable_get_gazebo_model_param() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_param)
  return _internal_mutable_get_gazebo_model_param();
}

// .mw.internal.robotics.gazebotransport.GazeboModelSDF gazebo_model_sdf = 42;
inline bool Packet::_internal_has_gazebo_model_sdf() const {
  return payload_case() == kGazeboModelSdf;
}
inline bool Packet::has_gazebo_model_sdf() const {
  return _internal_has_gazebo_model_sdf();
}
inline void Packet::set_has_gazebo_model_sdf() {
  _oneof_case_[0] = kGazeboModelSdf;
}
inline void Packet::clear_gazebo_model_sdf() {
  if (_internal_has_gazebo_model_sdf()) {
    if (GetArena() == nullptr) {
      delete payload_.gazebo_model_sdf_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::GazeboModelSDF* Packet::release_gazebo_model_sdf() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.gazebo_model_sdf)
  if (_internal_has_gazebo_model_sdf()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::GazeboModelSDF* temp = payload_.gazebo_model_sdf_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.gazebo_model_sdf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::GazeboModelSDF& Packet::_internal_gazebo_model_sdf() const {
  return _internal_has_gazebo_model_sdf()
      ? *payload_.gazebo_model_sdf_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::GazeboModelSDF*>(&::mw::internal::robotics::gazebotransport::_GazeboModelSDF_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::GazeboModelSDF& Packet::gazebo_model_sdf() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.gazebo_model_sdf)
  return _internal_gazebo_model_sdf();
}
inline ::mw::internal::robotics::gazebotransport::GazeboModelSDF* Packet::unsafe_arena_release_gazebo_model_sdf() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.gazebo_model_sdf)
  if (_internal_has_gazebo_model_sdf()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GazeboModelSDF* temp = payload_.gazebo_model_sdf_;
    payload_.gazebo_model_sdf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_gazebo_model_sdf(::mw::internal::robotics::gazebotransport::GazeboModelSDF* gazebo_model_sdf) {
  clear_payload();
  if (gazebo_model_sdf) {
    set_has_gazebo_model_sdf();
    payload_.gazebo_model_sdf_ = gazebo_model_sdf;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.gazebo_model_sdf)
}
inline ::mw::internal::robotics::gazebotransport::GazeboModelSDF* Packet::_internal_mutable_gazebo_model_sdf() {
  if (!_internal_has_gazebo_model_sdf()) {
    clear_payload();
    set_has_gazebo_model_sdf();
    payload_.gazebo_model_sdf_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::GazeboModelSDF >(GetArena());
  }
  return payload_.gazebo_model_sdf_;
}
inline ::mw::internal::robotics::gazebotransport::GazeboModelSDF* Packet::mutable_gazebo_model_sdf() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.gazebo_model_sdf)
  return _internal_mutable_gazebo_model_sdf();
}

// .mw.internal.robotics.gazebotransport.GetGazeboModelSDF get_gazebo_model_sdf = 43;
inline bool Packet::_internal_has_get_gazebo_model_sdf() const {
  return payload_case() == kGetGazeboModelSdf;
}
inline bool Packet::has_get_gazebo_model_sdf() const {
  return _internal_has_get_gazebo_model_sdf();
}
inline void Packet::set_has_get_gazebo_model_sdf() {
  _oneof_case_[0] = kGetGazeboModelSdf;
}
inline void Packet::clear_get_gazebo_model_sdf() {
  if (_internal_has_get_gazebo_model_sdf()) {
    if (GetArena() == nullptr) {
      delete payload_.get_gazebo_model_sdf_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* Packet::release_get_gazebo_model_sdf() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_sdf)
  if (_internal_has_get_gazebo_model_sdf()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* temp = payload_.get_gazebo_model_sdf_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.get_gazebo_model_sdf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF& Packet::_internal_get_gazebo_model_sdf() const {
  return _internal_has_get_gazebo_model_sdf()
      ? *payload_.get_gazebo_model_sdf_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF*>(&::mw::internal::robotics::gazebotransport::_GetGazeboModelSDF_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF& Packet::get_gazebo_model_sdf() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_sdf)
  return _internal_get_gazebo_model_sdf();
}
inline ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* Packet::unsafe_arena_release_get_gazebo_model_sdf() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_sdf)
  if (_internal_has_get_gazebo_model_sdf()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* temp = payload_.get_gazebo_model_sdf_;
    payload_.get_gazebo_model_sdf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_get_gazebo_model_sdf(::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* get_gazebo_model_sdf) {
  clear_payload();
  if (get_gazebo_model_sdf) {
    set_has_get_gazebo_model_sdf();
    payload_.get_gazebo_model_sdf_ = get_gazebo_model_sdf;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_sdf)
}
inline ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* Packet::_internal_mutable_get_gazebo_model_sdf() {
  if (!_internal_has_get_gazebo_model_sdf()) {
    clear_payload();
    set_has_get_gazebo_model_sdf();
    payload_.get_gazebo_model_sdf_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF >(GetArena());
  }
  return payload_.get_gazebo_model_sdf_;
}
inline ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* Packet::mutable_get_gazebo_model_sdf() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_sdf)
  return _internal_mutable_get_gazebo_model_sdf();
}

// optional string error_message = 44;
inline bool Packet::_internal_has_error_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Packet::has_error_message() const {
  return _internal_has_error_message();
}
inline void Packet::clear_error_message() {
  error_message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Packet::error_message() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.error_message)
  return _internal_error_message();
}
inline void Packet::set_error_message(const std::string& value) {
  _internal_set_error_message(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Packet.error_message)
}
inline std::string* Packet::mutable_error_message() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.error_message)
  return _internal_mutable_error_message();
}
inline const std::string& Packet::_internal_error_message() const {
  return error_message_.Get();
}
inline void Packet::_internal_set_error_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Packet::set_error_message(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  error_message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.Packet.error_message)
}
inline void Packet::set_error_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.Packet.error_message)
}
inline void Packet::set_error_message(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.Packet.error_message)
}
inline std::string* Packet::_internal_mutable_error_message() {
  _has_bits_[0] |= 0x00000001u;
  return error_message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Packet::release_error_message() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.error_message)
  if (!_internal_has_error_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return error_message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Packet::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.error_message)
}
inline std::string* Packet::unsafe_arena_release_error_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Packet.error_message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return error_message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Packet::unsafe_arena_set_allocated_error_message(
    std::string* error_message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (error_message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      error_message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Packet.error_message)
}

// optional bool is_new_reading = 45;
inline bool Packet::_internal_has_is_new_reading() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Packet::has_is_new_reading() const {
  return _internal_has_is_new_reading();
}
inline void Packet::clear_is_new_reading() {
  is_new_reading_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Packet::_internal_is_new_reading() const {
  return is_new_reading_;
}
inline bool Packet::is_new_reading() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.is_new_reading)
  return _internal_is_new_reading();
}
inline void Packet::_internal_set_is_new_reading(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_new_reading_ = value;
}
inline void Packet::set_is_new_reading(bool value) {
  _internal_set_is_new_reading(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Packet.is_new_reading)
}

inline bool Packet::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Packet::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Packet::PayloadCase Packet::payload_case() const {
  return Packet::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// StepSimulation

// required uint32 num_steps = 1;
inline bool StepSimulation::_internal_has_num_steps() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StepSimulation::has_num_steps() const {
  return _internal_has_num_steps();
}
inline void StepSimulation::clear_num_steps() {
  num_steps_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StepSimulation::_internal_num_steps() const {
  return num_steps_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StepSimulation::num_steps() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.StepSimulation.num_steps)
  return _internal_num_steps();
}
inline void StepSimulation::_internal_set_num_steps(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  num_steps_ = value;
}
inline void StepSimulation::set_num_steps(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_num_steps(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.StepSimulation.num_steps)
}

// -------------------------------------------------------------------

// ResetSimulation

// required .mw.internal.robotics.gazebotransport.ResetSimulation.ResetBehavior behavior = 1;
inline bool ResetSimulation::_internal_has_behavior() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResetSimulation::has_behavior() const {
  return _internal_has_behavior();
}
inline void ResetSimulation::clear_behavior() {
  behavior_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior ResetSimulation::_internal_behavior() const {
  return static_cast< ::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior >(behavior_);
}
inline ::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior ResetSimulation::behavior() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ResetSimulation.behavior)
  return _internal_behavior();
}
inline void ResetSimulation::_internal_set_behavior(::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior value) {
  assert(::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  behavior_ = value;
}
inline void ResetSimulation::set_behavior(::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior value) {
  _internal_set_behavior(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ResetSimulation.behavior)
}

// -------------------------------------------------------------------

// Image

// optional uint32 width = 1;
inline bool Image::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Image::has_width() const {
  return _internal_has_width();
}
inline void Image::clear_width() {
  width_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Image::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Image::width() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Image.width)
  return _internal_width();
}
inline void Image::_internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  width_ = value;
}
inline void Image::set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Image.width)
}

// optional uint32 height = 2;
inline bool Image::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Image::has_height() const {
  return _internal_has_height();
}
inline void Image::clear_height() {
  height_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Image::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Image::height() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Image.height)
  return _internal_height();
}
inline void Image::_internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  height_ = value;
}
inline void Image::set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Image.height)
}

// optional bytes data = 3;
inline bool Image::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Image::has_data() const {
  return _internal_has_data();
}
inline void Image::clear_data() {
  data_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Image::data() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Image.data)
  return _internal_data();
}
inline void Image::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Image.data)
}
inline std::string* Image::mutable_data() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Image.data)
  return _internal_mutable_data();
}
inline const std::string& Image::_internal_data() const {
  return data_.Get();
}
inline void Image::_internal_set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Image::set_data(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.Image.data)
}
inline void Image::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.Image.data)
}
inline void Image::set_data(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.Image.data)
}
inline std::string* Image::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000001u;
  return data_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Image::release_data() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Image.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Image::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Image.data)
}
inline std::string* Image::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Image.data)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return data_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Image::unsafe_arena_set_allocated_data(
    std::string* data) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      data, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Image.data)
}

// optional string data_type = 4;
inline bool Image::_internal_has_data_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Image::has_data_type() const {
  return _internal_has_data_type();
}
inline void Image::clear_data_type() {
  data_type_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Image::data_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Image.data_type)
  return _internal_data_type();
}
inline void Image::set_data_type(const std::string& value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Image.data_type)
}
inline std::string* Image::mutable_data_type() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Image.data_type)
  return _internal_mutable_data_type();
}
inline const std::string& Image::_internal_data_type() const {
  return data_type_.Get();
}
inline void Image::_internal_set_data_type(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  data_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Image::set_data_type(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  data_type_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.Image.data_type)
}
inline void Image::set_data_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  data_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.Image.data_type)
}
inline void Image::set_data_type(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  data_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.Image.data_type)
}
inline std::string* Image::_internal_mutable_data_type() {
  _has_bits_[0] |= 0x00000002u;
  return data_type_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Image::release_data_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Image.data_type)
  if (!_internal_has_data_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return data_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Image::set_allocated_data_type(std::string* data_type) {
  if (data_type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  data_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data_type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Image.data_type)
}
inline std::string* Image::unsafe_arena_release_data_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Image.data_type)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return data_type_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Image::unsafe_arena_set_allocated_data_type(
    std::string* data_type) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (data_type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  data_type_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      data_type, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Image.data_type)
}

// -------------------------------------------------------------------

// RequestImage

// required string topic_name = 1;
inline bool RequestImage::_internal_has_topic_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestImage::has_topic_name() const {
  return _internal_has_topic_name();
}
inline void RequestImage::clear_topic_name() {
  topic_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RequestImage::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
  return _internal_topic_name();
}
inline void RequestImage::set_topic_name(const std::string& value) {
  _internal_set_topic_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
}
inline std::string* RequestImage::mutable_topic_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
  return _internal_mutable_topic_name();
}
inline const std::string& RequestImage::_internal_topic_name() const {
  return topic_name_.Get();
}
inline void RequestImage::_internal_set_topic_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RequestImage::set_topic_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
}
inline void RequestImage::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
}
inline void RequestImage::set_topic_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
}
inline std::string* RequestImage::_internal_mutable_topic_name() {
  _has_bits_[0] |= 0x00000001u;
  return topic_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RequestImage::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
  if (!_internal_has_topic_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return topic_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RequestImage::set_allocated_topic_name(std::string* topic_name) {
  if (topic_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
}
inline std::string* RequestImage::unsafe_arena_release_topic_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return topic_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RequestImage::unsafe_arena_set_allocated_topic_name(
    std::string* topic_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (topic_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      topic_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
}

// -------------------------------------------------------------------

// RequestCoSim

// required string client_id = 1;
inline bool RequestCoSim::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestCoSim::has_client_id() const {
  return _internal_has_client_id();
}
inline void RequestCoSim::clear_client_id() {
  client_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RequestCoSim::client_id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
  return _internal_client_id();
}
inline void RequestCoSim::set_client_id(const std::string& value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
}
inline std::string* RequestCoSim::mutable_client_id() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
  return _internal_mutable_client_id();
}
inline const std::string& RequestCoSim::_internal_client_id() const {
  return client_id_.Get();
}
inline void RequestCoSim::_internal_set_client_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  client_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RequestCoSim::set_client_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  client_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
}
inline void RequestCoSim::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  client_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
}
inline void RequestCoSim::set_client_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  client_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
}
inline std::string* RequestCoSim::_internal_mutable_client_id() {
  _has_bits_[0] |= 0x00000001u;
  return client_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RequestCoSim::release_client_id() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
  if (!_internal_has_client_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return client_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RequestCoSim::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
}
inline std::string* RequestCoSim::unsafe_arena_release_client_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return client_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RequestCoSim::unsafe_arena_set_allocated_client_id(
    std::string* client_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (client_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      client_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
}

// required double duration = 2;
inline bool RequestCoSim::_internal_has_duration() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RequestCoSim::has_duration() const {
  return _internal_has_duration();
}
inline void RequestCoSim::clear_duration() {
  duration_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double RequestCoSim::_internal_duration() const {
  return duration_;
}
inline double RequestCoSim::duration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestCoSim.duration)
  return _internal_duration();
}
inline void RequestCoSim::_internal_set_duration(double value) {
  _has_bits_[0] |= 0x00000002u;
  duration_ = value;
}
inline void RequestCoSim::set_duration(double value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestCoSim.duration)
}

// -------------------------------------------------------------------

// StopCoSim

// required string client_id = 1;
inline bool StopCoSim::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StopCoSim::has_client_id() const {
  return _internal_has_client_id();
}
inline void StopCoSim::clear_client_id() {
  client_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StopCoSim::client_id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
  return _internal_client_id();
}
inline void StopCoSim::set_client_id(const std::string& value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
}
inline std::string* StopCoSim::mutable_client_id() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
  return _internal_mutable_client_id();
}
inline const std::string& StopCoSim::_internal_client_id() const {
  return client_id_.Get();
}
inline void StopCoSim::_internal_set_client_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  client_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void StopCoSim::set_client_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  client_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
}
inline void StopCoSim::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  client_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
}
inline void StopCoSim::set_client_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  client_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
}
inline std::string* StopCoSim::_internal_mutable_client_id() {
  _has_bits_[0] |= 0x00000001u;
  return client_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* StopCoSim::release_client_id() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
  if (!_internal_has_client_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return client_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void StopCoSim::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
}
inline std::string* StopCoSim::unsafe_arena_release_client_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return client_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void StopCoSim::unsafe_arena_set_allocated_client_id(
    std::string* client_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (client_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      client_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
}

// -------------------------------------------------------------------

// GetGroundTruthWorldPose

// required string model_name = 1;
inline bool GetGroundTruthWorldPose::_internal_has_model_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetGroundTruthWorldPose::has_model_name() const {
  return _internal_has_model_name();
}
inline void GetGroundTruthWorldPose::clear_model_name() {
  model_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetGroundTruthWorldPose::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
  return _internal_model_name();
}
inline void GetGroundTruthWorldPose::set_model_name(const std::string& value) {
  _internal_set_model_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}
inline std::string* GetGroundTruthWorldPose::mutable_model_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
  return _internal_mutable_model_name();
}
inline const std::string& GetGroundTruthWorldPose::_internal_model_name() const {
  return model_name_.Get();
}
inline void GetGroundTruthWorldPose::_internal_set_model_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetGroundTruthWorldPose::set_model_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}
inline void GetGroundTruthWorldPose::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}
inline void GetGroundTruthWorldPose::set_model_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}
inline std::string* GetGroundTruthWorldPose::_internal_mutable_model_name() {
  _has_bits_[0] |= 0x00000001u;
  return model_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetGroundTruthWorldPose::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
  if (!_internal_has_model_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetGroundTruthWorldPose::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}
inline std::string* GetGroundTruthWorldPose::unsafe_arena_release_model_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetGroundTruthWorldPose::unsafe_arena_set_allocated_model_name(
    std::string* model_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      model_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}

// required string link_name = 2;
inline bool GetGroundTruthWorldPose::_internal_has_link_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetGroundTruthWorldPose::has_link_name() const {
  return _internal_has_link_name();
}
inline void GetGroundTruthWorldPose::clear_link_name() {
  link_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GetGroundTruthWorldPose::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
  return _internal_link_name();
}
inline void GetGroundTruthWorldPose::set_link_name(const std::string& value) {
  _internal_set_link_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}
inline std::string* GetGroundTruthWorldPose::mutable_link_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
  return _internal_mutable_link_name();
}
inline const std::string& GetGroundTruthWorldPose::_internal_link_name() const {
  return link_name_.Get();
}
inline void GetGroundTruthWorldPose::_internal_set_link_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetGroundTruthWorldPose::set_link_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}
inline void GetGroundTruthWorldPose::set_link_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}
inline void GetGroundTruthWorldPose::set_link_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}
inline std::string* GetGroundTruthWorldPose::_internal_mutable_link_name() {
  _has_bits_[0] |= 0x00000002u;
  return link_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetGroundTruthWorldPose::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
  if (!_internal_has_link_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return link_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetGroundTruthWorldPose::set_allocated_link_name(std::string* link_name) {
  if (link_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  link_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), link_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}
inline std::string* GetGroundTruthWorldPose::unsafe_arena_release_link_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return link_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetGroundTruthWorldPose::unsafe_arena_set_allocated_link_name(
    std::string* link_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (link_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  link_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      link_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}

// -------------------------------------------------------------------

// Point

// required double x = 1;
inline bool Point::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Point::has_x() const {
  return _internal_has_x();
}
inline void Point::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Point::_internal_x() const {
  return x_;
}
inline double Point::x() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Point.x)
  return _internal_x();
}
inline void Point::_internal_set_x(double value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void Point::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Point.x)
}

// required double y = 2;
inline bool Point::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Point::has_y() const {
  return _internal_has_y();
}
inline void Point::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Point::_internal_y() const {
  return y_;
}
inline double Point::y() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Point.y)
  return _internal_y();
}
inline void Point::_internal_set_y(double value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void Point::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Point.y)
}

// required double z = 3;
inline bool Point::_internal_has_z() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Point::has_z() const {
  return _internal_has_z();
}
inline void Point::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double Point::_internal_z() const {
  return z_;
}
inline double Point::z() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Point.z)
  return _internal_z();
}
inline void Point::_internal_set_z(double value) {
  _has_bits_[0] |= 0x00000004u;
  z_ = value;
}
inline void Point::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Point.z)
}

// -------------------------------------------------------------------

// Quaternion

// required double x = 1;
inline bool Quaternion::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Quaternion::has_x() const {
  return _internal_has_x();
}
inline void Quaternion::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Quaternion::_internal_x() const {
  return x_;
}
inline double Quaternion::x() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Quaternion.x)
  return _internal_x();
}
inline void Quaternion::_internal_set_x(double value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void Quaternion::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Quaternion.x)
}

// required double y = 2;
inline bool Quaternion::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Quaternion::has_y() const {
  return _internal_has_y();
}
inline void Quaternion::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Quaternion::_internal_y() const {
  return y_;
}
inline double Quaternion::y() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Quaternion.y)
  return _internal_y();
}
inline void Quaternion::_internal_set_y(double value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void Quaternion::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Quaternion.y)
}

// required double z = 3;
inline bool Quaternion::_internal_has_z() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Quaternion::has_z() const {
  return _internal_has_z();
}
inline void Quaternion::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double Quaternion::_internal_z() const {
  return z_;
}
inline double Quaternion::z() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Quaternion.z)
  return _internal_z();
}
inline void Quaternion::_internal_set_z(double value) {
  _has_bits_[0] |= 0x00000004u;
  z_ = value;
}
inline void Quaternion::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Quaternion.z)
}

// required double w = 4;
inline bool Quaternion::_internal_has_w() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Quaternion::has_w() const {
  return _internal_has_w();
}
inline void Quaternion::clear_w() {
  w_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double Quaternion::_internal_w() const {
  return w_;
}
inline double Quaternion::w() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Quaternion.w)
  return _internal_w();
}
inline void Quaternion::_internal_set_w(double value) {
  _has_bits_[0] |= 0x00000008u;
  w_ = value;
}
inline void Quaternion::set_w(double value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Quaternion.w)
}

// -------------------------------------------------------------------

// Pose

// required .mw.internal.robotics.gazebotransport.Point position = 1;
inline bool Pose::_internal_has_position() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || position_ != nullptr);
  return value;
}
inline bool Pose::has_position() const {
  return _internal_has_position();
}
inline void Pose::clear_position() {
  if (position_ != nullptr) position_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mw::internal::robotics::gazebotransport::Point& Pose::_internal_position() const {
  const ::mw::internal::robotics::gazebotransport::Point* p = position_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Point*>(
      &::mw::internal::robotics::gazebotransport::_Point_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Point& Pose::position() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Pose.position)
  return _internal_position();
}
inline void Pose::unsafe_arena_set_allocated_position(
    ::mw::internal::robotics::gazebotransport::Point* position) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Pose.position)
}
inline ::mw::internal::robotics::gazebotransport::Point* Pose::release_position() {
  auto temp = unsafe_arena_release_position();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* Pose::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Pose.position)
  _has_bits_[0] &= ~0x00000001u;
  ::mw::internal::robotics::gazebotransport::Point* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* Pose::_internal_mutable_position() {
  _has_bits_[0] |= 0x00000001u;
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Point>(GetArena());
    position_ = p;
  }
  return position_;
}
inline ::mw::internal::robotics::gazebotransport::Point* Pose::mutable_position() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Pose.position)
  return _internal_mutable_position();
}
inline void Pose::set_allocated_position(::mw::internal::robotics::gazebotransport::Point* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Pose.position)
}

// required .mw.internal.robotics.gazebotransport.Quaternion orientation = 2;
inline bool Pose::_internal_has_orientation() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || orientation_ != nullptr);
  return value;
}
inline bool Pose::has_orientation() const {
  return _internal_has_orientation();
}
inline void Pose::clear_orientation() {
  if (orientation_ != nullptr) orientation_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mw::internal::robotics::gazebotransport::Quaternion& Pose::_internal_orientation() const {
  const ::mw::internal::robotics::gazebotransport::Quaternion* p = orientation_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Quaternion*>(
      &::mw::internal::robotics::gazebotransport::_Quaternion_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Quaternion& Pose::orientation() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Pose.orientation)
  return _internal_orientation();
}
inline void Pose::unsafe_arena_set_allocated_orientation(
    ::mw::internal::robotics::gazebotransport::Quaternion* orientation) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(orientation_);
  }
  orientation_ = orientation;
  if (orientation) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Pose.orientation)
}
inline ::mw::internal::robotics::gazebotransport::Quaternion* Pose::release_orientation() {
  auto temp = unsafe_arena_release_orientation();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Quaternion* Pose::unsafe_arena_release_orientation() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Pose.orientation)
  _has_bits_[0] &= ~0x00000002u;
  ::mw::internal::robotics::gazebotransport::Quaternion* temp = orientation_;
  orientation_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Quaternion* Pose::_internal_mutable_orientation() {
  _has_bits_[0] |= 0x00000002u;
  if (orientation_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Quaternion>(GetArena());
    orientation_ = p;
  }
  return orientation_;
}
inline ::mw::internal::robotics::gazebotransport::Quaternion* Pose::mutable_orientation() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Pose.orientation)
  return _internal_mutable_orientation();
}
inline void Pose::set_allocated_orientation(::mw::internal::robotics::gazebotransport::Quaternion* orientation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete orientation_;
  }
  if (orientation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(orientation);
    if (message_arena != submessage_arena) {
      orientation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orientation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  orientation_ = orientation;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Pose.orientation)
}

// -------------------------------------------------------------------

// StopSimulation

// required bool stop_scene = 1;
inline bool StopSimulation::_internal_has_stop_scene() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StopSimulation::has_stop_scene() const {
  return _internal_has_stop_scene();
}
inline void StopSimulation::clear_stop_scene() {
  stop_scene_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool StopSimulation::_internal_stop_scene() const {
  return stop_scene_;
}
inline bool StopSimulation::stop_scene() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.StopSimulation.stop_scene)
  return _internal_stop_scene();
}
inline void StopSimulation::_internal_set_stop_scene(bool value) {
  _has_bits_[0] |= 0x00000001u;
  stop_scene_ = value;
}
inline void StopSimulation::set_stop_scene(bool value) {
  _internal_set_stop_scene(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.StopSimulation.stop_scene)
}

// -------------------------------------------------------------------

// LaserData

// optional double angle_min = 1;
inline bool LaserData::_internal_has_angle_min() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LaserData::has_angle_min() const {
  return _internal_has_angle_min();
}
inline void LaserData::clear_angle_min() {
  angle_min_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double LaserData::_internal_angle_min() const {
  return angle_min_;
}
inline double LaserData::angle_min() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.angle_min)
  return _internal_angle_min();
}
inline void LaserData::_internal_set_angle_min(double value) {
  _has_bits_[0] |= 0x00000001u;
  angle_min_ = value;
}
inline void LaserData::set_angle_min(double value) {
  _internal_set_angle_min(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.angle_min)
}

// optional double angle_max = 2;
inline bool LaserData::_internal_has_angle_max() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LaserData::has_angle_max() const {
  return _internal_has_angle_max();
}
inline void LaserData::clear_angle_max() {
  angle_max_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double LaserData::_internal_angle_max() const {
  return angle_max_;
}
inline double LaserData::angle_max() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.angle_max)
  return _internal_angle_max();
}
inline void LaserData::_internal_set_angle_max(double value) {
  _has_bits_[0] |= 0x00000002u;
  angle_max_ = value;
}
inline void LaserData::set_angle_max(double value) {
  _internal_set_angle_max(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.angle_max)
}

// optional double angle_step = 3;
inline bool LaserData::_internal_has_angle_step() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LaserData::has_angle_step() const {
  return _internal_has_angle_step();
}
inline void LaserData::clear_angle_step() {
  angle_step_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double LaserData::_internal_angle_step() const {
  return angle_step_;
}
inline double LaserData::angle_step() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.angle_step)
  return _internal_angle_step();
}
inline void LaserData::_internal_set_angle_step(double value) {
  _has_bits_[0] |= 0x00000004u;
  angle_step_ = value;
}
inline void LaserData::set_angle_step(double value) {
  _internal_set_angle_step(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.angle_step)
}

// optional double range_min = 4;
inline bool LaserData::_internal_has_range_min() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LaserData::has_range_min() const {
  return _internal_has_range_min();
}
inline void LaserData::clear_range_min() {
  range_min_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double LaserData::_internal_range_min() const {
  return range_min_;
}
inline double LaserData::range_min() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.range_min)
  return _internal_range_min();
}
inline void LaserData::_internal_set_range_min(double value) {
  _has_bits_[0] |= 0x00000008u;
  range_min_ = value;
}
inline void LaserData::set_range_min(double value) {
  _internal_set_range_min(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.range_min)
}

// optional double range_max = 5;
inline bool LaserData::_internal_has_range_max() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LaserData::has_range_max() const {
  return _internal_has_range_max();
}
inline void LaserData::clear_range_max() {
  range_max_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double LaserData::_internal_range_max() const {
  return range_max_;
}
inline double LaserData::range_max() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.range_max)
  return _internal_range_max();
}
inline void LaserData::_internal_set_range_max(double value) {
  _has_bits_[0] |= 0x00000010u;
  range_max_ = value;
}
inline void LaserData::set_range_max(double value) {
  _internal_set_range_max(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.range_max)
}

// optional double count = 6;
inline bool LaserData::_internal_has_count() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LaserData::has_count() const {
  return _internal_has_count();
}
inline void LaserData::clear_count() {
  count_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double LaserData::_internal_count() const {
  return count_;
}
inline double LaserData::count() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.count)
  return _internal_count();
}
inline void LaserData::_internal_set_count(double value) {
  _has_bits_[0] |= 0x00000020u;
  count_ = value;
}
inline void LaserData::set_count(double value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.count)
}

// optional double vertical_angle_min = 7;
inline bool LaserData::_internal_has_vertical_angle_min() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LaserData::has_vertical_angle_min() const {
  return _internal_has_vertical_angle_min();
}
inline void LaserData::clear_vertical_angle_min() {
  vertical_angle_min_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double LaserData::_internal_vertical_angle_min() const {
  return vertical_angle_min_;
}
inline double LaserData::vertical_angle_min() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.vertical_angle_min)
  return _internal_vertical_angle_min();
}
inline void LaserData::_internal_set_vertical_angle_min(double value) {
  _has_bits_[0] |= 0x00000040u;
  vertical_angle_min_ = value;
}
inline void LaserData::set_vertical_angle_min(double value) {
  _internal_set_vertical_angle_min(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.vertical_angle_min)
}

// optional double vertical_angle_max = 8;
inline bool LaserData::_internal_has_vertical_angle_max() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool LaserData::has_vertical_angle_max() const {
  return _internal_has_vertical_angle_max();
}
inline void LaserData::clear_vertical_angle_max() {
  vertical_angle_max_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline double LaserData::_internal_vertical_angle_max() const {
  return vertical_angle_max_;
}
inline double LaserData::vertical_angle_max() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.vertical_angle_max)
  return _internal_vertical_angle_max();
}
inline void LaserData::_internal_set_vertical_angle_max(double value) {
  _has_bits_[0] |= 0x00000080u;
  vertical_angle_max_ = value;
}
inline void LaserData::set_vertical_angle_max(double value) {
  _internal_set_vertical_angle_max(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.vertical_angle_max)
}

// optional double vertical_angle_step = 9;
inline bool LaserData::_internal_has_vertical_angle_step() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool LaserData::has_vertical_angle_step() const {
  return _internal_has_vertical_angle_step();
}
inline void LaserData::clear_vertical_angle_step() {
  vertical_angle_step_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline double LaserData::_internal_vertical_angle_step() const {
  return vertical_angle_step_;
}
inline double LaserData::vertical_angle_step() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.vertical_angle_step)
  return _internal_vertical_angle_step();
}
inline void LaserData::_internal_set_vertical_angle_step(double value) {
  _has_bits_[0] |= 0x00000100u;
  vertical_angle_step_ = value;
}
inline void LaserData::set_vertical_angle_step(double value) {
  _internal_set_vertical_angle_step(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.vertical_angle_step)
}

// repeated double range = 10;
inline int LaserData::_internal_range_size() const {
  return range_.size();
}
inline int LaserData::range_size() const {
  return _internal_range_size();
}
inline void LaserData::clear_range() {
  range_.Clear();
}
inline double LaserData::_internal_range(int index) const {
  return range_.Get(index);
}
inline double LaserData::range(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.range)
  return _internal_range(index);
}
inline void LaserData::set_range(int index, double value) {
  range_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.range)
}
inline void LaserData::_internal_add_range(double value) {
  range_.Add(value);
}
inline void LaserData::add_range(double value) {
  _internal_add_range(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.LaserData.range)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
LaserData::_internal_range() const {
  return range_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
LaserData::range() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.LaserData.range)
  return _internal_range();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
LaserData::_internal_mutable_range() {
  return &range_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
LaserData::mutable_range() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.LaserData.range)
  return _internal_mutable_range();
}

// repeated double intensities = 11;
inline int LaserData::_internal_intensities_size() const {
  return intensities_.size();
}
inline int LaserData::intensities_size() const {
  return _internal_intensities_size();
}
inline void LaserData::clear_intensities() {
  intensities_.Clear();
}
inline double LaserData::_internal_intensities(int index) const {
  return intensities_.Get(index);
}
inline double LaserData::intensities(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.intensities)
  return _internal_intensities(index);
}
inline void LaserData::set_intensities(int index, double value) {
  intensities_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.intensities)
}
inline void LaserData::_internal_add_intensities(double value) {
  intensities_.Add(value);
}
inline void LaserData::add_intensities(double value) {
  _internal_add_intensities(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.LaserData.intensities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
LaserData::_internal_intensities() const {
  return intensities_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
LaserData::intensities() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.LaserData.intensities)
  return _internal_intensities();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
LaserData::_internal_mutable_intensities() {
  return &intensities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
LaserData::mutable_intensities() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.LaserData.intensities)
  return _internal_mutable_intensities();
}

// -------------------------------------------------------------------

// RequestLaser

// required string topic_name = 1;
inline bool RequestLaser::_internal_has_topic_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestLaser::has_topic_name() const {
  return _internal_has_topic_name();
}
inline void RequestLaser::clear_topic_name() {
  topic_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RequestLaser::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
  return _internal_topic_name();
}
inline void RequestLaser::set_topic_name(const std::string& value) {
  _internal_set_topic_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
}
inline std::string* RequestLaser::mutable_topic_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
  return _internal_mutable_topic_name();
}
inline const std::string& RequestLaser::_internal_topic_name() const {
  return topic_name_.Get();
}
inline void RequestLaser::_internal_set_topic_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RequestLaser::set_topic_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
}
inline void RequestLaser::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
}
inline void RequestLaser::set_topic_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
}
inline std::string* RequestLaser::_internal_mutable_topic_name() {
  _has_bits_[0] |= 0x00000001u;
  return topic_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RequestLaser::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
  if (!_internal_has_topic_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return topic_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RequestLaser::set_allocated_topic_name(std::string* topic_name) {
  if (topic_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
}
inline std::string* RequestLaser::unsafe_arena_release_topic_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return topic_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RequestLaser::unsafe_arena_set_allocated_topic_name(
    std::string* topic_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (topic_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      topic_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
}

// -------------------------------------------------------------------

// ImuData

// optional .mw.internal.robotics.gazebotransport.Point linear_acceleration = 1;
inline bool ImuData::_internal_has_linear_acceleration() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || linear_acceleration_ != nullptr);
  return value;
}
inline bool ImuData::has_linear_acceleration() const {
  return _internal_has_linear_acceleration();
}
inline void ImuData::clear_linear_acceleration() {
  if (linear_acceleration_ != nullptr) linear_acceleration_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mw::internal::robotics::gazebotransport::Point& ImuData::_internal_linear_acceleration() const {
  const ::mw::internal::robotics::gazebotransport::Point* p = linear_acceleration_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Point*>(
      &::mw::internal::robotics::gazebotransport::_Point_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Point& ImuData::linear_acceleration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ImuData.linear_acceleration)
  return _internal_linear_acceleration();
}
inline void ImuData::unsafe_arena_set_allocated_linear_acceleration(
    ::mw::internal::robotics::gazebotransport::Point* linear_acceleration) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(linear_acceleration_);
  }
  linear_acceleration_ = linear_acceleration;
  if (linear_acceleration) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.ImuData.linear_acceleration)
}
inline ::mw::internal::robotics::gazebotransport::Point* ImuData::release_linear_acceleration() {
  auto temp = unsafe_arena_release_linear_acceleration();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* ImuData::unsafe_arena_release_linear_acceleration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ImuData.linear_acceleration)
  _has_bits_[0] &= ~0x00000001u;
  ::mw::internal::robotics::gazebotransport::Point* temp = linear_acceleration_;
  linear_acceleration_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* ImuData::_internal_mutable_linear_acceleration() {
  _has_bits_[0] |= 0x00000001u;
  if (linear_acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Point>(GetArena());
    linear_acceleration_ = p;
  }
  return linear_acceleration_;
}
inline ::mw::internal::robotics::gazebotransport::Point* ImuData::mutable_linear_acceleration() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ImuData.linear_acceleration)
  return _internal_mutable_linear_acceleration();
}
inline void ImuData::set_allocated_linear_acceleration(::mw::internal::robotics::gazebotransport::Point* linear_acceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete linear_acceleration_;
  }
  if (linear_acceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(linear_acceleration);
    if (message_arena != submessage_arena) {
      linear_acceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear_acceleration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  linear_acceleration_ = linear_acceleration;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ImuData.linear_acceleration)
}

// optional .mw.internal.robotics.gazebotransport.Point angular_velocity = 2;
inline bool ImuData::_internal_has_angular_velocity() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || angular_velocity_ != nullptr);
  return value;
}
inline bool ImuData::has_angular_velocity() const {
  return _internal_has_angular_velocity();
}
inline void ImuData::clear_angular_velocity() {
  if (angular_velocity_ != nullptr) angular_velocity_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mw::internal::robotics::gazebotransport::Point& ImuData::_internal_angular_velocity() const {
  const ::mw::internal::robotics::gazebotransport::Point* p = angular_velocity_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Point*>(
      &::mw::internal::robotics::gazebotransport::_Point_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Point& ImuData::angular_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ImuData.angular_velocity)
  return _internal_angular_velocity();
}
inline void ImuData::unsafe_arena_set_allocated_angular_velocity(
    ::mw::internal::robotics::gazebotransport::Point* angular_velocity) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(angular_velocity_);
  }
  angular_velocity_ = angular_velocity;
  if (angular_velocity) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.ImuData.angular_velocity)
}
inline ::mw::internal::robotics::gazebotransport::Point* ImuData::release_angular_velocity() {
  auto temp = unsafe_arena_release_angular_velocity();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* ImuData::unsafe_arena_release_angular_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ImuData.angular_velocity)
  _has_bits_[0] &= ~0x00000002u;
  ::mw::internal::robotics::gazebotransport::Point* temp = angular_velocity_;
  angular_velocity_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* ImuData::_internal_mutable_angular_velocity() {
  _has_bits_[0] |= 0x00000002u;
  if (angular_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Point>(GetArena());
    angular_velocity_ = p;
  }
  return angular_velocity_;
}
inline ::mw::internal::robotics::gazebotransport::Point* ImuData::mutable_angular_velocity() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ImuData.angular_velocity)
  return _internal_mutable_angular_velocity();
}
inline void ImuData::set_allocated_angular_velocity(::mw::internal::robotics::gazebotransport::Point* angular_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete angular_velocity_;
  }
  if (angular_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(angular_velocity);
    if (message_arena != submessage_arena) {
      angular_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angular_velocity, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  angular_velocity_ = angular_velocity;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ImuData.angular_velocity)
}

// optional .mw.internal.robotics.gazebotransport.Quaternion orientation = 3;
inline bool ImuData::_internal_has_orientation() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || orientation_ != nullptr);
  return value;
}
inline bool ImuData::has_orientation() const {
  return _internal_has_orientation();
}
inline void ImuData::clear_orientation() {
  if (orientation_ != nullptr) orientation_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mw::internal::robotics::gazebotransport::Quaternion& ImuData::_internal_orientation() const {
  const ::mw::internal::robotics::gazebotransport::Quaternion* p = orientation_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Quaternion*>(
      &::mw::internal::robotics::gazebotransport::_Quaternion_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Quaternion& ImuData::orientation() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ImuData.orientation)
  return _internal_orientation();
}
inline void ImuData::unsafe_arena_set_allocated_orientation(
    ::mw::internal::robotics::gazebotransport::Quaternion* orientation) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(orientation_);
  }
  orientation_ = orientation;
  if (orientation) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.ImuData.orientation)
}
inline ::mw::internal::robotics::gazebotransport::Quaternion* ImuData::release_orientation() {
  auto temp = unsafe_arena_release_orientation();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Quaternion* ImuData::unsafe_arena_release_orientation() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ImuData.orientation)
  _has_bits_[0] &= ~0x00000004u;
  ::mw::internal::robotics::gazebotransport::Quaternion* temp = orientation_;
  orientation_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Quaternion* ImuData::_internal_mutable_orientation() {
  _has_bits_[0] |= 0x00000004u;
  if (orientation_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Quaternion>(GetArena());
    orientation_ = p;
  }
  return orientation_;
}
inline ::mw::internal::robotics::gazebotransport::Quaternion* ImuData::mutable_orientation() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ImuData.orientation)
  return _internal_mutable_orientation();
}
inline void ImuData::set_allocated_orientation(::mw::internal::robotics::gazebotransport::Quaternion* orientation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete orientation_;
  }
  if (orientation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(orientation);
    if (message_arena != submessage_arena) {
      orientation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orientation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  orientation_ = orientation;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ImuData.orientation)
}

// -------------------------------------------------------------------

// RequestImu

// required string topic_name = 1;
inline bool RequestImu::_internal_has_topic_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestImu::has_topic_name() const {
  return _internal_has_topic_name();
}
inline void RequestImu::clear_topic_name() {
  topic_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RequestImu::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
  return _internal_topic_name();
}
inline void RequestImu::set_topic_name(const std::string& value) {
  _internal_set_topic_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
}
inline std::string* RequestImu::mutable_topic_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
  return _internal_mutable_topic_name();
}
inline const std::string& RequestImu::_internal_topic_name() const {
  return topic_name_.Get();
}
inline void RequestImu::_internal_set_topic_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RequestImu::set_topic_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
}
inline void RequestImu::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
}
inline void RequestImu::set_topic_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
}
inline std::string* RequestImu::_internal_mutable_topic_name() {
  _has_bits_[0] |= 0x00000001u;
  return topic_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RequestImu::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
  if (!_internal_has_topic_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return topic_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RequestImu::set_allocated_topic_name(std::string* topic_name) {
  if (topic_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
}
inline std::string* RequestImu::unsafe_arena_release_topic_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return topic_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RequestImu::unsafe_arena_set_allocated_topic_name(
    std::string* topic_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (topic_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      topic_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
}

// -------------------------------------------------------------------

// SubscribeImage

// required string topic_name = 1;
inline bool SubscribeImage::_internal_has_topic_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SubscribeImage::has_topic_name() const {
  return _internal_has_topic_name();
}
inline void SubscribeImage::clear_topic_name() {
  topic_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SubscribeImage::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
  return _internal_topic_name();
}
inline void SubscribeImage::set_topic_name(const std::string& value) {
  _internal_set_topic_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
}
inline std::string* SubscribeImage::mutable_topic_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
  return _internal_mutable_topic_name();
}
inline const std::string& SubscribeImage::_internal_topic_name() const {
  return topic_name_.Get();
}
inline void SubscribeImage::_internal_set_topic_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SubscribeImage::set_topic_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
}
inline void SubscribeImage::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
}
inline void SubscribeImage::set_topic_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
}
inline std::string* SubscribeImage::_internal_mutable_topic_name() {
  _has_bits_[0] |= 0x00000001u;
  return topic_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SubscribeImage::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
  if (!_internal_has_topic_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return topic_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SubscribeImage::set_allocated_topic_name(std::string* topic_name) {
  if (topic_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
}
inline std::string* SubscribeImage::unsafe_arena_release_topic_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return topic_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SubscribeImage::unsafe_arena_set_allocated_topic_name(
    std::string* topic_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (topic_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      topic_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
}

// -------------------------------------------------------------------

// SubscribeLaser

// required string topic_name = 1;
inline bool SubscribeLaser::_internal_has_topic_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SubscribeLaser::has_topic_name() const {
  return _internal_has_topic_name();
}
inline void SubscribeLaser::clear_topic_name() {
  topic_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SubscribeLaser::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
  return _internal_topic_name();
}
inline void SubscribeLaser::set_topic_name(const std::string& value) {
  _internal_set_topic_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
}
inline std::string* SubscribeLaser::mutable_topic_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
  return _internal_mutable_topic_name();
}
inline const std::string& SubscribeLaser::_internal_topic_name() const {
  return topic_name_.Get();
}
inline void SubscribeLaser::_internal_set_topic_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SubscribeLaser::set_topic_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
}
inline void SubscribeLaser::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
}
inline void SubscribeLaser::set_topic_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
}
inline std::string* SubscribeLaser::_internal_mutable_topic_name() {
  _has_bits_[0] |= 0x00000001u;
  return topic_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SubscribeLaser::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
  if (!_internal_has_topic_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return topic_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SubscribeLaser::set_allocated_topic_name(std::string* topic_name) {
  if (topic_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
}
inline std::string* SubscribeLaser::unsafe_arena_release_topic_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return topic_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SubscribeLaser::unsafe_arena_set_allocated_topic_name(
    std::string* topic_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (topic_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      topic_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
}

// -------------------------------------------------------------------

// SubscribeImu

// required string topic_name = 1;
inline bool SubscribeImu::_internal_has_topic_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SubscribeImu::has_topic_name() const {
  return _internal_has_topic_name();
}
inline void SubscribeImu::clear_topic_name() {
  topic_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SubscribeImu::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
  return _internal_topic_name();
}
inline void SubscribeImu::set_topic_name(const std::string& value) {
  _internal_set_topic_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
}
inline std::string* SubscribeImu::mutable_topic_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
  return _internal_mutable_topic_name();
}
inline const std::string& SubscribeImu::_internal_topic_name() const {
  return topic_name_.Get();
}
inline void SubscribeImu::_internal_set_topic_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SubscribeImu::set_topic_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
}
inline void SubscribeImu::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
}
inline void SubscribeImu::set_topic_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
}
inline std::string* SubscribeImu::_internal_mutable_topic_name() {
  _has_bits_[0] |= 0x00000001u;
  return topic_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SubscribeImu::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
  if (!_internal_has_topic_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return topic_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SubscribeImu::set_allocated_topic_name(std::string* topic_name) {
  if (topic_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
}
inline std::string* SubscribeImu::unsafe_arena_release_topic_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return topic_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SubscribeImu::unsafe_arena_set_allocated_topic_name(
    std::string* topic_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (topic_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      topic_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
}

// -------------------------------------------------------------------

// ApplyLinkWrench

// required string model_name = 1;
inline bool ApplyLinkWrench::_internal_has_model_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ApplyLinkWrench::has_model_name() const {
  return _internal_has_model_name();
}
inline void ApplyLinkWrench::clear_model_name() {
  model_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ApplyLinkWrench::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
  return _internal_model_name();
}
inline void ApplyLinkWrench::set_model_name(const std::string& value) {
  _internal_set_model_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
}
inline std::string* ApplyLinkWrench::mutable_model_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
  return _internal_mutable_model_name();
}
inline const std::string& ApplyLinkWrench::_internal_model_name() const {
  return model_name_.Get();
}
inline void ApplyLinkWrench::_internal_set_model_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ApplyLinkWrench::set_model_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
}
inline void ApplyLinkWrench::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
}
inline void ApplyLinkWrench::set_model_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
}
inline std::string* ApplyLinkWrench::_internal_mutable_model_name() {
  _has_bits_[0] |= 0x00000001u;
  return model_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ApplyLinkWrench::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
  if (!_internal_has_model_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ApplyLinkWrench::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
}
inline std::string* ApplyLinkWrench::unsafe_arena_release_model_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ApplyLinkWrench::unsafe_arena_set_allocated_model_name(
    std::string* model_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      model_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
}

// required string link_name = 2;
inline bool ApplyLinkWrench::_internal_has_link_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ApplyLinkWrench::has_link_name() const {
  return _internal_has_link_name();
}
inline void ApplyLinkWrench::clear_link_name() {
  link_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ApplyLinkWrench::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
  return _internal_link_name();
}
inline void ApplyLinkWrench::set_link_name(const std::string& value) {
  _internal_set_link_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
}
inline std::string* ApplyLinkWrench::mutable_link_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
  return _internal_mutable_link_name();
}
inline const std::string& ApplyLinkWrench::_internal_link_name() const {
  return link_name_.Get();
}
inline void ApplyLinkWrench::_internal_set_link_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ApplyLinkWrench::set_link_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
}
inline void ApplyLinkWrench::set_link_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
}
inline void ApplyLinkWrench::set_link_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
}
inline std::string* ApplyLinkWrench::_internal_mutable_link_name() {
  _has_bits_[0] |= 0x00000002u;
  return link_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ApplyLinkWrench::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
  if (!_internal_has_link_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return link_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ApplyLinkWrench::set_allocated_link_name(std::string* link_name) {
  if (link_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  link_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), link_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
}
inline std::string* ApplyLinkWrench::unsafe_arena_release_link_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return link_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ApplyLinkWrench::unsafe_arena_set_allocated_link_name(
    std::string* link_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (link_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  link_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      link_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
}

// required string force_type = 3;
inline bool ApplyLinkWrench::_internal_has_force_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ApplyLinkWrench::has_force_type() const {
  return _internal_has_force_type();
}
inline void ApplyLinkWrench::clear_force_type() {
  force_type_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ApplyLinkWrench::force_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
  return _internal_force_type();
}
inline void ApplyLinkWrench::set_force_type(const std::string& value) {
  _internal_set_force_type(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
}
inline std::string* ApplyLinkWrench::mutable_force_type() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
  return _internal_mutable_force_type();
}
inline const std::string& ApplyLinkWrench::_internal_force_type() const {
  return force_type_.Get();
}
inline void ApplyLinkWrench::_internal_set_force_type(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  force_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ApplyLinkWrench::set_force_type(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  force_type_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
}
inline void ApplyLinkWrench::set_force_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  force_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
}
inline void ApplyLinkWrench::set_force_type(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  force_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
}
inline std::string* ApplyLinkWrench::_internal_mutable_force_type() {
  _has_bits_[0] |= 0x00000004u;
  return force_type_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ApplyLinkWrench::release_force_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
  if (!_internal_has_force_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return force_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ApplyLinkWrench::set_allocated_force_type(std::string* force_type) {
  if (force_type != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  force_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), force_type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
}
inline std::string* ApplyLinkWrench::unsafe_arena_release_force_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return force_type_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ApplyLinkWrench::unsafe_arena_set_allocated_force_type(
    std::string* force_type) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (force_type != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  force_type_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      force_type, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
}

// required double fx = 4;
inline bool ApplyLinkWrench::_internal_has_fx() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ApplyLinkWrench::has_fx() const {
  return _internal_has_fx();
}
inline void ApplyLinkWrench::clear_fx() {
  fx_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double ApplyLinkWrench::_internal_fx() const {
  return fx_;
}
inline double ApplyLinkWrench::fx() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.fx)
  return _internal_fx();
}
inline void ApplyLinkWrench::_internal_set_fx(double value) {
  _has_bits_[0] |= 0x00000020u;
  fx_ = value;
}
inline void ApplyLinkWrench::set_fx(double value) {
  _internal_set_fx(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.fx)
}

// required double fy = 5;
inline bool ApplyLinkWrench::_internal_has_fy() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ApplyLinkWrench::has_fy() const {
  return _internal_has_fy();
}
inline void ApplyLinkWrench::clear_fy() {
  fy_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double ApplyLinkWrench::_internal_fy() const {
  return fy_;
}
inline double ApplyLinkWrench::fy() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.fy)
  return _internal_fy();
}
inline void ApplyLinkWrench::_internal_set_fy(double value) {
  _has_bits_[0] |= 0x00000040u;
  fy_ = value;
}
inline void ApplyLinkWrench::set_fy(double value) {
  _internal_set_fy(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.fy)
}

// required double fz = 6;
inline bool ApplyLinkWrench::_internal_has_fz() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ApplyLinkWrench::has_fz() const {
  return _internal_has_fz();
}
inline void ApplyLinkWrench::clear_fz() {
  fz_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline double ApplyLinkWrench::_internal_fz() const {
  return fz_;
}
inline double ApplyLinkWrench::fz() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.fz)
  return _internal_fz();
}
inline void ApplyLinkWrench::_internal_set_fz(double value) {
  _has_bits_[0] |= 0x00000080u;
  fz_ = value;
}
inline void ApplyLinkWrench::set_fz(double value) {
  _internal_set_fz(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.fz)
}

// required string torque_type = 7;
inline bool ApplyLinkWrench::_internal_has_torque_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ApplyLinkWrench::has_torque_type() const {
  return _internal_has_torque_type();
}
inline void ApplyLinkWrench::clear_torque_type() {
  torque_type_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ApplyLinkWrench::torque_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
  return _internal_torque_type();
}
inline void ApplyLinkWrench::set_torque_type(const std::string& value) {
  _internal_set_torque_type(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
}
inline std::string* ApplyLinkWrench::mutable_torque_type() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
  return _internal_mutable_torque_type();
}
inline const std::string& ApplyLinkWrench::_internal_torque_type() const {
  return torque_type_.Get();
}
inline void ApplyLinkWrench::_internal_set_torque_type(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  torque_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ApplyLinkWrench::set_torque_type(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  torque_type_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
}
inline void ApplyLinkWrench::set_torque_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  torque_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
}
inline void ApplyLinkWrench::set_torque_type(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  torque_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
}
inline std::string* ApplyLinkWrench::_internal_mutable_torque_type() {
  _has_bits_[0] |= 0x00000008u;
  return torque_type_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ApplyLinkWrench::release_torque_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
  if (!_internal_has_torque_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return torque_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ApplyLinkWrench::set_allocated_torque_type(std::string* torque_type) {
  if (torque_type != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  torque_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), torque_type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
}
inline std::string* ApplyLinkWrench::unsafe_arena_release_torque_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000008u;
  return torque_type_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ApplyLinkWrench::unsafe_arena_set_allocated_torque_type(
    std::string* torque_type) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (torque_type != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  torque_type_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      torque_type, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
}

// required double tx = 8;
inline bool ApplyLinkWrench::_internal_has_tx() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ApplyLinkWrench::has_tx() const {
  return _internal_has_tx();
}
inline void ApplyLinkWrench::clear_tx() {
  tx_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline double ApplyLinkWrench::_internal_tx() const {
  return tx_;
}
inline double ApplyLinkWrench::tx() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.tx)
  return _internal_tx();
}
inline void ApplyLinkWrench::_internal_set_tx(double value) {
  _has_bits_[0] |= 0x00000100u;
  tx_ = value;
}
inline void ApplyLinkWrench::set_tx(double value) {
  _internal_set_tx(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.tx)
}

// required double ty = 9;
inline bool ApplyLinkWrench::_internal_has_ty() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ApplyLinkWrench::has_ty() const {
  return _internal_has_ty();
}
inline void ApplyLinkWrench::clear_ty() {
  ty_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline double ApplyLinkWrench::_internal_ty() const {
  return ty_;
}
inline double ApplyLinkWrench::ty() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.ty)
  return _internal_ty();
}
inline void ApplyLinkWrench::_internal_set_ty(double value) {
  _has_bits_[0] |= 0x00000200u;
  ty_ = value;
}
inline void ApplyLinkWrench::set_ty(double value) {
  _internal_set_ty(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.ty)
}

// required double tz = 10;
inline bool ApplyLinkWrench::_internal_has_tz() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ApplyLinkWrench::has_tz() const {
  return _internal_has_tz();
}
inline void ApplyLinkWrench::clear_tz() {
  tz_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline double ApplyLinkWrench::_internal_tz() const {
  return tz_;
}
inline double ApplyLinkWrench::tz() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.tz)
  return _internal_tz();
}
inline void ApplyLinkWrench::_internal_set_tz(double value) {
  _has_bits_[0] |= 0x00000400u;
  tz_ = value;
}
inline void ApplyLinkWrench::set_tz(double value) {
  _internal_set_tz(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.tz)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 11;
inline bool ApplyLinkWrench::_internal_has_duration() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || duration_ != nullptr);
  return value;
}
inline bool ApplyLinkWrench::has_duration() const {
  return _internal_has_duration();
}
inline void ApplyLinkWrench::clear_duration() {
  if (duration_ != nullptr) duration_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::mw::internal::robotics::gazebotransport::Time& ApplyLinkWrench::_internal_duration() const {
  const ::mw::internal::robotics::gazebotransport::Time* p = duration_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Time*>(
      &::mw::internal::robotics::gazebotransport::_Time_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Time& ApplyLinkWrench::duration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.duration)
  return _internal_duration();
}
inline void ApplyLinkWrench::unsafe_arena_set_allocated_duration(
    ::mw::internal::robotics::gazebotransport::Time* duration) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration_);
  }
  duration_ = duration;
  if (duration) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.ApplyLinkWrench.duration)
}
inline ::mw::internal::robotics::gazebotransport::Time* ApplyLinkWrench::release_duration() {
  auto temp = unsafe_arena_release_duration();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Time* ApplyLinkWrench::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyLinkWrench.duration)
  _has_bits_[0] &= ~0x00000010u;
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Time* ApplyLinkWrench::_internal_mutable_duration() {
  _has_bits_[0] |= 0x00000010u;
  if (duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Time>(GetArena());
    duration_ = p;
  }
  return duration_;
}
inline ::mw::internal::robotics::gazebotransport::Time* ApplyLinkWrench::mutable_duration() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyLinkWrench.duration)
  return _internal_mutable_duration();
}
inline void ApplyLinkWrench::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete duration_;
  }
  if (duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(duration);
    if (message_arena != submessage_arena) {
      duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyLinkWrench.duration)
}

// -------------------------------------------------------------------

// ApplyJointTorque

// required string model_name = 1;
inline bool ApplyJointTorque::_internal_has_model_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ApplyJointTorque::has_model_name() const {
  return _internal_has_model_name();
}
inline void ApplyJointTorque::clear_model_name() {
  model_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ApplyJointTorque::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
  return _internal_model_name();
}
inline void ApplyJointTorque::set_model_name(const std::string& value) {
  _internal_set_model_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
}
inline std::string* ApplyJointTorque::mutable_model_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
  return _internal_mutable_model_name();
}
inline const std::string& ApplyJointTorque::_internal_model_name() const {
  return model_name_.Get();
}
inline void ApplyJointTorque::_internal_set_model_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ApplyJointTorque::set_model_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
}
inline void ApplyJointTorque::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
}
inline void ApplyJointTorque::set_model_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
}
inline std::string* ApplyJointTorque::_internal_mutable_model_name() {
  _has_bits_[0] |= 0x00000001u;
  return model_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ApplyJointTorque::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
  if (!_internal_has_model_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ApplyJointTorque::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
}
inline std::string* ApplyJointTorque::unsafe_arena_release_model_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ApplyJointTorque::unsafe_arena_set_allocated_model_name(
    std::string* model_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      model_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
}

// required string joint_name = 2;
inline bool ApplyJointTorque::_internal_has_joint_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ApplyJointTorque::has_joint_name() const {
  return _internal_has_joint_name();
}
inline void ApplyJointTorque::clear_joint_name() {
  joint_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ApplyJointTorque::joint_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
  return _internal_joint_name();
}
inline void ApplyJointTorque::set_joint_name(const std::string& value) {
  _internal_set_joint_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
}
inline std::string* ApplyJointTorque::mutable_joint_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
  return _internal_mutable_joint_name();
}
inline const std::string& ApplyJointTorque::_internal_joint_name() const {
  return joint_name_.Get();
}
inline void ApplyJointTorque::_internal_set_joint_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  joint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ApplyJointTorque::set_joint_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  joint_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
}
inline void ApplyJointTorque::set_joint_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  joint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
}
inline void ApplyJointTorque::set_joint_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  joint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
}
inline std::string* ApplyJointTorque::_internal_mutable_joint_name() {
  _has_bits_[0] |= 0x00000002u;
  return joint_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ApplyJointTorque::release_joint_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
  if (!_internal_has_joint_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return joint_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ApplyJointTorque::set_allocated_joint_name(std::string* joint_name) {
  if (joint_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  joint_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), joint_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
}
inline std::string* ApplyJointTorque::unsafe_arena_release_joint_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return joint_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ApplyJointTorque::unsafe_arena_set_allocated_joint_name(
    std::string* joint_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (joint_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  joint_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      joint_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
}

// required uint32 index = 3;
inline bool ApplyJointTorque::_internal_has_index() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ApplyJointTorque::has_index() const {
  return _internal_has_index();
}
inline void ApplyJointTorque::clear_index() {
  index_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ApplyJointTorque::_internal_index() const {
  return index_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ApplyJointTorque::index() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyJointTorque.index)
  return _internal_index();
}
inline void ApplyJointTorque::_internal_set_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  index_ = value;
}
inline void ApplyJointTorque::set_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyJointTorque.index)
}

// required double effort = 4;
inline bool ApplyJointTorque::_internal_has_effort() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ApplyJointTorque::has_effort() const {
  return _internal_has_effort();
}
inline void ApplyJointTorque::clear_effort() {
  effort_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double ApplyJointTorque::_internal_effort() const {
  return effort_;
}
inline double ApplyJointTorque::effort() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyJointTorque.effort)
  return _internal_effort();
}
inline void ApplyJointTorque::_internal_set_effort(double value) {
  _has_bits_[0] |= 0x00000008u;
  effort_ = value;
}
inline void ApplyJointTorque::set_effort(double value) {
  _internal_set_effort(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyJointTorque.effort)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 5;
inline bool ApplyJointTorque::_internal_has_duration() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || duration_ != nullptr);
  return value;
}
inline bool ApplyJointTorque::has_duration() const {
  return _internal_has_duration();
}
inline void ApplyJointTorque::clear_duration() {
  if (duration_ != nullptr) duration_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mw::internal::robotics::gazebotransport::Time& ApplyJointTorque::_internal_duration() const {
  const ::mw::internal::robotics::gazebotransport::Time* p = duration_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Time*>(
      &::mw::internal::robotics::gazebotransport::_Time_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Time& ApplyJointTorque::duration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyJointTorque.duration)
  return _internal_duration();
}
inline void ApplyJointTorque::unsafe_arena_set_allocated_duration(
    ::mw::internal::robotics::gazebotransport::Time* duration) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration_);
  }
  duration_ = duration;
  if (duration) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.ApplyJointTorque.duration)
}
inline ::mw::internal::robotics::gazebotransport::Time* ApplyJointTorque::release_duration() {
  auto temp = unsafe_arena_release_duration();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Time* ApplyJointTorque::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyJointTorque.duration)
  _has_bits_[0] &= ~0x00000004u;
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Time* ApplyJointTorque::_internal_mutable_duration() {
  _has_bits_[0] |= 0x00000004u;
  if (duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Time>(GetArena());
    duration_ = p;
  }
  return duration_;
}
inline ::mw::internal::robotics::gazebotransport::Time* ApplyJointTorque::mutable_duration() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyJointTorque.duration)
  return _internal_mutable_duration();
}
inline void ApplyJointTorque::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete duration_;
  }
  if (duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(duration);
    if (message_arena != submessage_arena) {
      duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyJointTorque.duration)
}

// -------------------------------------------------------------------

// GetPose

// required string model_name = 1;
inline bool GetPose::_internal_has_model_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetPose::has_model_name() const {
  return _internal_has_model_name();
}
inline void GetPose::clear_model_name() {
  model_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetPose::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetPose.model_name)
  return _internal_model_name();
}
inline void GetPose::set_model_name(const std::string& value) {
  _internal_set_model_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetPose.model_name)
}
inline std::string* GetPose::mutable_model_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetPose.model_name)
  return _internal_mutable_model_name();
}
inline const std::string& GetPose::_internal_model_name() const {
  return model_name_.Get();
}
inline void GetPose::_internal_set_model_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetPose::set_model_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.GetPose.model_name)
}
inline void GetPose::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetPose.model_name)
}
inline void GetPose::set_model_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetPose.model_name)
}
inline std::string* GetPose::_internal_mutable_model_name() {
  _has_bits_[0] |= 0x00000001u;
  return model_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetPose::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetPose.model_name)
  if (!_internal_has_model_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetPose::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetPose.model_name)
}
inline std::string* GetPose::unsafe_arena_release_model_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.GetPose.model_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetPose::unsafe_arena_set_allocated_model_name(
    std::string* model_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      model_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.GetPose.model_name)
}

// -------------------------------------------------------------------

// GetTopicList

// required string topic_name = 1;
inline bool GetTopicList::_internal_has_topic_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetTopicList::has_topic_name() const {
  return _internal_has_topic_name();
}
inline void GetTopicList::clear_topic_name() {
  topic_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetTopicList::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
  return _internal_topic_name();
}
inline void GetTopicList::set_topic_name(const std::string& value) {
  _internal_set_topic_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
}
inline std::string* GetTopicList::mutable_topic_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
  return _internal_mutable_topic_name();
}
inline const std::string& GetTopicList::_internal_topic_name() const {
  return topic_name_.Get();
}
inline void GetTopicList::_internal_set_topic_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetTopicList::set_topic_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
}
inline void GetTopicList::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
}
inline void GetTopicList::set_topic_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
}
inline std::string* GetTopicList::_internal_mutable_topic_name() {
  _has_bits_[0] |= 0x00000001u;
  return topic_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetTopicList::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
  if (!_internal_has_topic_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return topic_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetTopicList::set_allocated_topic_name(std::string* topic_name) {
  if (topic_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
}
inline std::string* GetTopicList::unsafe_arena_release_topic_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return topic_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetTopicList::unsafe_arena_set_allocated_topic_name(
    std::string* topic_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (topic_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      topic_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
}

// -------------------------------------------------------------------

// TopicList_TopicInfo

// required string name = 1;
inline bool TopicList_TopicInfo::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TopicList_TopicInfo::has_name() const {
  return _internal_has_name();
}
inline void TopicList_TopicInfo::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TopicList_TopicInfo::name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
  return _internal_name();
}
inline void TopicList_TopicInfo::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
}
inline std::string* TopicList_TopicInfo::mutable_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
  return _internal_mutable_name();
}
inline const std::string& TopicList_TopicInfo::_internal_name() const {
  return name_.Get();
}
inline void TopicList_TopicInfo::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TopicList_TopicInfo::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
}
inline void TopicList_TopicInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
}
inline void TopicList_TopicInfo::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
}
inline std::string* TopicList_TopicInfo::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TopicList_TopicInfo::release_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TopicList_TopicInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
}
inline std::string* TopicList_TopicInfo::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TopicList_TopicInfo::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
}

// required string type = 2;
inline bool TopicList_TopicInfo::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TopicList_TopicInfo::has_type() const {
  return _internal_has_type();
}
inline void TopicList_TopicInfo::clear_type() {
  type_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TopicList_TopicInfo::type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
  return _internal_type();
}
inline void TopicList_TopicInfo::set_type(const std::string& value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
}
inline std::string* TopicList_TopicInfo::mutable_type() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
  return _internal_mutable_type();
}
inline const std::string& TopicList_TopicInfo::_internal_type() const {
  return type_.Get();
}
inline void TopicList_TopicInfo::_internal_set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TopicList_TopicInfo::set_type(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  type_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
}
inline void TopicList_TopicInfo::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
}
inline void TopicList_TopicInfo::set_type(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
}
inline std::string* TopicList_TopicInfo::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000002u;
  return type_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TopicList_TopicInfo::release_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TopicList_TopicInfo::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
}
inline std::string* TopicList_TopicInfo::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return type_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TopicList_TopicInfo::unsafe_arena_set_allocated_type(
    std::string* type) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  type_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      type, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
}

// -------------------------------------------------------------------

// TopicList

// repeated .mw.internal.robotics.gazebotransport.TopicList.TopicInfo data = 1;
inline int TopicList::_internal_data_size() const {
  return data_.size();
}
inline int TopicList::data_size() const {
  return _internal_data_size();
}
inline void TopicList::clear_data() {
  data_.Clear();
}
inline ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo* TopicList::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TopicList.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo >*
TopicList::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.TopicList.data)
  return &data_;
}
inline const ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo& TopicList::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo& TopicList::data(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TopicList.data)
  return _internal_data(index);
}
inline ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo* TopicList::_internal_add_data() {
  return data_.Add();
}
inline ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo* TopicList::add_data() {
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TopicList.data)
  return _internal_add_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo >&
TopicList::data() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.TopicList.data)
  return data_;
}

// -------------------------------------------------------------------

// GetModelInfo

// required string topic_name = 1;
inline bool GetModelInfo::_internal_has_topic_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetModelInfo::has_topic_name() const {
  return _internal_has_topic_name();
}
inline void GetModelInfo::clear_topic_name() {
  topic_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetModelInfo::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
  return _internal_topic_name();
}
inline void GetModelInfo::set_topic_name(const std::string& value) {
  _internal_set_topic_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
}
inline std::string* GetModelInfo::mutable_topic_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
  return _internal_mutable_topic_name();
}
inline const std::string& GetModelInfo::_internal_topic_name() const {
  return topic_name_.Get();
}
inline void GetModelInfo::_internal_set_topic_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetModelInfo::set_topic_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
}
inline void GetModelInfo::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
}
inline void GetModelInfo::set_topic_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
}
inline std::string* GetModelInfo::_internal_mutable_topic_name() {
  _has_bits_[0] |= 0x00000001u;
  return topic_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetModelInfo::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
  if (!_internal_has_topic_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return topic_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetModelInfo::set_allocated_topic_name(std::string* topic_name) {
  if (topic_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
}
inline std::string* GetModelInfo::unsafe_arena_release_topic_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return topic_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetModelInfo::unsafe_arena_set_allocated_topic_name(
    std::string* topic_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (topic_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      topic_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
}

// -------------------------------------------------------------------

// ModelInfo_LINKS

// repeated string link_name = 1;
inline int ModelInfo_LINKS::_internal_link_name_size() const {
  return link_name_.size();
}
inline int ModelInfo_LINKS::link_name_size() const {
  return _internal_link_name_size();
}
inline void ModelInfo_LINKS::clear_link_name() {
  link_name_.Clear();
}
inline std::string* ModelInfo_LINKS::add_link_name() {
  // @@protoc_insertion_point(field_add_mutable:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return _internal_add_link_name();
}
inline const std::string& ModelInfo_LINKS::_internal_link_name(int index) const {
  return link_name_.Get(index);
}
inline const std::string& ModelInfo_LINKS::link_name(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return _internal_link_name(index);
}
inline std::string* ModelInfo_LINKS::mutable_link_name(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return link_name_.Mutable(index);
}
inline void ModelInfo_LINKS::set_link_name(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
  link_name_.Mutable(index)->assign(value);
}
inline void ModelInfo_LINKS::set_link_name(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
  link_name_.Mutable(index)->assign(std::move(value));
}
inline void ModelInfo_LINKS::set_link_name(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  link_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
inline void ModelInfo_LINKS::set_link_name(int index, const char* value, size_t size) {
  link_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
inline std::string* ModelInfo_LINKS::_internal_add_link_name() {
  return link_name_.Add();
}
inline void ModelInfo_LINKS::add_link_name(const std::string& value) {
  link_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
inline void ModelInfo_LINKS::add_link_name(std::string&& value) {
  link_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
inline void ModelInfo_LINKS::add_link_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  link_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
inline void ModelInfo_LINKS::add_link_name(const char* value, size_t size) {
  link_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModelInfo_LINKS::link_name() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return link_name_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModelInfo_LINKS::mutable_link_name() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return &link_name_;
}

// -------------------------------------------------------------------

// ModelInfo_JOINTS

// repeated string joint_name = 1;
inline int ModelInfo_JOINTS::_internal_joint_name_size() const {
  return joint_name_.size();
}
inline int ModelInfo_JOINTS::joint_name_size() const {
  return _internal_joint_name_size();
}
inline void ModelInfo_JOINTS::clear_joint_name() {
  joint_name_.Clear();
}
inline std::string* ModelInfo_JOINTS::add_joint_name() {
  // @@protoc_insertion_point(field_add_mutable:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return _internal_add_joint_name();
}
inline const std::string& ModelInfo_JOINTS::_internal_joint_name(int index) const {
  return joint_name_.Get(index);
}
inline const std::string& ModelInfo_JOINTS::joint_name(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return _internal_joint_name(index);
}
inline std::string* ModelInfo_JOINTS::mutable_joint_name(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return joint_name_.Mutable(index);
}
inline void ModelInfo_JOINTS::set_joint_name(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  joint_name_.Mutable(index)->assign(value);
}
inline void ModelInfo_JOINTS::set_joint_name(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  joint_name_.Mutable(index)->assign(std::move(value));
}
inline void ModelInfo_JOINTS::set_joint_name(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  joint_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
inline void ModelInfo_JOINTS::set_joint_name(int index, const char* value, size_t size) {
  joint_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
inline std::string* ModelInfo_JOINTS::_internal_add_joint_name() {
  return joint_name_.Add();
}
inline void ModelInfo_JOINTS::add_joint_name(const std::string& value) {
  joint_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
inline void ModelInfo_JOINTS::add_joint_name(std::string&& value) {
  joint_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
inline void ModelInfo_JOINTS::add_joint_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  joint_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
inline void ModelInfo_JOINTS::add_joint_name(const char* value, size_t size) {
  joint_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModelInfo_JOINTS::joint_name() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return joint_name_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModelInfo_JOINTS::mutable_joint_name() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return &joint_name_;
}

// -------------------------------------------------------------------

// ModelInfo_Model

// required string model_name = 1;
inline bool ModelInfo_Model::_internal_has_model_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ModelInfo_Model::has_model_name() const {
  return _internal_has_model_name();
}
inline void ModelInfo_Model::clear_model_name() {
  model_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ModelInfo_Model::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
  return _internal_model_name();
}
inline void ModelInfo_Model::set_model_name(const std::string& value) {
  _internal_set_model_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
}
inline std::string* ModelInfo_Model::mutable_model_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
  return _internal_mutable_model_name();
}
inline const std::string& ModelInfo_Model::_internal_model_name() const {
  return model_name_.Get();
}
inline void ModelInfo_Model::_internal_set_model_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ModelInfo_Model::set_model_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
}
inline void ModelInfo_Model::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
}
inline void ModelInfo_Model::set_model_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
}
inline std::string* ModelInfo_Model::_internal_mutable_model_name() {
  _has_bits_[0] |= 0x00000001u;
  return model_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ModelInfo_Model::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
  if (!_internal_has_model_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ModelInfo_Model::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
}
inline std::string* ModelInfo_Model::unsafe_arena_release_model_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ModelInfo_Model::unsafe_arena_set_allocated_model_name(
    std::string* model_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      model_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
}

// optional .mw.internal.robotics.gazebotransport.ModelInfo.LINKS links = 2;
inline bool ModelInfo_Model::_internal_has_links() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || links_ != nullptr);
  return value;
}
inline bool ModelInfo_Model::has_links() const {
  return _internal_has_links();
}
inline void ModelInfo_Model::clear_links() {
  if (links_ != nullptr) links_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS& ModelInfo_Model::_internal_links() const {
  const ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* p = links_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS*>(
      &::mw::internal::robotics::gazebotransport::_ModelInfo_LINKS_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS& ModelInfo_Model::links() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ModelInfo.Model.links)
  return _internal_links();
}
inline void ModelInfo_Model::unsafe_arena_set_allocated_links(
    ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* links) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(links_);
  }
  links_ = links;
  if (links) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.ModelInfo.Model.links)
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* ModelInfo_Model::release_links() {
  auto temp = unsafe_arena_release_links();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* ModelInfo_Model::unsafe_arena_release_links() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ModelInfo.Model.links)
  _has_bits_[0] &= ~0x00000002u;
  ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* temp = links_;
  links_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* ModelInfo_Model::_internal_mutable_links() {
  _has_bits_[0] |= 0x00000002u;
  if (links_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ModelInfo_LINKS>(GetArena());
    links_ = p;
  }
  return links_;
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* ModelInfo_Model::mutable_links() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ModelInfo.Model.links)
  return _internal_mutable_links();
}
inline void ModelInfo_Model::set_allocated_links(::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* links) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete links_;
  }
  if (links) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(links);
    if (message_arena != submessage_arena) {
      links = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, links, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  links_ = links;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ModelInfo.Model.links)
}

// optional .mw.internal.robotics.gazebotransport.ModelInfo.JOINTS joints = 3;
inline bool ModelInfo_Model::_internal_has_joints() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || joints_ != nullptr);
  return value;
}
inline bool ModelInfo_Model::has_joints() const {
  return _internal_has_joints();
}
inline void ModelInfo_Model::clear_joints() {
  if (joints_ != nullptr) joints_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS& ModelInfo_Model::_internal_joints() const {
  const ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* p = joints_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS*>(
      &::mw::internal::robotics::gazebotransport::_ModelInfo_JOINTS_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS& ModelInfo_Model::joints() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ModelInfo.Model.joints)
  return _internal_joints();
}
inline void ModelInfo_Model::unsafe_arena_set_allocated_joints(
    ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* joints) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(joints_);
  }
  joints_ = joints;
  if (joints) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.ModelInfo.Model.joints)
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* ModelInfo_Model::release_joints() {
  auto temp = unsafe_arena_release_joints();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* ModelInfo_Model::unsafe_arena_release_joints() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ModelInfo.Model.joints)
  _has_bits_[0] &= ~0x00000004u;
  ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* temp = joints_;
  joints_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* ModelInfo_Model::_internal_mutable_joints() {
  _has_bits_[0] |= 0x00000004u;
  if (joints_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS>(GetArena());
    joints_ = p;
  }
  return joints_;
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* ModelInfo_Model::mutable_joints() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ModelInfo.Model.joints)
  return _internal_mutable_joints();
}
inline void ModelInfo_Model::set_allocated_joints(::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* joints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete joints_;
  }
  if (joints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(joints);
    if (message_arena != submessage_arena) {
      joints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, joints, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  joints_ = joints;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ModelInfo.Model.joints)
}

// -------------------------------------------------------------------

// ModelInfo

// repeated .mw.internal.robotics.gazebotransport.ModelInfo.Model model_data = 1;
inline int ModelInfo::_internal_model_data_size() const {
  return model_data_.size();
}
inline int ModelInfo::model_data_size() const {
  return _internal_model_data_size();
}
inline void ModelInfo::clear_model_data() {
  model_data_.Clear();
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo_Model* ModelInfo::mutable_model_data(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ModelInfo.model_data)
  return model_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ModelInfo_Model >*
ModelInfo::mutable_model_data() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.ModelInfo.model_data)
  return &model_data_;
}
inline const ::mw::internal::robotics::gazebotransport::ModelInfo_Model& ModelInfo::_internal_model_data(int index) const {
  return model_data_.Get(index);
}
inline const ::mw::internal::robotics::gazebotransport::ModelInfo_Model& ModelInfo::model_data(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ModelInfo.model_data)
  return _internal_model_data(index);
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo_Model* ModelInfo::_internal_add_model_data() {
  return model_data_.Add();
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo_Model* ModelInfo::add_model_data() {
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.ModelInfo.model_data)
  return _internal_add_model_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ModelInfo_Model >&
ModelInfo::model_data() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.ModelInfo.model_data)
  return model_data_;
}

// -------------------------------------------------------------------

// MaxStepSize

// required .mw.internal.robotics.gazebotransport.MaxStepSize.TYPE type = 1;
inline bool MaxStepSize::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MaxStepSize::has_type() const {
  return _internal_has_type();
}
inline void MaxStepSize::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE MaxStepSize::_internal_type() const {
  return static_cast< ::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE >(type_);
}
inline ::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE MaxStepSize::type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.MaxStepSize.type)
  return _internal_type();
}
inline void MaxStepSize::_internal_set_type(::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE value) {
  assert(::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void MaxStepSize::set_type(::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.MaxStepSize.type)
}

// required double size = 2;
inline bool MaxStepSize::_internal_has_size() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MaxStepSize::has_size() const {
  return _internal_has_size();
}
inline void MaxStepSize::clear_size() {
  size_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double MaxStepSize::_internal_size() const {
  return size_;
}
inline double MaxStepSize::size() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.MaxStepSize.size)
  return _internal_size();
}
inline void MaxStepSize::_internal_set_size(double value) {
  _has_bits_[0] |= 0x00000001u;
  size_ = value;
}
inline void MaxStepSize::set_size(double value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.MaxStepSize.size)
}

// -------------------------------------------------------------------

// InitCustomPublisher

// required string topic_name = 1;
inline bool InitCustomPublisher::_internal_has_topic_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InitCustomPublisher::has_topic_name() const {
  return _internal_has_topic_name();
}
inline void InitCustomPublisher::clear_topic_name() {
  topic_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InitCustomPublisher::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
  return _internal_topic_name();
}
inline void InitCustomPublisher::set_topic_name(const std::string& value) {
  _internal_set_topic_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
}
inline std::string* InitCustomPublisher::mutable_topic_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
  return _internal_mutable_topic_name();
}
inline const std::string& InitCustomPublisher::_internal_topic_name() const {
  return topic_name_.Get();
}
inline void InitCustomPublisher::_internal_set_topic_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void InitCustomPublisher::set_topic_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
}
inline void InitCustomPublisher::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
}
inline void InitCustomPublisher::set_topic_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
}
inline std::string* InitCustomPublisher::_internal_mutable_topic_name() {
  _has_bits_[0] |= 0x00000001u;
  return topic_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* InitCustomPublisher::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
  if (!_internal_has_topic_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return topic_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InitCustomPublisher::set_allocated_topic_name(std::string* topic_name) {
  if (topic_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
}
inline std::string* InitCustomPublisher::unsafe_arena_release_topic_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return topic_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void InitCustomPublisher::unsafe_arena_set_allocated_topic_name(
    std::string* topic_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (topic_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      topic_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
}

// required string message_type = 2;
inline bool InitCustomPublisher::_internal_has_message_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InitCustomPublisher::has_message_type() const {
  return _internal_has_message_type();
}
inline void InitCustomPublisher::clear_message_type() {
  message_type_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InitCustomPublisher::message_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
  return _internal_message_type();
}
inline void InitCustomPublisher::set_message_type(const std::string& value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
}
inline std::string* InitCustomPublisher::mutable_message_type() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
  return _internal_mutable_message_type();
}
inline const std::string& InitCustomPublisher::_internal_message_type() const {
  return message_type_.Get();
}
inline void InitCustomPublisher::_internal_set_message_type(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  message_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void InitCustomPublisher::set_message_type(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  message_type_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
}
inline void InitCustomPublisher::set_message_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  message_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
}
inline void InitCustomPublisher::set_message_type(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  message_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
}
inline std::string* InitCustomPublisher::_internal_mutable_message_type() {
  _has_bits_[0] |= 0x00000002u;
  return message_type_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* InitCustomPublisher::release_message_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
  if (!_internal_has_message_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return message_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InitCustomPublisher::set_allocated_message_type(std::string* message_type) {
  if (message_type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  message_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message_type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
}
inline std::string* InitCustomPublisher::unsafe_arena_release_message_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return message_type_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void InitCustomPublisher::unsafe_arena_set_allocated_message_type(
    std::string* message_type) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message_type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  message_type_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message_type, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
}

// -------------------------------------------------------------------

// InitCustomSubscriber

// required string topic_name = 1;
inline bool InitCustomSubscriber::_internal_has_topic_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InitCustomSubscriber::has_topic_name() const {
  return _internal_has_topic_name();
}
inline void InitCustomSubscriber::clear_topic_name() {
  topic_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InitCustomSubscriber::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
  return _internal_topic_name();
}
inline void InitCustomSubscriber::set_topic_name(const std::string& value) {
  _internal_set_topic_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
}
inline std::string* InitCustomSubscriber::mutable_topic_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
  return _internal_mutable_topic_name();
}
inline const std::string& InitCustomSubscriber::_internal_topic_name() const {
  return topic_name_.Get();
}
inline void InitCustomSubscriber::_internal_set_topic_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void InitCustomSubscriber::set_topic_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
}
inline void InitCustomSubscriber::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
}
inline void InitCustomSubscriber::set_topic_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
}
inline std::string* InitCustomSubscriber::_internal_mutable_topic_name() {
  _has_bits_[0] |= 0x00000001u;
  return topic_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* InitCustomSubscriber::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
  if (!_internal_has_topic_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return topic_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InitCustomSubscriber::set_allocated_topic_name(std::string* topic_name) {
  if (topic_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
}
inline std::string* InitCustomSubscriber::unsafe_arena_release_topic_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return topic_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void InitCustomSubscriber::unsafe_arena_set_allocated_topic_name(
    std::string* topic_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (topic_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      topic_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
}

// required string message_type = 2;
inline bool InitCustomSubscriber::_internal_has_message_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InitCustomSubscriber::has_message_type() const {
  return _internal_has_message_type();
}
inline void InitCustomSubscriber::clear_message_type() {
  message_type_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InitCustomSubscriber::message_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
  return _internal_message_type();
}
inline void InitCustomSubscriber::set_message_type(const std::string& value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
}
inline std::string* InitCustomSubscriber::mutable_message_type() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
  return _internal_mutable_message_type();
}
inline const std::string& InitCustomSubscriber::_internal_message_type() const {
  return message_type_.Get();
}
inline void InitCustomSubscriber::_internal_set_message_type(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  message_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void InitCustomSubscriber::set_message_type(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  message_type_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
}
inline void InitCustomSubscriber::set_message_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  message_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
}
inline void InitCustomSubscriber::set_message_type(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  message_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
}
inline std::string* InitCustomSubscriber::_internal_mutable_message_type() {
  _has_bits_[0] |= 0x00000002u;
  return message_type_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* InitCustomSubscriber::release_message_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
  if (!_internal_has_message_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return message_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InitCustomSubscriber::set_allocated_message_type(std::string* message_type) {
  if (message_type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  message_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message_type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
}
inline std::string* InitCustomSubscriber::unsafe_arena_release_message_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return message_type_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void InitCustomSubscriber::unsafe_arena_set_allocated_message_type(
    std::string* message_type) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message_type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  message_type_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message_type, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
}

// -------------------------------------------------------------------

// CustomMessageSupport

// required string topic_name = 1;
inline bool CustomMessageSupport::_internal_has_topic_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CustomMessageSupport::has_topic_name() const {
  return _internal_has_topic_name();
}
inline void CustomMessageSupport::clear_topic_name() {
  topic_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CustomMessageSupport::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
  return _internal_topic_name();
}
inline void CustomMessageSupport::set_topic_name(const std::string& value) {
  _internal_set_topic_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
}
inline std::string* CustomMessageSupport::mutable_topic_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
  return _internal_mutable_topic_name();
}
inline const std::string& CustomMessageSupport::_internal_topic_name() const {
  return topic_name_.Get();
}
inline void CustomMessageSupport::_internal_set_topic_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CustomMessageSupport::set_topic_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
}
inline void CustomMessageSupport::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
}
inline void CustomMessageSupport::set_topic_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
}
inline std::string* CustomMessageSupport::_internal_mutable_topic_name() {
  _has_bits_[0] |= 0x00000001u;
  return topic_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CustomMessageSupport::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
  if (!_internal_has_topic_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return topic_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CustomMessageSupport::set_allocated_topic_name(std::string* topic_name) {
  if (topic_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
}
inline std::string* CustomMessageSupport::unsafe_arena_release_topic_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return topic_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CustomMessageSupport::unsafe_arena_set_allocated_topic_name(
    std::string* topic_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (topic_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      topic_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
}

// required string message_type = 2;
inline bool CustomMessageSupport::_internal_has_message_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CustomMessageSupport::has_message_type() const {
  return _internal_has_message_type();
}
inline void CustomMessageSupport::clear_message_type() {
  message_type_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CustomMessageSupport::message_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
  return _internal_message_type();
}
inline void CustomMessageSupport::set_message_type(const std::string& value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
}
inline std::string* CustomMessageSupport::mutable_message_type() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
  return _internal_mutable_message_type();
}
inline const std::string& CustomMessageSupport::_internal_message_type() const {
  return message_type_.Get();
}
inline void CustomMessageSupport::_internal_set_message_type(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  message_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CustomMessageSupport::set_message_type(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  message_type_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
}
inline void CustomMessageSupport::set_message_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  message_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
}
inline void CustomMessageSupport::set_message_type(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  message_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
}
inline std::string* CustomMessageSupport::_internal_mutable_message_type() {
  _has_bits_[0] |= 0x00000002u;
  return message_type_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CustomMessageSupport::release_message_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
  if (!_internal_has_message_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return message_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CustomMessageSupport::set_allocated_message_type(std::string* message_type) {
  if (message_type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  message_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message_type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
}
inline std::string* CustomMessageSupport::unsafe_arena_release_message_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return message_type_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CustomMessageSupport::unsafe_arena_set_allocated_message_type(
    std::string* message_type) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message_type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  message_type_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message_type, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
}

// required bytes data = 3;
inline bool CustomMessageSupport::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CustomMessageSupport::has_data() const {
  return _internal_has_data();
}
inline void CustomMessageSupport::clear_data() {
  data_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CustomMessageSupport::data() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
  return _internal_data();
}
inline void CustomMessageSupport::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
}
inline std::string* CustomMessageSupport::mutable_data() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
  return _internal_mutable_data();
}
inline const std::string& CustomMessageSupport::_internal_data() const {
  return data_.Get();
}
inline void CustomMessageSupport::_internal_set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CustomMessageSupport::set_data(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  data_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
}
inline void CustomMessageSupport::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
}
inline void CustomMessageSupport::set_data(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
}
inline std::string* CustomMessageSupport::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000004u;
  return data_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CustomMessageSupport::release_data() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CustomMessageSupport::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
}
inline std::string* CustomMessageSupport::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return data_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CustomMessageSupport::unsafe_arena_set_allocated_data(
    std::string* data) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  data_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      data, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
}

// optional bool is_new = 4;
inline bool CustomMessageSupport::_internal_has_is_new() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CustomMessageSupport::has_is_new() const {
  return _internal_has_is_new();
}
inline void CustomMessageSupport::clear_is_new() {
  is_new_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool CustomMessageSupport::_internal_is_new() const {
  return is_new_;
}
inline bool CustomMessageSupport::is_new() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.CustomMessageSupport.is_new)
  return _internal_is_new();
}
inline void CustomMessageSupport::_internal_set_is_new(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_new_ = value;
}
inline void CustomMessageSupport::set_is_new(bool value) {
  _internal_set_is_new(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.CustomMessageSupport.is_new)
}

// -------------------------------------------------------------------

// RequestCustomMessageSupport

// required string topic_name = 1;
inline bool RequestCustomMessageSupport::_internal_has_topic_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestCustomMessageSupport::has_topic_name() const {
  return _internal_has_topic_name();
}
inline void RequestCustomMessageSupport::clear_topic_name() {
  topic_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RequestCustomMessageSupport::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
  return _internal_topic_name();
}
inline void RequestCustomMessageSupport::set_topic_name(const std::string& value) {
  _internal_set_topic_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
}
inline std::string* RequestCustomMessageSupport::mutable_topic_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
  return _internal_mutable_topic_name();
}
inline const std::string& RequestCustomMessageSupport::_internal_topic_name() const {
  return topic_name_.Get();
}
inline void RequestCustomMessageSupport::_internal_set_topic_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RequestCustomMessageSupport::set_topic_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
}
inline void RequestCustomMessageSupport::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
}
inline void RequestCustomMessageSupport::set_topic_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
}
inline std::string* RequestCustomMessageSupport::_internal_mutable_topic_name() {
  _has_bits_[0] |= 0x00000001u;
  return topic_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RequestCustomMessageSupport::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
  if (!_internal_has_topic_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return topic_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RequestCustomMessageSupport::set_allocated_topic_name(std::string* topic_name) {
  if (topic_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
}
inline std::string* RequestCustomMessageSupport::unsafe_arena_release_topic_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return topic_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RequestCustomMessageSupport::unsafe_arena_set_allocated_topic_name(
    std::string* topic_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (topic_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      topic_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
}

// required string message_type = 2;
inline bool RequestCustomMessageSupport::_internal_has_message_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RequestCustomMessageSupport::has_message_type() const {
  return _internal_has_message_type();
}
inline void RequestCustomMessageSupport::clear_message_type() {
  message_type_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RequestCustomMessageSupport::message_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
  return _internal_message_type();
}
inline void RequestCustomMessageSupport::set_message_type(const std::string& value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
}
inline std::string* RequestCustomMessageSupport::mutable_message_type() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
  return _internal_mutable_message_type();
}
inline const std::string& RequestCustomMessageSupport::_internal_message_type() const {
  return message_type_.Get();
}
inline void RequestCustomMessageSupport::_internal_set_message_type(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  message_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RequestCustomMessageSupport::set_message_type(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  message_type_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
}
inline void RequestCustomMessageSupport::set_message_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  message_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
}
inline void RequestCustomMessageSupport::set_message_type(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  message_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
}
inline std::string* RequestCustomMessageSupport::_internal_mutable_message_type() {
  _has_bits_[0] |= 0x00000002u;
  return message_type_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RequestCustomMessageSupport::release_message_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
  if (!_internal_has_message_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return message_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RequestCustomMessageSupport::set_allocated_message_type(std::string* message_type) {
  if (message_type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  message_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message_type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
}
inline std::string* RequestCustomMessageSupport::unsafe_arena_release_message_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return message_type_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RequestCustomMessageSupport::unsafe_arena_set_allocated_message_type(
    std::string* message_type) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message_type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  message_type_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message_type, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
}

// -------------------------------------------------------------------

// SetJointPosition

// required string model_name = 1;
inline bool SetJointPosition::_internal_has_model_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetJointPosition::has_model_name() const {
  return _internal_has_model_name();
}
inline void SetJointPosition::clear_model_name() {
  model_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SetJointPosition::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
  return _internal_model_name();
}
inline void SetJointPosition::set_model_name(const std::string& value) {
  _internal_set_model_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
}
inline std::string* SetJointPosition::mutable_model_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
  return _internal_mutable_model_name();
}
inline const std::string& SetJointPosition::_internal_model_name() const {
  return model_name_.Get();
}
inline void SetJointPosition::_internal_set_model_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetJointPosition::set_model_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
}
inline void SetJointPosition::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
}
inline void SetJointPosition::set_model_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
}
inline std::string* SetJointPosition::_internal_mutable_model_name() {
  _has_bits_[0] |= 0x00000001u;
  return model_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetJointPosition::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
  if (!_internal_has_model_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetJointPosition::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
}
inline std::string* SetJointPosition::unsafe_arena_release_model_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetJointPosition::unsafe_arena_set_allocated_model_name(
    std::string* model_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      model_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
}

// required string joint_name = 2;
inline bool SetJointPosition::_internal_has_joint_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SetJointPosition::has_joint_name() const {
  return _internal_has_joint_name();
}
inline void SetJointPosition::clear_joint_name() {
  joint_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SetJointPosition::joint_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
  return _internal_joint_name();
}
inline void SetJointPosition::set_joint_name(const std::string& value) {
  _internal_set_joint_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
}
inline std::string* SetJointPosition::mutable_joint_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
  return _internal_mutable_joint_name();
}
inline const std::string& SetJointPosition::_internal_joint_name() const {
  return joint_name_.Get();
}
inline void SetJointPosition::_internal_set_joint_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  joint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetJointPosition::set_joint_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  joint_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
}
inline void SetJointPosition::set_joint_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  joint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
}
inline void SetJointPosition::set_joint_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  joint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
}
inline std::string* SetJointPosition::_internal_mutable_joint_name() {
  _has_bits_[0] |= 0x00000002u;
  return joint_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetJointPosition::release_joint_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
  if (!_internal_has_joint_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return joint_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetJointPosition::set_allocated_joint_name(std::string* joint_name) {
  if (joint_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  joint_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), joint_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
}
inline std::string* SetJointPosition::unsafe_arena_release_joint_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return joint_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetJointPosition::unsafe_arena_set_allocated_joint_name(
    std::string* joint_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (joint_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  joint_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      joint_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
}

// required uint32 index = 3;
inline bool SetJointPosition::_internal_has_index() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SetJointPosition::has_index() const {
  return _internal_has_index();
}
inline void SetJointPosition::clear_index() {
  index_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SetJointPosition::_internal_index() const {
  return index_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SetJointPosition::index() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointPosition.index)
  return _internal_index();
}
inline void SetJointPosition::_internal_set_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  index_ = value;
}
inline void SetJointPosition::set_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointPosition.index)
}

// required double position = 4;
inline bool SetJointPosition::_internal_has_position() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SetJointPosition::has_position() const {
  return _internal_has_position();
}
inline void SetJointPosition::clear_position() {
  position_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double SetJointPosition::_internal_position() const {
  return position_;
}
inline double SetJointPosition::position() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointPosition.position)
  return _internal_position();
}
inline void SetJointPosition::_internal_set_position(double value) {
  _has_bits_[0] |= 0x00000008u;
  position_ = value;
}
inline void SetJointPosition::set_position(double value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointPosition.position)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 5;
inline bool SetJointPosition::_internal_has_duration() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || duration_ != nullptr);
  return value;
}
inline bool SetJointPosition::has_duration() const {
  return _internal_has_duration();
}
inline void SetJointPosition::clear_duration() {
  if (duration_ != nullptr) duration_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mw::internal::robotics::gazebotransport::Time& SetJointPosition::_internal_duration() const {
  const ::mw::internal::robotics::gazebotransport::Time* p = duration_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Time*>(
      &::mw::internal::robotics::gazebotransport::_Time_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Time& SetJointPosition::duration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointPosition.duration)
  return _internal_duration();
}
inline void SetJointPosition::unsafe_arena_set_allocated_duration(
    ::mw::internal::robotics::gazebotransport::Time* duration) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration_);
  }
  duration_ = duration;
  if (duration) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.SetJointPosition.duration)
}
inline ::mw::internal::robotics::gazebotransport::Time* SetJointPosition::release_duration() {
  auto temp = unsafe_arena_release_duration();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetJointPosition::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetJointPosition.duration)
  _has_bits_[0] &= ~0x00000004u;
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetJointPosition::_internal_mutable_duration() {
  _has_bits_[0] |= 0x00000004u;
  if (duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Time>(GetArena());
    duration_ = p;
  }
  return duration_;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetJointPosition::mutable_duration() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetJointPosition.duration)
  return _internal_mutable_duration();
}
inline void SetJointPosition::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete duration_;
  }
  if (duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(duration);
    if (message_arena != submessage_arena) {
      duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetJointPosition.duration)
}

// -------------------------------------------------------------------

// SetJointVelocity

// required string model_name = 1;
inline bool SetJointVelocity::_internal_has_model_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetJointVelocity::has_model_name() const {
  return _internal_has_model_name();
}
inline void SetJointVelocity::clear_model_name() {
  model_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SetJointVelocity::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
  return _internal_model_name();
}
inline void SetJointVelocity::set_model_name(const std::string& value) {
  _internal_set_model_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
}
inline std::string* SetJointVelocity::mutable_model_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
  return _internal_mutable_model_name();
}
inline const std::string& SetJointVelocity::_internal_model_name() const {
  return model_name_.Get();
}
inline void SetJointVelocity::_internal_set_model_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetJointVelocity::set_model_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
}
inline void SetJointVelocity::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
}
inline void SetJointVelocity::set_model_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
}
inline std::string* SetJointVelocity::_internal_mutable_model_name() {
  _has_bits_[0] |= 0x00000001u;
  return model_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetJointVelocity::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
  if (!_internal_has_model_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetJointVelocity::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
}
inline std::string* SetJointVelocity::unsafe_arena_release_model_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetJointVelocity::unsafe_arena_set_allocated_model_name(
    std::string* model_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      model_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
}

// required string joint_name = 2;
inline bool SetJointVelocity::_internal_has_joint_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SetJointVelocity::has_joint_name() const {
  return _internal_has_joint_name();
}
inline void SetJointVelocity::clear_joint_name() {
  joint_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SetJointVelocity::joint_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
  return _internal_joint_name();
}
inline void SetJointVelocity::set_joint_name(const std::string& value) {
  _internal_set_joint_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
}
inline std::string* SetJointVelocity::mutable_joint_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
  return _internal_mutable_joint_name();
}
inline const std::string& SetJointVelocity::_internal_joint_name() const {
  return joint_name_.Get();
}
inline void SetJointVelocity::_internal_set_joint_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  joint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetJointVelocity::set_joint_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  joint_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
}
inline void SetJointVelocity::set_joint_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  joint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
}
inline void SetJointVelocity::set_joint_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  joint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
}
inline std::string* SetJointVelocity::_internal_mutable_joint_name() {
  _has_bits_[0] |= 0x00000002u;
  return joint_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetJointVelocity::release_joint_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
  if (!_internal_has_joint_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return joint_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetJointVelocity::set_allocated_joint_name(std::string* joint_name) {
  if (joint_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  joint_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), joint_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
}
inline std::string* SetJointVelocity::unsafe_arena_release_joint_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return joint_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetJointVelocity::unsafe_arena_set_allocated_joint_name(
    std::string* joint_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (joint_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  joint_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      joint_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
}

// required uint32 index = 3;
inline bool SetJointVelocity::_internal_has_index() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SetJointVelocity::has_index() const {
  return _internal_has_index();
}
inline void SetJointVelocity::clear_index() {
  index_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SetJointVelocity::_internal_index() const {
  return index_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SetJointVelocity::index() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointVelocity.index)
  return _internal_index();
}
inline void SetJointVelocity::_internal_set_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  index_ = value;
}
inline void SetJointVelocity::set_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointVelocity.index)
}

// required double velocity = 4;
inline bool SetJointVelocity::_internal_has_velocity() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SetJointVelocity::has_velocity() const {
  return _internal_has_velocity();
}
inline void SetJointVelocity::clear_velocity() {
  velocity_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double SetJointVelocity::_internal_velocity() const {
  return velocity_;
}
inline double SetJointVelocity::velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointVelocity.velocity)
  return _internal_velocity();
}
inline void SetJointVelocity::_internal_set_velocity(double value) {
  _has_bits_[0] |= 0x00000008u;
  velocity_ = value;
}
inline void SetJointVelocity::set_velocity(double value) {
  _internal_set_velocity(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointVelocity.velocity)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 5;
inline bool SetJointVelocity::_internal_has_duration() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || duration_ != nullptr);
  return value;
}
inline bool SetJointVelocity::has_duration() const {
  return _internal_has_duration();
}
inline void SetJointVelocity::clear_duration() {
  if (duration_ != nullptr) duration_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mw::internal::robotics::gazebotransport::Time& SetJointVelocity::_internal_duration() const {
  const ::mw::internal::robotics::gazebotransport::Time* p = duration_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Time*>(
      &::mw::internal::robotics::gazebotransport::_Time_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Time& SetJointVelocity::duration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointVelocity.duration)
  return _internal_duration();
}
inline void SetJointVelocity::unsafe_arena_set_allocated_duration(
    ::mw::internal::robotics::gazebotransport::Time* duration) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration_);
  }
  duration_ = duration;
  if (duration) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.SetJointVelocity.duration)
}
inline ::mw::internal::robotics::gazebotransport::Time* SetJointVelocity::release_duration() {
  auto temp = unsafe_arena_release_duration();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetJointVelocity::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetJointVelocity.duration)
  _has_bits_[0] &= ~0x00000004u;
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetJointVelocity::_internal_mutable_duration() {
  _has_bits_[0] |= 0x00000004u;
  if (duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Time>(GetArena());
    duration_ = p;
  }
  return duration_;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetJointVelocity::mutable_duration() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetJointVelocity.duration)
  return _internal_mutable_duration();
}
inline void SetJointVelocity::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete duration_;
  }
  if (duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(duration);
    if (message_arena != submessage_arena) {
      duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetJointVelocity.duration)
}

// -------------------------------------------------------------------

// GetJointState

// required string model_name = 1;
inline bool GetJointState::_internal_has_model_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetJointState::has_model_name() const {
  return _internal_has_model_name();
}
inline void GetJointState::clear_model_name() {
  model_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetJointState::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetJointState.model_name)
  return _internal_model_name();
}
inline void GetJointState::set_model_name(const std::string& value) {
  _internal_set_model_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetJointState.model_name)
}
inline std::string* GetJointState::mutable_model_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetJointState.model_name)
  return _internal_mutable_model_name();
}
inline const std::string& GetJointState::_internal_model_name() const {
  return model_name_.Get();
}
inline void GetJointState::_internal_set_model_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetJointState::set_model_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.GetJointState.model_name)
}
inline void GetJointState::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetJointState.model_name)
}
inline void GetJointState::set_model_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetJointState.model_name)
}
inline std::string* GetJointState::_internal_mutable_model_name() {
  _has_bits_[0] |= 0x00000001u;
  return model_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetJointState::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetJointState.model_name)
  if (!_internal_has_model_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetJointState::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetJointState.model_name)
}
inline std::string* GetJointState::unsafe_arena_release_model_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.GetJointState.model_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetJointState::unsafe_arena_set_allocated_model_name(
    std::string* model_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      model_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.GetJointState.model_name)
}

// required string joint_name = 2;
inline bool GetJointState::_internal_has_joint_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetJointState::has_joint_name() const {
  return _internal_has_joint_name();
}
inline void GetJointState::clear_joint_name() {
  joint_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GetJointState::joint_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
  return _internal_joint_name();
}
inline void GetJointState::set_joint_name(const std::string& value) {
  _internal_set_joint_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
}
inline std::string* GetJointState::mutable_joint_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
  return _internal_mutable_joint_name();
}
inline const std::string& GetJointState::_internal_joint_name() const {
  return joint_name_.Get();
}
inline void GetJointState::_internal_set_joint_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  joint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetJointState::set_joint_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  joint_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
}
inline void GetJointState::set_joint_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  joint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
}
inline void GetJointState::set_joint_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  joint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
}
inline std::string* GetJointState::_internal_mutable_joint_name() {
  _has_bits_[0] |= 0x00000002u;
  return joint_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetJointState::release_joint_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
  if (!_internal_has_joint_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return joint_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetJointState::set_allocated_joint_name(std::string* joint_name) {
  if (joint_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  joint_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), joint_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
}
inline std::string* GetJointState::unsafe_arena_release_joint_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return joint_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetJointState::unsafe_arena_set_allocated_joint_name(
    std::string* joint_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (joint_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  joint_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      joint_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
}

// -------------------------------------------------------------------

// Axis

// required .mw.internal.robotics.gazebotransport.Point xyz = 1;
inline bool Axis::_internal_has_xyz() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || xyz_ != nullptr);
  return value;
}
inline bool Axis::has_xyz() const {
  return _internal_has_xyz();
}
inline void Axis::clear_xyz() {
  if (xyz_ != nullptr) xyz_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mw::internal::robotics::gazebotransport::Point& Axis::_internal_xyz() const {
  const ::mw::internal::robotics::gazebotransport::Point* p = xyz_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Point*>(
      &::mw::internal::robotics::gazebotransport::_Point_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Point& Axis::xyz() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.xyz)
  return _internal_xyz();
}
inline void Axis::unsafe_arena_set_allocated_xyz(
    ::mw::internal::robotics::gazebotransport::Point* xyz) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(xyz_);
  }
  xyz_ = xyz;
  if (xyz) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Axis.xyz)
}
inline ::mw::internal::robotics::gazebotransport::Point* Axis::release_xyz() {
  auto temp = unsafe_arena_release_xyz();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* Axis::unsafe_arena_release_xyz() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Axis.xyz)
  _has_bits_[0] &= ~0x00000001u;
  ::mw::internal::robotics::gazebotransport::Point* temp = xyz_;
  xyz_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* Axis::_internal_mutable_xyz() {
  _has_bits_[0] |= 0x00000001u;
  if (xyz_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Point>(GetArena());
    xyz_ = p;
  }
  return xyz_;
}
inline ::mw::internal::robotics::gazebotransport::Point* Axis::mutable_xyz() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Axis.xyz)
  return _internal_mutable_xyz();
}
inline void Axis::set_allocated_xyz(::mw::internal::robotics::gazebotransport::Point* xyz) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete xyz_;
  }
  if (xyz) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(xyz);
    if (message_arena != submessage_arena) {
      xyz = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, xyz, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  xyz_ = xyz;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Axis.xyz)
}

// required double limit_lower = 2;
inline bool Axis::_internal_has_limit_lower() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Axis::has_limit_lower() const {
  return _internal_has_limit_lower();
}
inline void Axis::clear_limit_lower() {
  limit_lower_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Axis::_internal_limit_lower() const {
  return limit_lower_;
}
inline double Axis::limit_lower() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.limit_lower)
  return _internal_limit_lower();
}
inline void Axis::_internal_set_limit_lower(double value) {
  _has_bits_[0] |= 0x00000002u;
  limit_lower_ = value;
}
inline void Axis::set_limit_lower(double value) {
  _internal_set_limit_lower(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.limit_lower)
}

// required double limit_upper = 3;
inline bool Axis::_internal_has_limit_upper() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Axis::has_limit_upper() const {
  return _internal_has_limit_upper();
}
inline void Axis::clear_limit_upper() {
  limit_upper_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double Axis::_internal_limit_upper() const {
  return limit_upper_;
}
inline double Axis::limit_upper() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.limit_upper)
  return _internal_limit_upper();
}
inline void Axis::_internal_set_limit_upper(double value) {
  _has_bits_[0] |= 0x00000004u;
  limit_upper_ = value;
}
inline void Axis::set_limit_upper(double value) {
  _internal_set_limit_upper(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.limit_upper)
}

// required double limit_effort = 4;
inline bool Axis::_internal_has_limit_effort() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Axis::has_limit_effort() const {
  return _internal_has_limit_effort();
}
inline void Axis::clear_limit_effort() {
  limit_effort_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double Axis::_internal_limit_effort() const {
  return limit_effort_;
}
inline double Axis::limit_effort() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.limit_effort)
  return _internal_limit_effort();
}
inline void Axis::_internal_set_limit_effort(double value) {
  _has_bits_[0] |= 0x00000008u;
  limit_effort_ = value;
}
inline void Axis::set_limit_effort(double value) {
  _internal_set_limit_effort(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.limit_effort)
}

// required double limit_velocity = 5;
inline bool Axis::_internal_has_limit_velocity() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Axis::has_limit_velocity() const {
  return _internal_has_limit_velocity();
}
inline void Axis::clear_limit_velocity() {
  limit_velocity_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double Axis::_internal_limit_velocity() const {
  return limit_velocity_;
}
inline double Axis::limit_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.limit_velocity)
  return _internal_limit_velocity();
}
inline void Axis::_internal_set_limit_velocity(double value) {
  _has_bits_[0] |= 0x00000010u;
  limit_velocity_ = value;
}
inline void Axis::set_limit_velocity(double value) {
  _internal_set_limit_velocity(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.limit_velocity)
}

// required double damping = 6;
inline bool Axis::_internal_has_damping() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Axis::has_damping() const {
  return _internal_has_damping();
}
inline void Axis::clear_damping() {
  damping_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double Axis::_internal_damping() const {
  return damping_;
}
inline double Axis::damping() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.damping)
  return _internal_damping();
}
inline void Axis::_internal_set_damping(double value) {
  _has_bits_[0] |= 0x00000020u;
  damping_ = value;
}
inline void Axis::set_damping(double value) {
  _internal_set_damping(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.damping)
}

// required double friction = 7;
inline bool Axis::_internal_has_friction() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Axis::has_friction() const {
  return _internal_has_friction();
}
inline void Axis::clear_friction() {
  friction_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double Axis::_internal_friction() const {
  return friction_;
}
inline double Axis::friction() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.friction)
  return _internal_friction();
}
inline void Axis::_internal_set_friction(double value) {
  _has_bits_[0] |= 0x00000040u;
  friction_ = value;
}
inline void Axis::set_friction(double value) {
  _internal_set_friction(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.friction)
}

// required bool use_parent_model_frame = 8;
inline bool Axis::_internal_has_use_parent_model_frame() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Axis::has_use_parent_model_frame() const {
  return _internal_has_use_parent_model_frame();
}
inline void Axis::clear_use_parent_model_frame() {
  use_parent_model_frame_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool Axis::_internal_use_parent_model_frame() const {
  return use_parent_model_frame_;
}
inline bool Axis::use_parent_model_frame() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.use_parent_model_frame)
  return _internal_use_parent_model_frame();
}
inline void Axis::_internal_set_use_parent_model_frame(bool value) {
  _has_bits_[0] |= 0x00000080u;
  use_parent_model_frame_ = value;
}
inline void Axis::set_use_parent_model_frame(bool value) {
  _internal_set_use_parent_model_frame(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.use_parent_model_frame)
}

// -------------------------------------------------------------------

// JointState

// required string model_name = 1;
inline bool JointState::_internal_has_model_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool JointState::has_model_name() const {
  return _internal_has_model_name();
}
inline void JointState::clear_model_name() {
  model_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& JointState::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.model_name)
  return _internal_model_name();
}
inline void JointState::set_model_name(const std::string& value) {
  _internal_set_model_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.model_name)
}
inline std::string* JointState::mutable_model_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.model_name)
  return _internal_mutable_model_name();
}
inline const std::string& JointState::_internal_model_name() const {
  return model_name_.Get();
}
inline void JointState::_internal_set_model_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void JointState::set_model_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.JointState.model_name)
}
inline void JointState::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.JointState.model_name)
}
inline void JointState::set_model_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.JointState.model_name)
}
inline std::string* JointState::_internal_mutable_model_name() {
  _has_bits_[0] |= 0x00000001u;
  return model_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* JointState::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.model_name)
  if (!_internal_has_model_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void JointState::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.model_name)
}
inline std::string* JointState::unsafe_arena_release_model_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.JointState.model_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void JointState::unsafe_arena_set_allocated_model_name(
    std::string* model_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      model_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.JointState.model_name)
}

// required string joint_name = 2;
inline bool JointState::_internal_has_joint_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool JointState::has_joint_name() const {
  return _internal_has_joint_name();
}
inline void JointState::clear_joint_name() {
  joint_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& JointState::joint_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.joint_name)
  return _internal_joint_name();
}
inline void JointState::set_joint_name(const std::string& value) {
  _internal_set_joint_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.joint_name)
}
inline std::string* JointState::mutable_joint_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.joint_name)
  return _internal_mutable_joint_name();
}
inline const std::string& JointState::_internal_joint_name() const {
  return joint_name_.Get();
}
inline void JointState::_internal_set_joint_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  joint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void JointState::set_joint_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  joint_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.JointState.joint_name)
}
inline void JointState::set_joint_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  joint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.JointState.joint_name)
}
inline void JointState::set_joint_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  joint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.JointState.joint_name)
}
inline std::string* JointState::_internal_mutable_joint_name() {
  _has_bits_[0] |= 0x00000002u;
  return joint_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* JointState::release_joint_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.joint_name)
  if (!_internal_has_joint_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return joint_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void JointState::set_allocated_joint_name(std::string* joint_name) {
  if (joint_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  joint_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), joint_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.joint_name)
}
inline std::string* JointState::unsafe_arena_release_joint_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.JointState.joint_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return joint_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void JointState::unsafe_arena_set_allocated_joint_name(
    std::string* joint_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (joint_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  joint_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      joint_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.JointState.joint_name)
}

// required uint32 joint_id = 3;
inline bool JointState::_internal_has_joint_id() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool JointState::has_joint_id() const {
  return _internal_has_joint_id();
}
inline void JointState::clear_joint_id() {
  joint_id_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 JointState::_internal_joint_id() const {
  return joint_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 JointState::joint_id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.joint_id)
  return _internal_joint_id();
}
inline void JointState::_internal_set_joint_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  joint_id_ = value;
}
inline void JointState::set_joint_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_joint_id(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.joint_id)
}

// repeated double joint_position = 4;
inline int JointState::_internal_joint_position_size() const {
  return joint_position_.size();
}
inline int JointState::joint_position_size() const {
  return _internal_joint_position_size();
}
inline void JointState::clear_joint_position() {
  joint_position_.Clear();
}
inline double JointState::_internal_joint_position(int index) const {
  return joint_position_.Get(index);
}
inline double JointState::joint_position(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.joint_position)
  return _internal_joint_position(index);
}
inline void JointState::set_joint_position(int index, double value) {
  joint_position_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.joint_position)
}
inline void JointState::_internal_add_joint_position(double value) {
  joint_position_.Add(value);
}
inline void JointState::add_joint_position(double value) {
  _internal_add_joint_position(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.JointState.joint_position)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
JointState::_internal_joint_position() const {
  return joint_position_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
JointState::joint_position() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.JointState.joint_position)
  return _internal_joint_position();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
JointState::_internal_mutable_joint_position() {
  return &joint_position_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
JointState::mutable_joint_position() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.JointState.joint_position)
  return _internal_mutable_joint_position();
}

// repeated double joint_velocity = 5;
inline int JointState::_internal_joint_velocity_size() const {
  return joint_velocity_.size();
}
inline int JointState::joint_velocity_size() const {
  return _internal_joint_velocity_size();
}
inline void JointState::clear_joint_velocity() {
  joint_velocity_.Clear();
}
inline double JointState::_internal_joint_velocity(int index) const {
  return joint_velocity_.Get(index);
}
inline double JointState::joint_velocity(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.joint_velocity)
  return _internal_joint_velocity(index);
}
inline void JointState::set_joint_velocity(int index, double value) {
  joint_velocity_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.joint_velocity)
}
inline void JointState::_internal_add_joint_velocity(double value) {
  joint_velocity_.Add(value);
}
inline void JointState::add_joint_velocity(double value) {
  _internal_add_joint_velocity(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.JointState.joint_velocity)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
JointState::_internal_joint_velocity() const {
  return joint_velocity_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
JointState::joint_velocity() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.JointState.joint_velocity)
  return _internal_joint_velocity();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
JointState::_internal_mutable_joint_velocity() {
  return &joint_velocity_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
JointState::mutable_joint_velocity() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.JointState.joint_velocity)
  return _internal_mutable_joint_velocity();
}

// optional .mw.internal.robotics.gazebotransport.JointState.Joint_Type joint_type = 6;
inline bool JointState::_internal_has_joint_type() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool JointState::has_joint_type() const {
  return _internal_has_joint_type();
}
inline void JointState::clear_joint_type() {
  joint_type_ = 1;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::mw::internal::robotics::gazebotransport::JointState_Joint_Type JointState::_internal_joint_type() const {
  return static_cast< ::mw::internal::robotics::gazebotransport::JointState_Joint_Type >(joint_type_);
}
inline ::mw::internal::robotics::gazebotransport::JointState_Joint_Type JointState::joint_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.joint_type)
  return _internal_joint_type();
}
inline void JointState::_internal_set_joint_type(::mw::internal::robotics::gazebotransport::JointState_Joint_Type value) {
  assert(::mw::internal::robotics::gazebotransport::JointState_Joint_Type_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  joint_type_ = value;
}
inline void JointState::set_joint_type(::mw::internal::robotics::gazebotransport::JointState_Joint_Type value) {
  _internal_set_joint_type(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.joint_type)
}

// optional string parent_name = 7;
inline bool JointState::_internal_has_parent_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool JointState::has_parent_name() const {
  return _internal_has_parent_name();
}
inline void JointState::clear_parent_name() {
  parent_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& JointState::parent_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.parent_name)
  return _internal_parent_name();
}
inline void JointState::set_parent_name(const std::string& value) {
  _internal_set_parent_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.parent_name)
}
inline std::string* JointState::mutable_parent_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.parent_name)
  return _internal_mutable_parent_name();
}
inline const std::string& JointState::_internal_parent_name() const {
  return parent_name_.Get();
}
inline void JointState::_internal_set_parent_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  parent_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void JointState::set_parent_name(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  parent_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.JointState.parent_name)
}
inline void JointState::set_parent_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  parent_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.JointState.parent_name)
}
inline void JointState::set_parent_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  parent_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.JointState.parent_name)
}
inline std::string* JointState::_internal_mutable_parent_name() {
  _has_bits_[0] |= 0x00000004u;
  return parent_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* JointState::release_parent_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.parent_name)
  if (!_internal_has_parent_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return parent_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void JointState::set_allocated_parent_name(std::string* parent_name) {
  if (parent_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  parent_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parent_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.parent_name)
}
inline std::string* JointState::unsafe_arena_release_parent_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.JointState.parent_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return parent_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void JointState::unsafe_arena_set_allocated_parent_name(
    std::string* parent_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (parent_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  parent_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      parent_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.JointState.parent_name)
}

// optional uint32 parent_id = 8;
inline bool JointState::_internal_has_parent_id() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool JointState::has_parent_id() const {
  return _internal_has_parent_id();
}
inline void JointState::clear_parent_id() {
  parent_id_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 JointState::_internal_parent_id() const {
  return parent_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 JointState::parent_id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.parent_id)
  return _internal_parent_id();
}
inline void JointState::_internal_set_parent_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  parent_id_ = value;
}
inline void JointState::set_parent_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_parent_id(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.parent_id)
}

// optional string child_name = 9;
inline bool JointState::_internal_has_child_name() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool JointState::has_child_name() const {
  return _internal_has_child_name();
}
inline void JointState::clear_child_name() {
  child_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& JointState::child_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.child_name)
  return _internal_child_name();
}
inline void JointState::set_child_name(const std::string& value) {
  _internal_set_child_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.child_name)
}
inline std::string* JointState::mutable_child_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.child_name)
  return _internal_mutable_child_name();
}
inline const std::string& JointState::_internal_child_name() const {
  return child_name_.Get();
}
inline void JointState::_internal_set_child_name(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  child_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void JointState::set_child_name(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  child_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.JointState.child_name)
}
inline void JointState::set_child_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  child_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.JointState.child_name)
}
inline void JointState::set_child_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  child_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.JointState.child_name)
}
inline std::string* JointState::_internal_mutable_child_name() {
  _has_bits_[0] |= 0x00000008u;
  return child_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* JointState::release_child_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.child_name)
  if (!_internal_has_child_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return child_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void JointState::set_allocated_child_name(std::string* child_name) {
  if (child_name != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  child_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), child_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.child_name)
}
inline std::string* JointState::unsafe_arena_release_child_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.JointState.child_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000008u;
  return child_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void JointState::unsafe_arena_set_allocated_child_name(
    std::string* child_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (child_name != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  child_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      child_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.JointState.child_name)
}

// optional uint32 child_id = 10;
inline bool JointState::_internal_has_child_id() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool JointState::has_child_id() const {
  return _internal_has_child_id();
}
inline void JointState::clear_child_id() {
  child_id_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 JointState::_internal_child_id() const {
  return child_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 JointState::child_id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.child_id)
  return _internal_child_id();
}
inline void JointState::_internal_set_child_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  child_id_ = value;
}
inline void JointState::set_child_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_child_id(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.child_id)
}

// optional .mw.internal.robotics.gazebotransport.Pose initial_anchor_pose = 11;
inline bool JointState::_internal_has_initial_anchor_pose() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || initial_anchor_pose_ != nullptr);
  return value;
}
inline bool JointState::has_initial_anchor_pose() const {
  return _internal_has_initial_anchor_pose();
}
inline void JointState::clear_initial_anchor_pose() {
  if (initial_anchor_pose_ != nullptr) initial_anchor_pose_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::mw::internal::robotics::gazebotransport::Pose& JointState::_internal_initial_anchor_pose() const {
  const ::mw::internal::robotics::gazebotransport::Pose* p = initial_anchor_pose_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Pose*>(
      &::mw::internal::robotics::gazebotransport::_Pose_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Pose& JointState::initial_anchor_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.initial_anchor_pose)
  return _internal_initial_anchor_pose();
}
inline void JointState::unsafe_arena_set_allocated_initial_anchor_pose(
    ::mw::internal::robotics::gazebotransport::Pose* initial_anchor_pose) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(initial_anchor_pose_);
  }
  initial_anchor_pose_ = initial_anchor_pose;
  if (initial_anchor_pose) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.JointState.initial_anchor_pose)
}
inline ::mw::internal::robotics::gazebotransport::Pose* JointState::release_initial_anchor_pose() {
  auto temp = unsafe_arena_release_initial_anchor_pose();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Pose* JointState::unsafe_arena_release_initial_anchor_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.initial_anchor_pose)
  _has_bits_[0] &= ~0x00000010u;
  ::mw::internal::robotics::gazebotransport::Pose* temp = initial_anchor_pose_;
  initial_anchor_pose_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Pose* JointState::_internal_mutable_initial_anchor_pose() {
  _has_bits_[0] |= 0x00000010u;
  if (initial_anchor_pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Pose>(GetArena());
    initial_anchor_pose_ = p;
  }
  return initial_anchor_pose_;
}
inline ::mw::internal::robotics::gazebotransport::Pose* JointState::mutable_initial_anchor_pose() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.initial_anchor_pose)
  return _internal_mutable_initial_anchor_pose();
}
inline void JointState::set_allocated_initial_anchor_pose(::mw::internal::robotics::gazebotransport::Pose* initial_anchor_pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete initial_anchor_pose_;
  }
  if (initial_anchor_pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(initial_anchor_pose);
    if (message_arena != submessage_arena) {
      initial_anchor_pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initial_anchor_pose, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  initial_anchor_pose_ = initial_anchor_pose;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.initial_anchor_pose)
}

// optional .mw.internal.robotics.gazebotransport.Pose world_pose = 12;
inline bool JointState::_internal_has_world_pose() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || world_pose_ != nullptr);
  return value;
}
inline bool JointState::has_world_pose() const {
  return _internal_has_world_pose();
}
inline void JointState::clear_world_pose() {
  if (world_pose_ != nullptr) world_pose_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::mw::internal::robotics::gazebotransport::Pose& JointState::_internal_world_pose() const {
  const ::mw::internal::robotics::gazebotransport::Pose* p = world_pose_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Pose*>(
      &::mw::internal::robotics::gazebotransport::_Pose_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Pose& JointState::world_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.world_pose)
  return _internal_world_pose();
}
inline void JointState::unsafe_arena_set_allocated_world_pose(
    ::mw::internal::robotics::gazebotransport::Pose* world_pose) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(world_pose_);
  }
  world_pose_ = world_pose;
  if (world_pose) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.JointState.world_pose)
}
inline ::mw::internal::robotics::gazebotransport::Pose* JointState::release_world_pose() {
  auto temp = unsafe_arena_release_world_pose();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Pose* JointState::unsafe_arena_release_world_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.world_pose)
  _has_bits_[0] &= ~0x00000020u;
  ::mw::internal::robotics::gazebotransport::Pose* temp = world_pose_;
  world_pose_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Pose* JointState::_internal_mutable_world_pose() {
  _has_bits_[0] |= 0x00000020u;
  if (world_pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Pose>(GetArena());
    world_pose_ = p;
  }
  return world_pose_;
}
inline ::mw::internal::robotics::gazebotransport::Pose* JointState::mutable_world_pose() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.world_pose)
  return _internal_mutable_world_pose();
}
inline void JointState::set_allocated_world_pose(::mw::internal::robotics::gazebotransport::Pose* world_pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete world_pose_;
  }
  if (world_pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(world_pose);
    if (message_arena != submessage_arena) {
      world_pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, world_pose, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  world_pose_ = world_pose;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.world_pose)
}

// optional .mw.internal.robotics.gazebotransport.Pose parent_world_pose = 13;
inline bool JointState::_internal_has_parent_world_pose() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || parent_world_pose_ != nullptr);
  return value;
}
inline bool JointState::has_parent_world_pose() const {
  return _internal_has_parent_world_pose();
}
inline void JointState::clear_parent_world_pose() {
  if (parent_world_pose_ != nullptr) parent_world_pose_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::mw::internal::robotics::gazebotransport::Pose& JointState::_internal_parent_world_pose() const {
  const ::mw::internal::robotics::gazebotransport::Pose* p = parent_world_pose_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Pose*>(
      &::mw::internal::robotics::gazebotransport::_Pose_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Pose& JointState::parent_world_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.parent_world_pose)
  return _internal_parent_world_pose();
}
inline void JointState::unsafe_arena_set_allocated_parent_world_pose(
    ::mw::internal::robotics::gazebotransport::Pose* parent_world_pose) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_world_pose_);
  }
  parent_world_pose_ = parent_world_pose;
  if (parent_world_pose) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.JointState.parent_world_pose)
}
inline ::mw::internal::robotics::gazebotransport::Pose* JointState::release_parent_world_pose() {
  auto temp = unsafe_arena_release_parent_world_pose();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Pose* JointState::unsafe_arena_release_parent_world_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.parent_world_pose)
  _has_bits_[0] &= ~0x00000040u;
  ::mw::internal::robotics::gazebotransport::Pose* temp = parent_world_pose_;
  parent_world_pose_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Pose* JointState::_internal_mutable_parent_world_pose() {
  _has_bits_[0] |= 0x00000040u;
  if (parent_world_pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Pose>(GetArena());
    parent_world_pose_ = p;
  }
  return parent_world_pose_;
}
inline ::mw::internal::robotics::gazebotransport::Pose* JointState::mutable_parent_world_pose() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.parent_world_pose)
  return _internal_mutable_parent_world_pose();
}
inline void JointState::set_allocated_parent_world_pose(::mw::internal::robotics::gazebotransport::Pose* parent_world_pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete parent_world_pose_;
  }
  if (parent_world_pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(parent_world_pose);
    if (message_arena != submessage_arena) {
      parent_world_pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent_world_pose, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  parent_world_pose_ = parent_world_pose;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.parent_world_pose)
}

// repeated .mw.internal.robotics.gazebotransport.Axis axis = 14;
inline int JointState::_internal_axis_size() const {
  return axis_.size();
}
inline int JointState::axis_size() const {
  return _internal_axis_size();
}
inline void JointState::clear_axis() {
  axis_.Clear();
}
inline ::mw::internal::robotics::gazebotransport::Axis* JointState::mutable_axis(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.axis)
  return axis_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::Axis >*
JointState::mutable_axis() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.JointState.axis)
  return &axis_;
}
inline const ::mw::internal::robotics::gazebotransport::Axis& JointState::_internal_axis(int index) const {
  return axis_.Get(index);
}
inline const ::mw::internal::robotics::gazebotransport::Axis& JointState::axis(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.axis)
  return _internal_axis(index);
}
inline ::mw::internal::robotics::gazebotransport::Axis* JointState::_internal_add_axis() {
  return axis_.Add();
}
inline ::mw::internal::robotics::gazebotransport::Axis* JointState::add_axis() {
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.JointState.axis)
  return _internal_add_axis();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::Axis >&
JointState::axis() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.JointState.axis)
  return axis_;
}

// -------------------------------------------------------------------

// SetLinkWorldPose

// required string model_name = 1;
inline bool SetLinkWorldPose::_internal_has_model_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetLinkWorldPose::has_model_name() const {
  return _internal_has_model_name();
}
inline void SetLinkWorldPose::clear_model_name() {
  model_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SetLinkWorldPose::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
  return _internal_model_name();
}
inline void SetLinkWorldPose::set_model_name(const std::string& value) {
  _internal_set_model_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
}
inline std::string* SetLinkWorldPose::mutable_model_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
  return _internal_mutable_model_name();
}
inline const std::string& SetLinkWorldPose::_internal_model_name() const {
  return model_name_.Get();
}
inline void SetLinkWorldPose::_internal_set_model_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetLinkWorldPose::set_model_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
}
inline void SetLinkWorldPose::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
}
inline void SetLinkWorldPose::set_model_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
}
inline std::string* SetLinkWorldPose::_internal_mutable_model_name() {
  _has_bits_[0] |= 0x00000001u;
  return model_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetLinkWorldPose::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
  if (!_internal_has_model_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetLinkWorldPose::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
}
inline std::string* SetLinkWorldPose::unsafe_arena_release_model_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetLinkWorldPose::unsafe_arena_set_allocated_model_name(
    std::string* model_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      model_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
}

// required string link_name = 2;
inline bool SetLinkWorldPose::_internal_has_link_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SetLinkWorldPose::has_link_name() const {
  return _internal_has_link_name();
}
inline void SetLinkWorldPose::clear_link_name() {
  link_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SetLinkWorldPose::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
  return _internal_link_name();
}
inline void SetLinkWorldPose::set_link_name(const std::string& value) {
  _internal_set_link_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
}
inline std::string* SetLinkWorldPose::mutable_link_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
  return _internal_mutable_link_name();
}
inline const std::string& SetLinkWorldPose::_internal_link_name() const {
  return link_name_.Get();
}
inline void SetLinkWorldPose::_internal_set_link_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetLinkWorldPose::set_link_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
}
inline void SetLinkWorldPose::set_link_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
}
inline void SetLinkWorldPose::set_link_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
}
inline std::string* SetLinkWorldPose::_internal_mutable_link_name() {
  _has_bits_[0] |= 0x00000002u;
  return link_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetLinkWorldPose::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
  if (!_internal_has_link_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return link_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetLinkWorldPose::set_allocated_link_name(std::string* link_name) {
  if (link_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  link_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), link_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
}
inline std::string* SetLinkWorldPose::unsafe_arena_release_link_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return link_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetLinkWorldPose::unsafe_arena_set_allocated_link_name(
    std::string* link_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (link_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  link_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      link_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
}

// required .mw.internal.robotics.gazebotransport.Pose pose = 3;
inline bool SetLinkWorldPose::_internal_has_pose() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || pose_ != nullptr);
  return value;
}
inline bool SetLinkWorldPose::has_pose() const {
  return _internal_has_pose();
}
inline void SetLinkWorldPose::clear_pose() {
  if (pose_ != nullptr) pose_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mw::internal::robotics::gazebotransport::Pose& SetLinkWorldPose::_internal_pose() const {
  const ::mw::internal::robotics::gazebotransport::Pose* p = pose_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Pose*>(
      &::mw::internal::robotics::gazebotransport::_Pose_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Pose& SetLinkWorldPose::pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkWorldPose.pose)
  return _internal_pose();
}
inline void SetLinkWorldPose::unsafe_arena_set_allocated_pose(
    ::mw::internal::robotics::gazebotransport::Pose* pose) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  pose_ = pose;
  if (pose) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.SetLinkWorldPose.pose)
}
inline ::mw::internal::robotics::gazebotransport::Pose* SetLinkWorldPose::release_pose() {
  auto temp = unsafe_arena_release_pose();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Pose* SetLinkWorldPose::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkWorldPose.pose)
  _has_bits_[0] &= ~0x00000004u;
  ::mw::internal::robotics::gazebotransport::Pose* temp = pose_;
  pose_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Pose* SetLinkWorldPose::_internal_mutable_pose() {
  _has_bits_[0] |= 0x00000004u;
  if (pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Pose>(GetArena());
    pose_ = p;
  }
  return pose_;
}
inline ::mw::internal::robotics::gazebotransport::Pose* SetLinkWorldPose::mutable_pose() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkWorldPose.pose)
  return _internal_mutable_pose();
}
inline void SetLinkWorldPose::set_allocated_pose(::mw::internal::robotics::gazebotransport::Pose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pose_;
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pose);
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkWorldPose.pose)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 4;
inline bool SetLinkWorldPose::_internal_has_duration() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || duration_ != nullptr);
  return value;
}
inline bool SetLinkWorldPose::has_duration() const {
  return _internal_has_duration();
}
inline void SetLinkWorldPose::clear_duration() {
  if (duration_ != nullptr) duration_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::mw::internal::robotics::gazebotransport::Time& SetLinkWorldPose::_internal_duration() const {
  const ::mw::internal::robotics::gazebotransport::Time* p = duration_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Time*>(
      &::mw::internal::robotics::gazebotransport::_Time_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Time& SetLinkWorldPose::duration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkWorldPose.duration)
  return _internal_duration();
}
inline void SetLinkWorldPose::unsafe_arena_set_allocated_duration(
    ::mw::internal::robotics::gazebotransport::Time* duration) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration_);
  }
  duration_ = duration;
  if (duration) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.SetLinkWorldPose.duration)
}
inline ::mw::internal::robotics::gazebotransport::Time* SetLinkWorldPose::release_duration() {
  auto temp = unsafe_arena_release_duration();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetLinkWorldPose::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkWorldPose.duration)
  _has_bits_[0] &= ~0x00000008u;
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetLinkWorldPose::_internal_mutable_duration() {
  _has_bits_[0] |= 0x00000008u;
  if (duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Time>(GetArena());
    duration_ = p;
  }
  return duration_;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetLinkWorldPose::mutable_duration() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkWorldPose.duration)
  return _internal_mutable_duration();
}
inline void SetLinkWorldPose::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete duration_;
  }
  if (duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(duration);
    if (message_arena != submessage_arena) {
      duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkWorldPose.duration)
}

// -------------------------------------------------------------------

// SetLinkLinearVelocity

// required string model_name = 1;
inline bool SetLinkLinearVelocity::_internal_has_model_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetLinkLinearVelocity::has_model_name() const {
  return _internal_has_model_name();
}
inline void SetLinkLinearVelocity::clear_model_name() {
  model_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SetLinkLinearVelocity::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
  return _internal_model_name();
}
inline void SetLinkLinearVelocity::set_model_name(const std::string& value) {
  _internal_set_model_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
}
inline std::string* SetLinkLinearVelocity::mutable_model_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
  return _internal_mutable_model_name();
}
inline const std::string& SetLinkLinearVelocity::_internal_model_name() const {
  return model_name_.Get();
}
inline void SetLinkLinearVelocity::_internal_set_model_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetLinkLinearVelocity::set_model_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
}
inline void SetLinkLinearVelocity::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
}
inline void SetLinkLinearVelocity::set_model_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
}
inline std::string* SetLinkLinearVelocity::_internal_mutable_model_name() {
  _has_bits_[0] |= 0x00000001u;
  return model_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetLinkLinearVelocity::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
  if (!_internal_has_model_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetLinkLinearVelocity::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
}
inline std::string* SetLinkLinearVelocity::unsafe_arena_release_model_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetLinkLinearVelocity::unsafe_arena_set_allocated_model_name(
    std::string* model_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      model_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
}

// required string link_name = 2;
inline bool SetLinkLinearVelocity::_internal_has_link_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SetLinkLinearVelocity::has_link_name() const {
  return _internal_has_link_name();
}
inline void SetLinkLinearVelocity::clear_link_name() {
  link_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SetLinkLinearVelocity::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
  return _internal_link_name();
}
inline void SetLinkLinearVelocity::set_link_name(const std::string& value) {
  _internal_set_link_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
}
inline std::string* SetLinkLinearVelocity::mutable_link_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
  return _internal_mutable_link_name();
}
inline const std::string& SetLinkLinearVelocity::_internal_link_name() const {
  return link_name_.Get();
}
inline void SetLinkLinearVelocity::_internal_set_link_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetLinkLinearVelocity::set_link_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
}
inline void SetLinkLinearVelocity::set_link_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
}
inline void SetLinkLinearVelocity::set_link_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
}
inline std::string* SetLinkLinearVelocity::_internal_mutable_link_name() {
  _has_bits_[0] |= 0x00000002u;
  return link_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetLinkLinearVelocity::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
  if (!_internal_has_link_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return link_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetLinkLinearVelocity::set_allocated_link_name(std::string* link_name) {
  if (link_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  link_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), link_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
}
inline std::string* SetLinkLinearVelocity::unsafe_arena_release_link_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return link_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetLinkLinearVelocity::unsafe_arena_set_allocated_link_name(
    std::string* link_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (link_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  link_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      link_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
}

// required .mw.internal.robotics.gazebotransport.Point velocity = 3;
inline bool SetLinkLinearVelocity::_internal_has_velocity() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || velocity_ != nullptr);
  return value;
}
inline bool SetLinkLinearVelocity::has_velocity() const {
  return _internal_has_velocity();
}
inline void SetLinkLinearVelocity::clear_velocity() {
  if (velocity_ != nullptr) velocity_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mw::internal::robotics::gazebotransport::Point& SetLinkLinearVelocity::_internal_velocity() const {
  const ::mw::internal::robotics::gazebotransport::Point* p = velocity_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Point*>(
      &::mw::internal::robotics::gazebotransport::_Point_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Point& SetLinkLinearVelocity::velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.velocity)
  return _internal_velocity();
}
inline void SetLinkLinearVelocity::unsafe_arena_set_allocated_velocity(
    ::mw::internal::robotics::gazebotransport::Point* velocity) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_);
  }
  velocity_ = velocity;
  if (velocity) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.velocity)
}
inline ::mw::internal::robotics::gazebotransport::Point* SetLinkLinearVelocity::release_velocity() {
  auto temp = unsafe_arena_release_velocity();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* SetLinkLinearVelocity::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.velocity)
  _has_bits_[0] &= ~0x00000004u;
  ::mw::internal::robotics::gazebotransport::Point* temp = velocity_;
  velocity_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* SetLinkLinearVelocity::_internal_mutable_velocity() {
  _has_bits_[0] |= 0x00000004u;
  if (velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Point>(GetArena());
    velocity_ = p;
  }
  return velocity_;
}
inline ::mw::internal::robotics::gazebotransport::Point* SetLinkLinearVelocity::mutable_velocity() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.velocity)
  return _internal_mutable_velocity();
}
inline void SetLinkLinearVelocity::set_allocated_velocity(::mw::internal::robotics::gazebotransport::Point* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete velocity_;
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(velocity);
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.velocity)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 4;
inline bool SetLinkLinearVelocity::_internal_has_duration() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || duration_ != nullptr);
  return value;
}
inline bool SetLinkLinearVelocity::has_duration() const {
  return _internal_has_duration();
}
inline void SetLinkLinearVelocity::clear_duration() {
  if (duration_ != nullptr) duration_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::mw::internal::robotics::gazebotransport::Time& SetLinkLinearVelocity::_internal_duration() const {
  const ::mw::internal::robotics::gazebotransport::Time* p = duration_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Time*>(
      &::mw::internal::robotics::gazebotransport::_Time_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Time& SetLinkLinearVelocity::duration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.duration)
  return _internal_duration();
}
inline void SetLinkLinearVelocity::unsafe_arena_set_allocated_duration(
    ::mw::internal::robotics::gazebotransport::Time* duration) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration_);
  }
  duration_ = duration;
  if (duration) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.duration)
}
inline ::mw::internal::robotics::gazebotransport::Time* SetLinkLinearVelocity::release_duration() {
  auto temp = unsafe_arena_release_duration();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetLinkLinearVelocity::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.duration)
  _has_bits_[0] &= ~0x00000008u;
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetLinkLinearVelocity::_internal_mutable_duration() {
  _has_bits_[0] |= 0x00000008u;
  if (duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Time>(GetArena());
    duration_ = p;
  }
  return duration_;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetLinkLinearVelocity::mutable_duration() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.duration)
  return _internal_mutable_duration();
}
inline void SetLinkLinearVelocity::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete duration_;
  }
  if (duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(duration);
    if (message_arena != submessage_arena) {
      duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.duration)
}

// -------------------------------------------------------------------

// SetLinkAngularVelocity

// required string model_name = 1;
inline bool SetLinkAngularVelocity::_internal_has_model_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetLinkAngularVelocity::has_model_name() const {
  return _internal_has_model_name();
}
inline void SetLinkAngularVelocity::clear_model_name() {
  model_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SetLinkAngularVelocity::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
  return _internal_model_name();
}
inline void SetLinkAngularVelocity::set_model_name(const std::string& value) {
  _internal_set_model_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
}
inline std::string* SetLinkAngularVelocity::mutable_model_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
  return _internal_mutable_model_name();
}
inline const std::string& SetLinkAngularVelocity::_internal_model_name() const {
  return model_name_.Get();
}
inline void SetLinkAngularVelocity::_internal_set_model_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetLinkAngularVelocity::set_model_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
}
inline void SetLinkAngularVelocity::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
}
inline void SetLinkAngularVelocity::set_model_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
}
inline std::string* SetLinkAngularVelocity::_internal_mutable_model_name() {
  _has_bits_[0] |= 0x00000001u;
  return model_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetLinkAngularVelocity::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
  if (!_internal_has_model_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetLinkAngularVelocity::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
}
inline std::string* SetLinkAngularVelocity::unsafe_arena_release_model_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetLinkAngularVelocity::unsafe_arena_set_allocated_model_name(
    std::string* model_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      model_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
}

// required string link_name = 2;
inline bool SetLinkAngularVelocity::_internal_has_link_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SetLinkAngularVelocity::has_link_name() const {
  return _internal_has_link_name();
}
inline void SetLinkAngularVelocity::clear_link_name() {
  link_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SetLinkAngularVelocity::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
  return _internal_link_name();
}
inline void SetLinkAngularVelocity::set_link_name(const std::string& value) {
  _internal_set_link_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
}
inline std::string* SetLinkAngularVelocity::mutable_link_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
  return _internal_mutable_link_name();
}
inline const std::string& SetLinkAngularVelocity::_internal_link_name() const {
  return link_name_.Get();
}
inline void SetLinkAngularVelocity::_internal_set_link_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetLinkAngularVelocity::set_link_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
}
inline void SetLinkAngularVelocity::set_link_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
}
inline void SetLinkAngularVelocity::set_link_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
}
inline std::string* SetLinkAngularVelocity::_internal_mutable_link_name() {
  _has_bits_[0] |= 0x00000002u;
  return link_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetLinkAngularVelocity::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
  if (!_internal_has_link_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return link_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetLinkAngularVelocity::set_allocated_link_name(std::string* link_name) {
  if (link_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  link_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), link_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
}
inline std::string* SetLinkAngularVelocity::unsafe_arena_release_link_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return link_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetLinkAngularVelocity::unsafe_arena_set_allocated_link_name(
    std::string* link_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (link_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  link_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      link_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
}

// required .mw.internal.robotics.gazebotransport.Point velocity = 3;
inline bool SetLinkAngularVelocity::_internal_has_velocity() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || velocity_ != nullptr);
  return value;
}
inline bool SetLinkAngularVelocity::has_velocity() const {
  return _internal_has_velocity();
}
inline void SetLinkAngularVelocity::clear_velocity() {
  if (velocity_ != nullptr) velocity_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mw::internal::robotics::gazebotransport::Point& SetLinkAngularVelocity::_internal_velocity() const {
  const ::mw::internal::robotics::gazebotransport::Point* p = velocity_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Point*>(
      &::mw::internal::robotics::gazebotransport::_Point_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Point& SetLinkAngularVelocity::velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.velocity)
  return _internal_velocity();
}
inline void SetLinkAngularVelocity::unsafe_arena_set_allocated_velocity(
    ::mw::internal::robotics::gazebotransport::Point* velocity) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_);
  }
  velocity_ = velocity;
  if (velocity) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.velocity)
}
inline ::mw::internal::robotics::gazebotransport::Point* SetLinkAngularVelocity::release_velocity() {
  auto temp = unsafe_arena_release_velocity();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* SetLinkAngularVelocity::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.velocity)
  _has_bits_[0] &= ~0x00000004u;
  ::mw::internal::robotics::gazebotransport::Point* temp = velocity_;
  velocity_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* SetLinkAngularVelocity::_internal_mutable_velocity() {
  _has_bits_[0] |= 0x00000004u;
  if (velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Point>(GetArena());
    velocity_ = p;
  }
  return velocity_;
}
inline ::mw::internal::robotics::gazebotransport::Point* SetLinkAngularVelocity::mutable_velocity() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.velocity)
  return _internal_mutable_velocity();
}
inline void SetLinkAngularVelocity::set_allocated_velocity(::mw::internal::robotics::gazebotransport::Point* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete velocity_;
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(velocity);
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.velocity)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 4;
inline bool SetLinkAngularVelocity::_internal_has_duration() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || duration_ != nullptr);
  return value;
}
inline bool SetLinkAngularVelocity::has_duration() const {
  return _internal_has_duration();
}
inline void SetLinkAngularVelocity::clear_duration() {
  if (duration_ != nullptr) duration_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::mw::internal::robotics::gazebotransport::Time& SetLinkAngularVelocity::_internal_duration() const {
  const ::mw::internal::robotics::gazebotransport::Time* p = duration_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Time*>(
      &::mw::internal::robotics::gazebotransport::_Time_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Time& SetLinkAngularVelocity::duration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.duration)
  return _internal_duration();
}
inline void SetLinkAngularVelocity::unsafe_arena_set_allocated_duration(
    ::mw::internal::robotics::gazebotransport::Time* duration) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration_);
  }
  duration_ = duration;
  if (duration) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.duration)
}
inline ::mw::internal::robotics::gazebotransport::Time* SetLinkAngularVelocity::release_duration() {
  auto temp = unsafe_arena_release_duration();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetLinkAngularVelocity::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.duration)
  _has_bits_[0] &= ~0x00000008u;
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetLinkAngularVelocity::_internal_mutable_duration() {
  _has_bits_[0] |= 0x00000008u;
  if (duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Time>(GetArena());
    duration_ = p;
  }
  return duration_;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetLinkAngularVelocity::mutable_duration() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.duration)
  return _internal_mutable_duration();
}
inline void SetLinkAngularVelocity::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete duration_;
  }
  if (duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(duration);
    if (message_arena != submessage_arena) {
      duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.duration)
}

// -------------------------------------------------------------------

// GetLinkState

// required string model_name = 1;
inline bool GetLinkState::_internal_has_model_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetLinkState::has_model_name() const {
  return _internal_has_model_name();
}
inline void GetLinkState::clear_model_name() {
  model_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetLinkState::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
  return _internal_model_name();
}
inline void GetLinkState::set_model_name(const std::string& value) {
  _internal_set_model_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
}
inline std::string* GetLinkState::mutable_model_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
  return _internal_mutable_model_name();
}
inline const std::string& GetLinkState::_internal_model_name() const {
  return model_name_.Get();
}
inline void GetLinkState::_internal_set_model_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetLinkState::set_model_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
}
inline void GetLinkState::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
}
inline void GetLinkState::set_model_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
}
inline std::string* GetLinkState::_internal_mutable_model_name() {
  _has_bits_[0] |= 0x00000001u;
  return model_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetLinkState::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
  if (!_internal_has_model_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetLinkState::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
}
inline std::string* GetLinkState::unsafe_arena_release_model_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetLinkState::unsafe_arena_set_allocated_model_name(
    std::string* model_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      model_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
}

// required string link_name = 2;
inline bool GetLinkState::_internal_has_link_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetLinkState::has_link_name() const {
  return _internal_has_link_name();
}
inline void GetLinkState::clear_link_name() {
  link_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GetLinkState::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
  return _internal_link_name();
}
inline void GetLinkState::set_link_name(const std::string& value) {
  _internal_set_link_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
}
inline std::string* GetLinkState::mutable_link_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
  return _internal_mutable_link_name();
}
inline const std::string& GetLinkState::_internal_link_name() const {
  return link_name_.Get();
}
inline void GetLinkState::_internal_set_link_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetLinkState::set_link_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
}
inline void GetLinkState::set_link_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
}
inline void GetLinkState::set_link_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
}
inline std::string* GetLinkState::_internal_mutable_link_name() {
  _has_bits_[0] |= 0x00000002u;
  return link_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetLinkState::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
  if (!_internal_has_link_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return link_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetLinkState::set_allocated_link_name(std::string* link_name) {
  if (link_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  link_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), link_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
}
inline std::string* GetLinkState::unsafe_arena_release_link_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return link_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetLinkState::unsafe_arena_set_allocated_link_name(
    std::string* link_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (link_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  link_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      link_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
}

// -------------------------------------------------------------------

// LinkState

// required string model_name = 1;
inline bool LinkState::_internal_has_model_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LinkState::has_model_name() const {
  return _internal_has_model_name();
}
inline void LinkState::clear_model_name() {
  model_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LinkState::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.model_name)
  return _internal_model_name();
}
inline void LinkState::set_model_name(const std::string& value) {
  _internal_set_model_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.model_name)
}
inline std::string* LinkState::mutable_model_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.model_name)
  return _internal_mutable_model_name();
}
inline const std::string& LinkState::_internal_model_name() const {
  return model_name_.Get();
}
inline void LinkState::_internal_set_model_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LinkState::set_model_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.LinkState.model_name)
}
inline void LinkState::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.LinkState.model_name)
}
inline void LinkState::set_model_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.LinkState.model_name)
}
inline std::string* LinkState::_internal_mutable_model_name() {
  _has_bits_[0] |= 0x00000001u;
  return model_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LinkState::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.model_name)
  if (!_internal_has_model_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LinkState::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.model_name)
}
inline std::string* LinkState::unsafe_arena_release_model_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.LinkState.model_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void LinkState::unsafe_arena_set_allocated_model_name(
    std::string* model_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      model_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.LinkState.model_name)
}

// required string link_name = 2;
inline bool LinkState::_internal_has_link_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LinkState::has_link_name() const {
  return _internal_has_link_name();
}
inline void LinkState::clear_link_name() {
  link_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LinkState::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.link_name)
  return _internal_link_name();
}
inline void LinkState::set_link_name(const std::string& value) {
  _internal_set_link_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.link_name)
}
inline std::string* LinkState::mutable_link_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.link_name)
  return _internal_mutable_link_name();
}
inline const std::string& LinkState::_internal_link_name() const {
  return link_name_.Get();
}
inline void LinkState::_internal_set_link_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LinkState::set_link_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.LinkState.link_name)
}
inline void LinkState::set_link_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.LinkState.link_name)
}
inline void LinkState::set_link_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.LinkState.link_name)
}
inline std::string* LinkState::_internal_mutable_link_name() {
  _has_bits_[0] |= 0x00000002u;
  return link_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LinkState::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.link_name)
  if (!_internal_has_link_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return link_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LinkState::set_allocated_link_name(std::string* link_name) {
  if (link_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  link_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), link_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.link_name)
}
inline std::string* LinkState::unsafe_arena_release_link_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.LinkState.link_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return link_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void LinkState::unsafe_arena_set_allocated_link_name(
    std::string* link_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (link_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  link_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      link_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.LinkState.link_name)
}

// required uint32 link_id = 3;
inline bool LinkState::_internal_has_link_id() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool LinkState::has_link_id() const {
  return _internal_has_link_id();
}
inline void LinkState::clear_link_id() {
  link_id_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LinkState::_internal_link_id() const {
  return link_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LinkState::link_id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.link_id)
  return _internal_link_id();
}
inline void LinkState::_internal_set_link_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  link_id_ = value;
}
inline void LinkState::set_link_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_link_id(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.link_id)
}

// required .mw.internal.robotics.gazebotransport.Point world_linear_velocity = 4;
inline bool LinkState::_internal_has_world_linear_velocity() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || world_linear_velocity_ != nullptr);
  return value;
}
inline bool LinkState::has_world_linear_velocity() const {
  return _internal_has_world_linear_velocity();
}
inline void LinkState::clear_world_linear_velocity() {
  if (world_linear_velocity_ != nullptr) world_linear_velocity_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mw::internal::robotics::gazebotransport::Point& LinkState::_internal_world_linear_velocity() const {
  const ::mw::internal::robotics::gazebotransport::Point* p = world_linear_velocity_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Point*>(
      &::mw::internal::robotics::gazebotransport::_Point_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Point& LinkState::world_linear_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.world_linear_velocity)
  return _internal_world_linear_velocity();
}
inline void LinkState::unsafe_arena_set_allocated_world_linear_velocity(
    ::mw::internal::robotics::gazebotransport::Point* world_linear_velocity) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(world_linear_velocity_);
  }
  world_linear_velocity_ = world_linear_velocity;
  if (world_linear_velocity) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.LinkState.world_linear_velocity)
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::release_world_linear_velocity() {
  auto temp = unsafe_arena_release_world_linear_velocity();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::unsafe_arena_release_world_linear_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.world_linear_velocity)
  _has_bits_[0] &= ~0x00000004u;
  ::mw::internal::robotics::gazebotransport::Point* temp = world_linear_velocity_;
  world_linear_velocity_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::_internal_mutable_world_linear_velocity() {
  _has_bits_[0] |= 0x00000004u;
  if (world_linear_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Point>(GetArena());
    world_linear_velocity_ = p;
  }
  return world_linear_velocity_;
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::mutable_world_linear_velocity() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.world_linear_velocity)
  return _internal_mutable_world_linear_velocity();
}
inline void LinkState::set_allocated_world_linear_velocity(::mw::internal::robotics::gazebotransport::Point* world_linear_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete world_linear_velocity_;
  }
  if (world_linear_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(world_linear_velocity);
    if (message_arena != submessage_arena) {
      world_linear_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, world_linear_velocity, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  world_linear_velocity_ = world_linear_velocity;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.world_linear_velocity)
}

// required .mw.internal.robotics.gazebotransport.Point world_angular_velocity = 5;
inline bool LinkState::_internal_has_world_angular_velocity() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || world_angular_velocity_ != nullptr);
  return value;
}
inline bool LinkState::has_world_angular_velocity() const {
  return _internal_has_world_angular_velocity();
}
inline void LinkState::clear_world_angular_velocity() {
  if (world_angular_velocity_ != nullptr) world_angular_velocity_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::mw::internal::robotics::gazebotransport::Point& LinkState::_internal_world_angular_velocity() const {
  const ::mw::internal::robotics::gazebotransport::Point* p = world_angular_velocity_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Point*>(
      &::mw::internal::robotics::gazebotransport::_Point_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Point& LinkState::world_angular_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.world_angular_velocity)
  return _internal_world_angular_velocity();
}
inline void LinkState::unsafe_arena_set_allocated_world_angular_velocity(
    ::mw::internal::robotics::gazebotransport::Point* world_angular_velocity) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(world_angular_velocity_);
  }
  world_angular_velocity_ = world_angular_velocity;
  if (world_angular_velocity) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.LinkState.world_angular_velocity)
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::release_world_angular_velocity() {
  auto temp = unsafe_arena_release_world_angular_velocity();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::unsafe_arena_release_world_angular_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.world_angular_velocity)
  _has_bits_[0] &= ~0x00000008u;
  ::mw::internal::robotics::gazebotransport::Point* temp = world_angular_velocity_;
  world_angular_velocity_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::_internal_mutable_world_angular_velocity() {
  _has_bits_[0] |= 0x00000008u;
  if (world_angular_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Point>(GetArena());
    world_angular_velocity_ = p;
  }
  return world_angular_velocity_;
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::mutable_world_angular_velocity() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.world_angular_velocity)
  return _internal_mutable_world_angular_velocity();
}
inline void LinkState::set_allocated_world_angular_velocity(::mw::internal::robotics::gazebotransport::Point* world_angular_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete world_angular_velocity_;
  }
  if (world_angular_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(world_angular_velocity);
    if (message_arena != submessage_arena) {
      world_angular_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, world_angular_velocity, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  world_angular_velocity_ = world_angular_velocity;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.world_angular_velocity)
}

// required .mw.internal.robotics.gazebotransport.Point relative_linear_velocity = 6;
inline bool LinkState::_internal_has_relative_linear_velocity() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || relative_linear_velocity_ != nullptr);
  return value;
}
inline bool LinkState::has_relative_linear_velocity() const {
  return _internal_has_relative_linear_velocity();
}
inline void LinkState::clear_relative_linear_velocity() {
  if (relative_linear_velocity_ != nullptr) relative_linear_velocity_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::mw::internal::robotics::gazebotransport::Point& LinkState::_internal_relative_linear_velocity() const {
  const ::mw::internal::robotics::gazebotransport::Point* p = relative_linear_velocity_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Point*>(
      &::mw::internal::robotics::gazebotransport::_Point_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Point& LinkState::relative_linear_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.relative_linear_velocity)
  return _internal_relative_linear_velocity();
}
inline void LinkState::unsafe_arena_set_allocated_relative_linear_velocity(
    ::mw::internal::robotics::gazebotransport::Point* relative_linear_velocity) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(relative_linear_velocity_);
  }
  relative_linear_velocity_ = relative_linear_velocity;
  if (relative_linear_velocity) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.LinkState.relative_linear_velocity)
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::release_relative_linear_velocity() {
  auto temp = unsafe_arena_release_relative_linear_velocity();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::unsafe_arena_release_relative_linear_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.relative_linear_velocity)
  _has_bits_[0] &= ~0x00000010u;
  ::mw::internal::robotics::gazebotransport::Point* temp = relative_linear_velocity_;
  relative_linear_velocity_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::_internal_mutable_relative_linear_velocity() {
  _has_bits_[0] |= 0x00000010u;
  if (relative_linear_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Point>(GetArena());
    relative_linear_velocity_ = p;
  }
  return relative_linear_velocity_;
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::mutable_relative_linear_velocity() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.relative_linear_velocity)
  return _internal_mutable_relative_linear_velocity();
}
inline void LinkState::set_allocated_relative_linear_velocity(::mw::internal::robotics::gazebotransport::Point* relative_linear_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete relative_linear_velocity_;
  }
  if (relative_linear_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(relative_linear_velocity);
    if (message_arena != submessage_arena) {
      relative_linear_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, relative_linear_velocity, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  relative_linear_velocity_ = relative_linear_velocity;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.relative_linear_velocity)
}

// required .mw.internal.robotics.gazebotransport.Point relative_angular_velocity = 7;
inline bool LinkState::_internal_has_relative_angular_velocity() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || relative_angular_velocity_ != nullptr);
  return value;
}
inline bool LinkState::has_relative_angular_velocity() const {
  return _internal_has_relative_angular_velocity();
}
inline void LinkState::clear_relative_angular_velocity() {
  if (relative_angular_velocity_ != nullptr) relative_angular_velocity_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::mw::internal::robotics::gazebotransport::Point& LinkState::_internal_relative_angular_velocity() const {
  const ::mw::internal::robotics::gazebotransport::Point* p = relative_angular_velocity_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Point*>(
      &::mw::internal::robotics::gazebotransport::_Point_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Point& LinkState::relative_angular_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.relative_angular_velocity)
  return _internal_relative_angular_velocity();
}
inline void LinkState::unsafe_arena_set_allocated_relative_angular_velocity(
    ::mw::internal::robotics::gazebotransport::Point* relative_angular_velocity) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(relative_angular_velocity_);
  }
  relative_angular_velocity_ = relative_angular_velocity;
  if (relative_angular_velocity) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.LinkState.relative_angular_velocity)
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::release_relative_angular_velocity() {
  auto temp = unsafe_arena_release_relative_angular_velocity();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::unsafe_arena_release_relative_angular_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.relative_angular_velocity)
  _has_bits_[0] &= ~0x00000020u;
  ::mw::internal::robotics::gazebotransport::Point* temp = relative_angular_velocity_;
  relative_angular_velocity_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::_internal_mutable_relative_angular_velocity() {
  _has_bits_[0] |= 0x00000020u;
  if (relative_angular_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Point>(GetArena());
    relative_angular_velocity_ = p;
  }
  return relative_angular_velocity_;
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::mutable_relative_angular_velocity() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.relative_angular_velocity)
  return _internal_mutable_relative_angular_velocity();
}
inline void LinkState::set_allocated_relative_angular_velocity(::mw::internal::robotics::gazebotransport::Point* relative_angular_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete relative_angular_velocity_;
  }
  if (relative_angular_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(relative_angular_velocity);
    if (message_arena != submessage_arena) {
      relative_angular_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, relative_angular_velocity, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  relative_angular_velocity_ = relative_angular_velocity;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.relative_angular_velocity)
}

// optional .mw.internal.robotics.gazebotransport.Pose world_pose = 8;
inline bool LinkState::_internal_has_world_pose() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || world_pose_ != nullptr);
  return value;
}
inline bool LinkState::has_world_pose() const {
  return _internal_has_world_pose();
}
inline void LinkState::clear_world_pose() {
  if (world_pose_ != nullptr) world_pose_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::mw::internal::robotics::gazebotransport::Pose& LinkState::_internal_world_pose() const {
  const ::mw::internal::robotics::gazebotransport::Pose* p = world_pose_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Pose*>(
      &::mw::internal::robotics::gazebotransport::_Pose_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Pose& LinkState::world_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.world_pose)
  return _internal_world_pose();
}
inline void LinkState::unsafe_arena_set_allocated_world_pose(
    ::mw::internal::robotics::gazebotransport::Pose* world_pose) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(world_pose_);
  }
  world_pose_ = world_pose;
  if (world_pose) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.LinkState.world_pose)
}
inline ::mw::internal::robotics::gazebotransport::Pose* LinkState::release_world_pose() {
  auto temp = unsafe_arena_release_world_pose();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Pose* LinkState::unsafe_arena_release_world_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.world_pose)
  _has_bits_[0] &= ~0x00000040u;
  ::mw::internal::robotics::gazebotransport::Pose* temp = world_pose_;
  world_pose_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Pose* LinkState::_internal_mutable_world_pose() {
  _has_bits_[0] |= 0x00000040u;
  if (world_pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Pose>(GetArena());
    world_pose_ = p;
  }
  return world_pose_;
}
inline ::mw::internal::robotics::gazebotransport::Pose* LinkState::mutable_world_pose() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.world_pose)
  return _internal_mutable_world_pose();
}
inline void LinkState::set_allocated_world_pose(::mw::internal::robotics::gazebotransport::Pose* world_pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete world_pose_;
  }
  if (world_pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(world_pose);
    if (message_arena != submessage_arena) {
      world_pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, world_pose, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  world_pose_ = world_pose;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.world_pose)
}

// optional .mw.internal.robotics.gazebotransport.Pose relative_pose = 9;
inline bool LinkState::_internal_has_relative_pose() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || relative_pose_ != nullptr);
  return value;
}
inline bool LinkState::has_relative_pose() const {
  return _internal_has_relative_pose();
}
inline void LinkState::clear_relative_pose() {
  if (relative_pose_ != nullptr) relative_pose_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::mw::internal::robotics::gazebotransport::Pose& LinkState::_internal_relative_pose() const {
  const ::mw::internal::robotics::gazebotransport::Pose* p = relative_pose_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Pose*>(
      &::mw::internal::robotics::gazebotransport::_Pose_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::Pose& LinkState::relative_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.relative_pose)
  return _internal_relative_pose();
}
inline void LinkState::unsafe_arena_set_allocated_relative_pose(
    ::mw::internal::robotics::gazebotransport::Pose* relative_pose) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(relative_pose_);
  }
  relative_pose_ = relative_pose;
  if (relative_pose) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.LinkState.relative_pose)
}
inline ::mw::internal::robotics::gazebotransport::Pose* LinkState::release_relative_pose() {
  auto temp = unsafe_arena_release_relative_pose();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Pose* LinkState::unsafe_arena_release_relative_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.relative_pose)
  _has_bits_[0] &= ~0x00000080u;
  ::mw::internal::robotics::gazebotransport::Pose* temp = relative_pose_;
  relative_pose_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Pose* LinkState::_internal_mutable_relative_pose() {
  _has_bits_[0] |= 0x00000080u;
  if (relative_pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Pose>(GetArena());
    relative_pose_ = p;
  }
  return relative_pose_;
}
inline ::mw::internal::robotics::gazebotransport::Pose* LinkState::mutable_relative_pose() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.relative_pose)
  return _internal_mutable_relative_pose();
}
inline void LinkState::set_allocated_relative_pose(::mw::internal::robotics::gazebotransport::Pose* relative_pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete relative_pose_;
  }
  if (relative_pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(relative_pose);
    if (message_arena != submessage_arena) {
      relative_pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, relative_pose, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  relative_pose_ = relative_pose;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.relative_pose)
}

// optional bool self_collide = 10;
inline bool LinkState::_internal_has_self_collide() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool LinkState::has_self_collide() const {
  return _internal_has_self_collide();
}
inline void LinkState::clear_self_collide() {
  self_collide_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool LinkState::_internal_self_collide() const {
  return self_collide_;
}
inline bool LinkState::self_collide() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.self_collide)
  return _internal_self_collide();
}
inline void LinkState::_internal_set_self_collide(bool value) {
  _has_bits_[0] |= 0x00000200u;
  self_collide_ = value;
}
inline void LinkState::set_self_collide(bool value) {
  _internal_set_self_collide(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.self_collide)
}

// optional bool gravity = 11;
inline bool LinkState::_internal_has_gravity() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool LinkState::has_gravity() const {
  return _internal_has_gravity();
}
inline void LinkState::clear_gravity() {
  gravity_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool LinkState::_internal_gravity() const {
  return gravity_;
}
inline bool LinkState::gravity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.gravity)
  return _internal_gravity();
}
inline void LinkState::_internal_set_gravity(bool value) {
  _has_bits_[0] |= 0x00000400u;
  gravity_ = value;
}
inline void LinkState::set_gravity(bool value) {
  _internal_set_gravity(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.gravity)
}

// optional bool kinematic = 12;
inline bool LinkState::_internal_has_kinematic() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool LinkState::has_kinematic() const {
  return _internal_has_kinematic();
}
inline void LinkState::clear_kinematic() {
  kinematic_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool LinkState::_internal_kinematic() const {
  return kinematic_;
}
inline bool LinkState::kinematic() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.kinematic)
  return _internal_kinematic();
}
inline void LinkState::_internal_set_kinematic(bool value) {
  _has_bits_[0] |= 0x00000800u;
  kinematic_ = value;
}
inline void LinkState::set_kinematic(bool value) {
  _internal_set_kinematic(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.kinematic)
}

// optional bool enable_wind = 13;
inline bool LinkState::_internal_has_enable_wind() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool LinkState::has_enable_wind() const {
  return _internal_has_enable_wind();
}
inline void LinkState::clear_enable_wind() {
  enable_wind_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool LinkState::_internal_enable_wind() const {
  return enable_wind_;
}
inline bool LinkState::enable_wind() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.enable_wind)
  return _internal_enable_wind();
}
inline void LinkState::_internal_set_enable_wind(bool value) {
  _has_bits_[0] |= 0x00001000u;
  enable_wind_ = value;
}
inline void LinkState::set_enable_wind(bool value) {
  _internal_set_enable_wind(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.enable_wind)
}

// optional bool canonical = 14;
inline bool LinkState::_internal_has_canonical() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool LinkState::has_canonical() const {
  return _internal_has_canonical();
}
inline void LinkState::clear_canonical() {
  canonical_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool LinkState::_internal_canonical() const {
  return canonical_;
}
inline bool LinkState::canonical() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.canonical)
  return _internal_canonical();
}
inline void LinkState::_internal_set_canonical(bool value) {
  _has_bits_[0] |= 0x00002000u;
  canonical_ = value;
}
inline void LinkState::set_canonical(bool value) {
  _internal_set_canonical(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.canonical)
}

// -------------------------------------------------------------------

// ML_Cord

// optional double x = 1;
inline bool ML_Cord::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ML_Cord::has_x() const {
  return _internal_has_x();
}
inline void ML_Cord::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double ML_Cord::_internal_x() const {
  return x_;
}
inline double ML_Cord::x() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Cord.x)
  return _internal_x();
}
inline void ML_Cord::_internal_set_x(double value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void ML_Cord::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Cord.x)
}

// optional double y = 2;
inline bool ML_Cord::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ML_Cord::has_y() const {
  return _internal_has_y();
}
inline void ML_Cord::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ML_Cord::_internal_y() const {
  return y_;
}
inline double ML_Cord::y() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Cord.y)
  return _internal_y();
}
inline void ML_Cord::_internal_set_y(double value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void ML_Cord::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Cord.y)
}

// -------------------------------------------------------------------

// ML_Point

// optional double x = 1;
inline bool ML_Point::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ML_Point::has_x() const {
  return _internal_has_x();
}
inline void ML_Point::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double ML_Point::_internal_x() const {
  return x_;
}
inline double ML_Point::x() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Point.x)
  return _internal_x();
}
inline void ML_Point::_internal_set_x(double value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void ML_Point::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Point.x)
}

// optional double y = 2;
inline bool ML_Point::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ML_Point::has_y() const {
  return _internal_has_y();
}
inline void ML_Point::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ML_Point::_internal_y() const {
  return y_;
}
inline double ML_Point::y() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Point.y)
  return _internal_y();
}
inline void ML_Point::_internal_set_y(double value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void ML_Point::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Point.y)
}

// optional double z = 3;
inline bool ML_Point::_internal_has_z() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ML_Point::has_z() const {
  return _internal_has_z();
}
inline void ML_Point::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ML_Point::_internal_z() const {
  return z_;
}
inline double ML_Point::z() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Point.z)
  return _internal_z();
}
inline void ML_Point::_internal_set_z(double value) {
  _has_bits_[0] |= 0x00000004u;
  z_ = value;
}
inline void ML_Point::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Point.z)
}

// -------------------------------------------------------------------

// ML_Quat

// optional double x = 1;
inline bool ML_Quat::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ML_Quat::has_x() const {
  return _internal_has_x();
}
inline void ML_Quat::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double ML_Quat::_internal_x() const {
  return x_;
}
inline double ML_Quat::x() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Quat.x)
  return _internal_x();
}
inline void ML_Quat::_internal_set_x(double value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void ML_Quat::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Quat.x)
}

// optional double y = 2;
inline bool ML_Quat::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ML_Quat::has_y() const {
  return _internal_has_y();
}
inline void ML_Quat::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ML_Quat::_internal_y() const {
  return y_;
}
inline double ML_Quat::y() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Quat.y)
  return _internal_y();
}
inline void ML_Quat::_internal_set_y(double value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void ML_Quat::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Quat.y)
}

// optional double z = 3;
inline bool ML_Quat::_internal_has_z() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ML_Quat::has_z() const {
  return _internal_has_z();
}
inline void ML_Quat::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ML_Quat::_internal_z() const {
  return z_;
}
inline double ML_Quat::z() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Quat.z)
  return _internal_z();
}
inline void ML_Quat::_internal_set_z(double value) {
  _has_bits_[0] |= 0x00000004u;
  z_ = value;
}
inline void ML_Quat::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Quat.z)
}

// optional double w = 4;
inline bool ML_Quat::_internal_has_w() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ML_Quat::has_w() const {
  return _internal_has_w();
}
inline void ML_Quat::clear_w() {
  w_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double ML_Quat::_internal_w() const {
  return w_;
}
inline double ML_Quat::w() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Quat.w)
  return _internal_w();
}
inline void ML_Quat::_internal_set_w(double value) {
  _has_bits_[0] |= 0x00000008u;
  w_ = value;
}
inline void ML_Quat::set_w(double value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Quat.w)
}

// -------------------------------------------------------------------

// ML_Pose

// optional .mw.internal.robotics.gazebotransport.ML_Point position = 1;
inline bool ML_Pose::_internal_has_position() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || position_ != nullptr);
  return value;
}
inline bool ML_Pose::has_position() const {
  return _internal_has_position();
}
inline void ML_Pose::clear_position() {
  if (position_ != nullptr) position_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mw::internal::robotics::gazebotransport::ML_Point& ML_Pose::_internal_position() const {
  const ::mw::internal::robotics::gazebotransport::ML_Point* p = position_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::ML_Point*>(
      &::mw::internal::robotics::gazebotransport::_ML_Point_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::ML_Point& ML_Pose::position() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Pose.position)
  return _internal_position();
}
inline void ML_Pose::unsafe_arena_set_allocated_position(
    ::mw::internal::robotics::gazebotransport::ML_Point* position) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.ML_Pose.position)
}
inline ::mw::internal::robotics::gazebotransport::ML_Point* ML_Pose::release_position() {
  auto temp = unsafe_arena_release_position();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::ML_Point* ML_Pose::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Pose.position)
  _has_bits_[0] &= ~0x00000001u;
  ::mw::internal::robotics::gazebotransport::ML_Point* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::ML_Point* ML_Pose::_internal_mutable_position() {
  _has_bits_[0] |= 0x00000001u;
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ML_Point>(GetArena());
    position_ = p;
  }
  return position_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Point* ML_Pose::mutable_position() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Pose.position)
  return _internal_mutable_position();
}
inline void ML_Pose::set_allocated_position(::mw::internal::robotics::gazebotransport::ML_Point* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Pose.position)
}

// optional .mw.internal.robotics.gazebotransport.ML_Quat orientation = 2;
inline bool ML_Pose::_internal_has_orientation() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || orientation_ != nullptr);
  return value;
}
inline bool ML_Pose::has_orientation() const {
  return _internal_has_orientation();
}
inline void ML_Pose::clear_orientation() {
  if (orientation_ != nullptr) orientation_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mw::internal::robotics::gazebotransport::ML_Quat& ML_Pose::_internal_orientation() const {
  const ::mw::internal::robotics::gazebotransport::ML_Quat* p = orientation_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::ML_Quat*>(
      &::mw::internal::robotics::gazebotransport::_ML_Quat_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::ML_Quat& ML_Pose::orientation() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Pose.orientation)
  return _internal_orientation();
}
inline void ML_Pose::unsafe_arena_set_allocated_orientation(
    ::mw::internal::robotics::gazebotransport::ML_Quat* orientation) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(orientation_);
  }
  orientation_ = orientation;
  if (orientation) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.ML_Pose.orientation)
}
inline ::mw::internal::robotics::gazebotransport::ML_Quat* ML_Pose::release_orientation() {
  auto temp = unsafe_arena_release_orientation();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::ML_Quat* ML_Pose::unsafe_arena_release_orientation() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Pose.orientation)
  _has_bits_[0] &= ~0x00000002u;
  ::mw::internal::robotics::gazebotransport::ML_Quat* temp = orientation_;
  orientation_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::ML_Quat* ML_Pose::_internal_mutable_orientation() {
  _has_bits_[0] |= 0x00000002u;
  if (orientation_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ML_Quat>(GetArena());
    orientation_ = p;
  }
  return orientation_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Quat* ML_Pose::mutable_orientation() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Pose.orientation)
  return _internal_mutable_orientation();
}
inline void ML_Pose::set_allocated_orientation(::mw::internal::robotics::gazebotransport::ML_Quat* orientation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete orientation_;
  }
  if (orientation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(orientation);
    if (message_arena != submessage_arena) {
      orientation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orientation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  orientation_ = orientation;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Pose.orientation)
}

// -------------------------------------------------------------------

// ML_Inertial

// optional double mass = 1;
inline bool ML_Inertial::_internal_has_mass() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ML_Inertial::has_mass() const {
  return _internal_has_mass();
}
inline void ML_Inertial::clear_mass() {
  mass_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double ML_Inertial::_internal_mass() const {
  return mass_;
}
inline double ML_Inertial::mass() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Inertial.mass)
  return _internal_mass();
}
inline void ML_Inertial::_internal_set_mass(double value) {
  _has_bits_[0] |= 0x00000001u;
  mass_ = value;
}
inline void ML_Inertial::set_mass(double value) {
  _internal_set_mass(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Inertial.mass)
}

// optional double ixx = 2;
inline bool ML_Inertial::_internal_has_ixx() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ML_Inertial::has_ixx() const {
  return _internal_has_ixx();
}
inline void ML_Inertial::clear_ixx() {
  ixx_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ML_Inertial::_internal_ixx() const {
  return ixx_;
}
inline double ML_Inertial::ixx() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Inertial.ixx)
  return _internal_ixx();
}
inline void ML_Inertial::_internal_set_ixx(double value) {
  _has_bits_[0] |= 0x00000002u;
  ixx_ = value;
}
inline void ML_Inertial::set_ixx(double value) {
  _internal_set_ixx(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Inertial.ixx)
}

// optional double ixy = 3;
inline bool ML_Inertial::_internal_has_ixy() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ML_Inertial::has_ixy() const {
  return _internal_has_ixy();
}
inline void ML_Inertial::clear_ixy() {
  ixy_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ML_Inertial::_internal_ixy() const {
  return ixy_;
}
inline double ML_Inertial::ixy() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Inertial.ixy)
  return _internal_ixy();
}
inline void ML_Inertial::_internal_set_ixy(double value) {
  _has_bits_[0] |= 0x00000004u;
  ixy_ = value;
}
inline void ML_Inertial::set_ixy(double value) {
  _internal_set_ixy(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Inertial.ixy)
}

// optional double ixz = 4;
inline bool ML_Inertial::_internal_has_ixz() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ML_Inertial::has_ixz() const {
  return _internal_has_ixz();
}
inline void ML_Inertial::clear_ixz() {
  ixz_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double ML_Inertial::_internal_ixz() const {
  return ixz_;
}
inline double ML_Inertial::ixz() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Inertial.ixz)
  return _internal_ixz();
}
inline void ML_Inertial::_internal_set_ixz(double value) {
  _has_bits_[0] |= 0x00000008u;
  ixz_ = value;
}
inline void ML_Inertial::set_ixz(double value) {
  _internal_set_ixz(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Inertial.ixz)
}

// optional double iyy = 5;
inline bool ML_Inertial::_internal_has_iyy() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ML_Inertial::has_iyy() const {
  return _internal_has_iyy();
}
inline void ML_Inertial::clear_iyy() {
  iyy_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double ML_Inertial::_internal_iyy() const {
  return iyy_;
}
inline double ML_Inertial::iyy() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Inertial.iyy)
  return _internal_iyy();
}
inline void ML_Inertial::_internal_set_iyy(double value) {
  _has_bits_[0] |= 0x00000010u;
  iyy_ = value;
}
inline void ML_Inertial::set_iyy(double value) {
  _internal_set_iyy(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Inertial.iyy)
}

// optional double iyz = 6;
inline bool ML_Inertial::_internal_has_iyz() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ML_Inertial::has_iyz() const {
  return _internal_has_iyz();
}
inline void ML_Inertial::clear_iyz() {
  iyz_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double ML_Inertial::_internal_iyz() const {
  return iyz_;
}
inline double ML_Inertial::iyz() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Inertial.iyz)
  return _internal_iyz();
}
inline void ML_Inertial::_internal_set_iyz(double value) {
  _has_bits_[0] |= 0x00000020u;
  iyz_ = value;
}
inline void ML_Inertial::set_iyz(double value) {
  _internal_set_iyz(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Inertial.iyz)
}

// optional double izz = 7;
inline bool ML_Inertial::_internal_has_izz() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ML_Inertial::has_izz() const {
  return _internal_has_izz();
}
inline void ML_Inertial::clear_izz() {
  izz_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double ML_Inertial::_internal_izz() const {
  return izz_;
}
inline double ML_Inertial::izz() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Inertial.izz)
  return _internal_izz();
}
inline void ML_Inertial::_internal_set_izz(double value) {
  _has_bits_[0] |= 0x00000040u;
  izz_ = value;
}
inline void ML_Inertial::set_izz(double value) {
  _internal_set_izz(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Inertial.izz)
}

// -------------------------------------------------------------------

// ML_Links

// optional string name = 1;
inline bool ML_Links::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ML_Links::has_name() const {
  return _internal_has_name();
}
inline void ML_Links::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ML_Links::name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.name)
  return _internal_name();
}
inline void ML_Links::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Links.name)
}
inline std::string* ML_Links::mutable_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Links.name)
  return _internal_mutable_name();
}
inline const std::string& ML_Links::_internal_name() const {
  return name_.Get();
}
inline void ML_Links::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ML_Links::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.ML_Links.name)
}
inline void ML_Links::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ML_Links.name)
}
inline void ML_Links::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ML_Links.name)
}
inline std::string* ML_Links::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ML_Links::release_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Links.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ML_Links::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Links.name)
}
inline std::string* ML_Links::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.ML_Links.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ML_Links::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.ML_Links.name)
}

// optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 2;
inline bool ML_Links::_internal_has_pose() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || pose_ != nullptr);
  return value;
}
inline bool ML_Links::has_pose() const {
  return _internal_has_pose();
}
inline void ML_Links::clear_pose() {
  if (pose_ != nullptr) pose_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mw::internal::robotics::gazebotransport::ML_Pose& ML_Links::_internal_pose() const {
  const ::mw::internal::robotics::gazebotransport::ML_Pose* p = pose_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::ML_Pose*>(
      &::mw::internal::robotics::gazebotransport::_ML_Pose_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::ML_Pose& ML_Links::pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.pose)
  return _internal_pose();
}
inline void ML_Links::unsafe_arena_set_allocated_pose(
    ::mw::internal::robotics::gazebotransport::ML_Pose* pose) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  pose_ = pose;
  if (pose) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.ML_Links.pose)
}
inline ::mw::internal::robotics::gazebotransport::ML_Pose* ML_Links::release_pose() {
  auto temp = unsafe_arena_release_pose();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::ML_Pose* ML_Links::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Links.pose)
  _has_bits_[0] &= ~0x00000002u;
  ::mw::internal::robotics::gazebotransport::ML_Pose* temp = pose_;
  pose_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::ML_Pose* ML_Links::_internal_mutable_pose() {
  _has_bits_[0] |= 0x00000002u;
  if (pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ML_Pose>(GetArena());
    pose_ = p;
  }
  return pose_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Pose* ML_Links::mutable_pose() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Links.pose)
  return _internal_mutable_pose();
}
inline void ML_Links::set_allocated_pose(::mw::internal::robotics::gazebotransport::ML_Pose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pose_;
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pose);
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Links.pose)
}

// optional .mw.internal.robotics.gazebotransport.ML_Inertial inertial = 3;
inline bool ML_Links::_internal_has_inertial() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || inertial_ != nullptr);
  return value;
}
inline bool ML_Links::has_inertial() const {
  return _internal_has_inertial();
}
inline void ML_Links::clear_inertial() {
  if (inertial_ != nullptr) inertial_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mw::internal::robotics::gazebotransport::ML_Inertial& ML_Links::_internal_inertial() const {
  const ::mw::internal::robotics::gazebotransport::ML_Inertial* p = inertial_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::ML_Inertial*>(
      &::mw::internal::robotics::gazebotransport::_ML_Inertial_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::ML_Inertial& ML_Links::inertial() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.inertial)
  return _internal_inertial();
}
inline void ML_Links::unsafe_arena_set_allocated_inertial(
    ::mw::internal::robotics::gazebotransport::ML_Inertial* inertial) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inertial_);
  }
  inertial_ = inertial;
  if (inertial) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.ML_Links.inertial)
}
inline ::mw::internal::robotics::gazebotransport::ML_Inertial* ML_Links::release_inertial() {
  auto temp = unsafe_arena_release_inertial();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::ML_Inertial* ML_Links::unsafe_arena_release_inertial() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Links.inertial)
  _has_bits_[0] &= ~0x00000004u;
  ::mw::internal::robotics::gazebotransport::ML_Inertial* temp = inertial_;
  inertial_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::ML_Inertial* ML_Links::_internal_mutable_inertial() {
  _has_bits_[0] |= 0x00000004u;
  if (inertial_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ML_Inertial>(GetArena());
    inertial_ = p;
  }
  return inertial_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Inertial* ML_Links::mutable_inertial() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Links.inertial)
  return _internal_mutable_inertial();
}
inline void ML_Links::set_allocated_inertial(::mw::internal::robotics::gazebotransport::ML_Inertial* inertial) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete inertial_;
  }
  if (inertial) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(inertial);
    if (message_arena != submessage_arena) {
      inertial = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inertial, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  inertial_ = inertial;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Links.inertial)
}

// optional bool self_collide = 4;
inline bool ML_Links::_internal_has_self_collide() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ML_Links::has_self_collide() const {
  return _internal_has_self_collide();
}
inline void ML_Links::clear_self_collide() {
  self_collide_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ML_Links::_internal_self_collide() const {
  return self_collide_;
}
inline bool ML_Links::self_collide() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.self_collide)
  return _internal_self_collide();
}
inline void ML_Links::_internal_set_self_collide(bool value) {
  _has_bits_[0] |= 0x00000008u;
  self_collide_ = value;
}
inline void ML_Links::set_self_collide(bool value) {
  _internal_set_self_collide(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Links.self_collide)
}

// optional bool gravity = 5;
inline bool ML_Links::_internal_has_gravity() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ML_Links::has_gravity() const {
  return _internal_has_gravity();
}
inline void ML_Links::clear_gravity() {
  gravity_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool ML_Links::_internal_gravity() const {
  return gravity_;
}
inline bool ML_Links::gravity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.gravity)
  return _internal_gravity();
}
inline void ML_Links::_internal_set_gravity(bool value) {
  _has_bits_[0] |= 0x00000010u;
  gravity_ = value;
}
inline void ML_Links::set_gravity(bool value) {
  _internal_set_gravity(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Links.gravity)
}

// optional bool kinematic = 6;
inline bool ML_Links::_internal_has_kinematic() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ML_Links::has_kinematic() const {
  return _internal_has_kinematic();
}
inline void ML_Links::clear_kinematic() {
  kinematic_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ML_Links::_internal_kinematic() const {
  return kinematic_;
}
inline bool ML_Links::kinematic() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.kinematic)
  return _internal_kinematic();
}
inline void ML_Links::_internal_set_kinematic(bool value) {
  _has_bits_[0] |= 0x00000020u;
  kinematic_ = value;
}
inline void ML_Links::set_kinematic(bool value) {
  _internal_set_kinematic(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Links.kinematic)
}

// optional bool enabled_wind = 7;
inline bool ML_Links::_internal_has_enabled_wind() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ML_Links::has_enabled_wind() const {
  return _internal_has_enabled_wind();
}
inline void ML_Links::clear_enabled_wind() {
  enabled_wind_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool ML_Links::_internal_enabled_wind() const {
  return enabled_wind_;
}
inline bool ML_Links::enabled_wind() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.enabled_wind)
  return _internal_enabled_wind();
}
inline void ML_Links::_internal_set_enabled_wind(bool value) {
  _has_bits_[0] |= 0x00000040u;
  enabled_wind_ = value;
}
inline void ML_Links::set_enabled_wind(bool value) {
  _internal_set_enabled_wind(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Links.enabled_wind)
}

// optional bool is_static = 8;
inline bool ML_Links::_internal_has_is_static() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ML_Links::has_is_static() const {
  return _internal_has_is_static();
}
inline void ML_Links::clear_is_static() {
  is_static_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool ML_Links::_internal_is_static() const {
  return is_static_;
}
inline bool ML_Links::is_static() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.is_static)
  return _internal_is_static();
}
inline void ML_Links::_internal_set_is_static(bool value) {
  _has_bits_[0] |= 0x00000080u;
  is_static_ = value;
}
inline void ML_Links::set_is_static(bool value) {
  _internal_set_is_static(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Links.is_static)
}

// optional bool canonical = 9;
inline bool ML_Links::_internal_has_canonical() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ML_Links::has_canonical() const {
  return _internal_has_canonical();
}
inline void ML_Links::clear_canonical() {
  canonical_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool ML_Links::_internal_canonical() const {
  return canonical_;
}
inline bool ML_Links::canonical() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.canonical)
  return _internal_canonical();
}
inline void ML_Links::_internal_set_canonical(bool value) {
  _has_bits_[0] |= 0x00000100u;
  canonical_ = value;
}
inline void ML_Links::set_canonical(bool value) {
  _internal_set_canonical(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Links.canonical)
}

// -------------------------------------------------------------------

// ML_Axis

// optional .mw.internal.robotics.gazebotransport.ML_Point xyz = 1;
inline bool ML_Axis::_internal_has_xyz() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || xyz_ != nullptr);
  return value;
}
inline bool ML_Axis::has_xyz() const {
  return _internal_has_xyz();
}
inline void ML_Axis::clear_xyz() {
  if (xyz_ != nullptr) xyz_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mw::internal::robotics::gazebotransport::ML_Point& ML_Axis::_internal_xyz() const {
  const ::mw::internal::robotics::gazebotransport::ML_Point* p = xyz_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::ML_Point*>(
      &::mw::internal::robotics::gazebotransport::_ML_Point_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::ML_Point& ML_Axis::xyz() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Axis.xyz)
  return _internal_xyz();
}
inline void ML_Axis::unsafe_arena_set_allocated_xyz(
    ::mw::internal::robotics::gazebotransport::ML_Point* xyz) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(xyz_);
  }
  xyz_ = xyz;
  if (xyz) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.ML_Axis.xyz)
}
inline ::mw::internal::robotics::gazebotransport::ML_Point* ML_Axis::release_xyz() {
  auto temp = unsafe_arena_release_xyz();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::ML_Point* ML_Axis::unsafe_arena_release_xyz() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Axis.xyz)
  _has_bits_[0] &= ~0x00000001u;
  ::mw::internal::robotics::gazebotransport::ML_Point* temp = xyz_;
  xyz_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::ML_Point* ML_Axis::_internal_mutable_xyz() {
  _has_bits_[0] |= 0x00000001u;
  if (xyz_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ML_Point>(GetArena());
    xyz_ = p;
  }
  return xyz_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Point* ML_Axis::mutable_xyz() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Axis.xyz)
  return _internal_mutable_xyz();
}
inline void ML_Axis::set_allocated_xyz(::mw::internal::robotics::gazebotransport::ML_Point* xyz) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete xyz_;
  }
  if (xyz) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(xyz);
    if (message_arena != submessage_arena) {
      xyz = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, xyz, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  xyz_ = xyz;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Axis.xyz)
}

// optional double damping = 2;
inline bool ML_Axis::_internal_has_damping() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ML_Axis::has_damping() const {
  return _internal_has_damping();
}
inline void ML_Axis::clear_damping() {
  damping_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ML_Axis::_internal_damping() const {
  return damping_;
}
inline double ML_Axis::damping() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Axis.damping)
  return _internal_damping();
}
inline void ML_Axis::_internal_set_damping(double value) {
  _has_bits_[0] |= 0x00000002u;
  damping_ = value;
}
inline void ML_Axis::set_damping(double value) {
  _internal_set_damping(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Axis.damping)
}

// optional double friction = 3;
inline bool ML_Axis::_internal_has_friction() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ML_Axis::has_friction() const {
  return _internal_has_friction();
}
inline void ML_Axis::clear_friction() {
  friction_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ML_Axis::_internal_friction() const {
  return friction_;
}
inline double ML_Axis::friction() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Axis.friction)
  return _internal_friction();
}
inline void ML_Axis::_internal_set_friction(double value) {
  _has_bits_[0] |= 0x00000004u;
  friction_ = value;
}
inline void ML_Axis::set_friction(double value) {
  _internal_set_friction(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Axis.friction)
}

// optional double angle = 4;
inline bool ML_Axis::_internal_has_angle() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ML_Axis::has_angle() const {
  return _internal_has_angle();
}
inline void ML_Axis::clear_angle() {
  angle_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double ML_Axis::_internal_angle() const {
  return angle_;
}
inline double ML_Axis::angle() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Axis.angle)
  return _internal_angle();
}
inline void ML_Axis::_internal_set_angle(double value) {
  _has_bits_[0] |= 0x00000008u;
  angle_ = value;
}
inline void ML_Axis::set_angle(double value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Axis.angle)
}

// -------------------------------------------------------------------

// ML_Joints

// optional string name = 1;
inline bool ML_Joints::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ML_Joints::has_name() const {
  return _internal_has_name();
}
inline void ML_Joints::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ML_Joints::name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.name)
  return _internal_name();
}
inline void ML_Joints::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Joints.name)
}
inline std::string* ML_Joints::mutable_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Joints.name)
  return _internal_mutable_name();
}
inline const std::string& ML_Joints::_internal_name() const {
  return name_.Get();
}
inline void ML_Joints::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ML_Joints::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.ML_Joints.name)
}
inline void ML_Joints::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ML_Joints.name)
}
inline void ML_Joints::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ML_Joints.name)
}
inline std::string* ML_Joints::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ML_Joints::release_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Joints.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ML_Joints::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Joints.name)
}
inline std::string* ML_Joints::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.ML_Joints.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ML_Joints::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.ML_Joints.name)
}

// optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 2;
inline bool ML_Joints::_internal_has_pose() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || pose_ != nullptr);
  return value;
}
inline bool ML_Joints::has_pose() const {
  return _internal_has_pose();
}
inline void ML_Joints::clear_pose() {
  if (pose_ != nullptr) pose_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mw::internal::robotics::gazebotransport::ML_Pose& ML_Joints::_internal_pose() const {
  const ::mw::internal::robotics::gazebotransport::ML_Pose* p = pose_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::ML_Pose*>(
      &::mw::internal::robotics::gazebotransport::_ML_Pose_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::ML_Pose& ML_Joints::pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.pose)
  return _internal_pose();
}
inline void ML_Joints::unsafe_arena_set_allocated_pose(
    ::mw::internal::robotics::gazebotransport::ML_Pose* pose) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  pose_ = pose;
  if (pose) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.ML_Joints.pose)
}
inline ::mw::internal::robotics::gazebotransport::ML_Pose* ML_Joints::release_pose() {
  auto temp = unsafe_arena_release_pose();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::ML_Pose* ML_Joints::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Joints.pose)
  _has_bits_[0] &= ~0x00000002u;
  ::mw::internal::robotics::gazebotransport::ML_Pose* temp = pose_;
  pose_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::ML_Pose* ML_Joints::_internal_mutable_pose() {
  _has_bits_[0] |= 0x00000002u;
  if (pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ML_Pose>(GetArena());
    pose_ = p;
  }
  return pose_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Pose* ML_Joints::mutable_pose() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Joints.pose)
  return _internal_mutable_pose();
}
inline void ML_Joints::set_allocated_pose(::mw::internal::robotics::gazebotransport::ML_Pose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pose_;
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pose);
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Joints.pose)
}

// optional .mw.internal.robotics.gazebotransport.ML_Axis axis1 = 3;
inline bool ML_Joints::_internal_has_axis1() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || axis1_ != nullptr);
  return value;
}
inline bool ML_Joints::has_axis1() const {
  return _internal_has_axis1();
}
inline void ML_Joints::clear_axis1() {
  if (axis1_ != nullptr) axis1_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mw::internal::robotics::gazebotransport::ML_Axis& ML_Joints::_internal_axis1() const {
  const ::mw::internal::robotics::gazebotransport::ML_Axis* p = axis1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::ML_Axis*>(
      &::mw::internal::robotics::gazebotransport::_ML_Axis_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::ML_Axis& ML_Joints::axis1() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.axis1)
  return _internal_axis1();
}
inline void ML_Joints::unsafe_arena_set_allocated_axis1(
    ::mw::internal::robotics::gazebotransport::ML_Axis* axis1) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(axis1_);
  }
  axis1_ = axis1;
  if (axis1) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.ML_Joints.axis1)
}
inline ::mw::internal::robotics::gazebotransport::ML_Axis* ML_Joints::release_axis1() {
  auto temp = unsafe_arena_release_axis1();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::ML_Axis* ML_Joints::unsafe_arena_release_axis1() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Joints.axis1)
  _has_bits_[0] &= ~0x00000004u;
  ::mw::internal::robotics::gazebotransport::ML_Axis* temp = axis1_;
  axis1_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::ML_Axis* ML_Joints::_internal_mutable_axis1() {
  _has_bits_[0] |= 0x00000004u;
  if (axis1_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ML_Axis>(GetArena());
    axis1_ = p;
  }
  return axis1_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Axis* ML_Joints::mutable_axis1() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Joints.axis1)
  return _internal_mutable_axis1();
}
inline void ML_Joints::set_allocated_axis1(::mw::internal::robotics::gazebotransport::ML_Axis* axis1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete axis1_;
  }
  if (axis1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(axis1);
    if (message_arena != submessage_arena) {
      axis1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, axis1, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  axis1_ = axis1;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Joints.axis1)
}

// optional .mw.internal.robotics.gazebotransport.ML_Axis axis2 = 4;
inline bool ML_Joints::_internal_has_axis2() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || axis2_ != nullptr);
  return value;
}
inline bool ML_Joints::has_axis2() const {
  return _internal_has_axis2();
}
inline void ML_Joints::clear_axis2() {
  if (axis2_ != nullptr) axis2_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::mw::internal::robotics::gazebotransport::ML_Axis& ML_Joints::_internal_axis2() const {
  const ::mw::internal::robotics::gazebotransport::ML_Axis* p = axis2_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::ML_Axis*>(
      &::mw::internal::robotics::gazebotransport::_ML_Axis_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::ML_Axis& ML_Joints::axis2() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.axis2)
  return _internal_axis2();
}
inline void ML_Joints::unsafe_arena_set_allocated_axis2(
    ::mw::internal::robotics::gazebotransport::ML_Axis* axis2) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(axis2_);
  }
  axis2_ = axis2;
  if (axis2) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.ML_Joints.axis2)
}
inline ::mw::internal::robotics::gazebotransport::ML_Axis* ML_Joints::release_axis2() {
  auto temp = unsafe_arena_release_axis2();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::ML_Axis* ML_Joints::unsafe_arena_release_axis2() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Joints.axis2)
  _has_bits_[0] &= ~0x00000008u;
  ::mw::internal::robotics::gazebotransport::ML_Axis* temp = axis2_;
  axis2_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::ML_Axis* ML_Joints::_internal_mutable_axis2() {
  _has_bits_[0] |= 0x00000008u;
  if (axis2_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ML_Axis>(GetArena());
    axis2_ = p;
  }
  return axis2_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Axis* ML_Joints::mutable_axis2() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Joints.axis2)
  return _internal_mutable_axis2();
}
inline void ML_Joints::set_allocated_axis2(::mw::internal::robotics::gazebotransport::ML_Axis* axis2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete axis2_;
  }
  if (axis2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(axis2);
    if (message_arena != submessage_arena) {
      axis2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, axis2, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  axis2_ = axis2;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Joints.axis2)
}

// optional double cfm = 5;
inline bool ML_Joints::_internal_has_cfm() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ML_Joints::has_cfm() const {
  return _internal_has_cfm();
}
inline void ML_Joints::clear_cfm() {
  cfm_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double ML_Joints::_internal_cfm() const {
  return cfm_;
}
inline double ML_Joints::cfm() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.cfm)
  return _internal_cfm();
}
inline void ML_Joints::_internal_set_cfm(double value) {
  _has_bits_[0] |= 0x00000010u;
  cfm_ = value;
}
inline void ML_Joints::set_cfm(double value) {
  _internal_set_cfm(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Joints.cfm)
}

// optional double fudge_factor = 6;
inline bool ML_Joints::_internal_has_fudge_factor() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ML_Joints::has_fudge_factor() const {
  return _internal_has_fudge_factor();
}
inline void ML_Joints::clear_fudge_factor() {
  fudge_factor_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double ML_Joints::_internal_fudge_factor() const {
  return fudge_factor_;
}
inline double ML_Joints::fudge_factor() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.fudge_factor)
  return _internal_fudge_factor();
}
inline void ML_Joints::_internal_set_fudge_factor(double value) {
  _has_bits_[0] |= 0x00000020u;
  fudge_factor_ = value;
}
inline void ML_Joints::set_fudge_factor(double value) {
  _internal_set_fudge_factor(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Joints.fudge_factor)
}

// optional double suspension_cfm = 7;
inline bool ML_Joints::_internal_has_suspension_cfm() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ML_Joints::has_suspension_cfm() const {
  return _internal_has_suspension_cfm();
}
inline void ML_Joints::clear_suspension_cfm() {
  suspension_cfm_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double ML_Joints::_internal_suspension_cfm() const {
  return suspension_cfm_;
}
inline double ML_Joints::suspension_cfm() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.suspension_cfm)
  return _internal_suspension_cfm();
}
inline void ML_Joints::_internal_set_suspension_cfm(double value) {
  _has_bits_[0] |= 0x00000040u;
  suspension_cfm_ = value;
}
inline void ML_Joints::set_suspension_cfm(double value) {
  _internal_set_suspension_cfm(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Joints.suspension_cfm)
}

// optional double suspension_erp = 8;
inline bool ML_Joints::_internal_has_suspension_erp() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ML_Joints::has_suspension_erp() const {
  return _internal_has_suspension_erp();
}
inline void ML_Joints::clear_suspension_erp() {
  suspension_erp_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline double ML_Joints::_internal_suspension_erp() const {
  return suspension_erp_;
}
inline double ML_Joints::suspension_erp() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.suspension_erp)
  return _internal_suspension_erp();
}
inline void ML_Joints::_internal_set_suspension_erp(double value) {
  _has_bits_[0] |= 0x00000080u;
  suspension_erp_ = value;
}
inline void ML_Joints::set_suspension_erp(double value) {
  _internal_set_suspension_erp(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Joints.suspension_erp)
}

// optional uint32 dof = 9;
inline bool ML_Joints::_internal_has_dof() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ML_Joints::has_dof() const {
  return _internal_has_dof();
}
inline void ML_Joints::clear_dof() {
  dof_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ML_Joints::_internal_dof() const {
  return dof_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ML_Joints::dof() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.dof)
  return _internal_dof();
}
inline void ML_Joints::_internal_set_dof(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  dof_ = value;
}
inline void ML_Joints::set_dof(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_dof(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Joints.dof)
}

// -------------------------------------------------------------------

// Gazebomodel

// required string name = 1;
inline bool Gazebomodel::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Gazebomodel::has_name() const {
  return _internal_has_name();
}
inline void Gazebomodel::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Gazebomodel::name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Gazebomodel.name)
  return _internal_name();
}
inline void Gazebomodel::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Gazebomodel.name)
}
inline std::string* Gazebomodel::mutable_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Gazebomodel.name)
  return _internal_mutable_name();
}
inline const std::string& Gazebomodel::_internal_name() const {
  return name_.Get();
}
inline void Gazebomodel::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Gazebomodel::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.Gazebomodel.name)
}
inline void Gazebomodel::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.Gazebomodel.name)
}
inline void Gazebomodel::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.Gazebomodel.name)
}
inline std::string* Gazebomodel::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Gazebomodel::release_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Gazebomodel.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Gazebomodel::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Gazebomodel.name)
}
inline std::string* Gazebomodel::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.Gazebomodel.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Gazebomodel::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Gazebomodel.name)
}

// repeated .mw.internal.robotics.gazebotransport.ML_Links links = 2;
inline int Gazebomodel::_internal_links_size() const {
  return links_.size();
}
inline int Gazebomodel::links_size() const {
  return _internal_links_size();
}
inline void Gazebomodel::clear_links() {
  links_.Clear();
}
inline ::mw::internal::robotics::gazebotransport::ML_Links* Gazebomodel::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Gazebomodel.links)
  return links_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ML_Links >*
Gazebomodel::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.Gazebomodel.links)
  return &links_;
}
inline const ::mw::internal::robotics::gazebotransport::ML_Links& Gazebomodel::_internal_links(int index) const {
  return links_.Get(index);
}
inline const ::mw::internal::robotics::gazebotransport::ML_Links& Gazebomodel::links(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Gazebomodel.links)
  return _internal_links(index);
}
inline ::mw::internal::robotics::gazebotransport::ML_Links* Gazebomodel::_internal_add_links() {
  return links_.Add();
}
inline ::mw::internal::robotics::gazebotransport::ML_Links* Gazebomodel::add_links() {
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.Gazebomodel.links)
  return _internal_add_links();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ML_Links >&
Gazebomodel::links() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.Gazebomodel.links)
  return links_;
}

// repeated .mw.internal.robotics.gazebotransport.ML_Joints joints = 3;
inline int Gazebomodel::_internal_joints_size() const {
  return joints_.size();
}
inline int Gazebomodel::joints_size() const {
  return _internal_joints_size();
}
inline void Gazebomodel::clear_joints() {
  joints_.Clear();
}
inline ::mw::internal::robotics::gazebotransport::ML_Joints* Gazebomodel::mutable_joints(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Gazebomodel.joints)
  return joints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ML_Joints >*
Gazebomodel::mutable_joints() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.Gazebomodel.joints)
  return &joints_;
}
inline const ::mw::internal::robotics::gazebotransport::ML_Joints& Gazebomodel::_internal_joints(int index) const {
  return joints_.Get(index);
}
inline const ::mw::internal::robotics::gazebotransport::ML_Joints& Gazebomodel::joints(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Gazebomodel.joints)
  return _internal_joints(index);
}
inline ::mw::internal::robotics::gazebotransport::ML_Joints* Gazebomodel::_internal_add_joints() {
  return joints_.Add();
}
inline ::mw::internal::robotics::gazebotransport::ML_Joints* Gazebomodel::add_joints() {
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.Gazebomodel.joints)
  return _internal_add_joints();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ML_Joints >&
Gazebomodel::joints() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.Gazebomodel.joints)
  return joints_;
}

// optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 4;
inline bool Gazebomodel::_internal_has_pose() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || pose_ != nullptr);
  return value;
}
inline bool Gazebomodel::has_pose() const {
  return _internal_has_pose();
}
inline void Gazebomodel::clear_pose() {
  if (pose_ != nullptr) pose_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mw::internal::robotics::gazebotransport::ML_Pose& Gazebomodel::_internal_pose() const {
  const ::mw::internal::robotics::gazebotransport::ML_Pose* p = pose_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::ML_Pose*>(
      &::mw::internal::robotics::gazebotransport::_ML_Pose_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::ML_Pose& Gazebomodel::pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Gazebomodel.pose)
  return _internal_pose();
}
inline void Gazebomodel::unsafe_arena_set_allocated_pose(
    ::mw::internal::robotics::gazebotransport::ML_Pose* pose) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  pose_ = pose;
  if (pose) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.Gazebomodel.pose)
}
inline ::mw::internal::robotics::gazebotransport::ML_Pose* Gazebomodel::release_pose() {
  auto temp = unsafe_arena_release_pose();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::ML_Pose* Gazebomodel::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Gazebomodel.pose)
  _has_bits_[0] &= ~0x00000002u;
  ::mw::internal::robotics::gazebotransport::ML_Pose* temp = pose_;
  pose_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::ML_Pose* Gazebomodel::_internal_mutable_pose() {
  _has_bits_[0] |= 0x00000002u;
  if (pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ML_Pose>(GetArena());
    pose_ = p;
  }
  return pose_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Pose* Gazebomodel::mutable_pose() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Gazebomodel.pose)
  return _internal_mutable_pose();
}
inline void Gazebomodel::set_allocated_pose(::mw::internal::robotics::gazebotransport::ML_Pose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pose_;
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pose);
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Gazebomodel.pose)
}

// optional bool enable_wind = 5;
inline bool Gazebomodel::_internal_has_enable_wind() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Gazebomodel::has_enable_wind() const {
  return _internal_has_enable_wind();
}
inline void Gazebomodel::clear_enable_wind() {
  enable_wind_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Gazebomodel::_internal_enable_wind() const {
  return enable_wind_;
}
inline bool Gazebomodel::enable_wind() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Gazebomodel.enable_wind)
  return _internal_enable_wind();
}
inline void Gazebomodel::_internal_set_enable_wind(bool value) {
  _has_bits_[0] |= 0x00000004u;
  enable_wind_ = value;
}
inline void Gazebomodel::set_enable_wind(bool value) {
  _internal_set_enable_wind(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Gazebomodel.enable_wind)
}

// optional bool self_collide = 6;
inline bool Gazebomodel::_internal_has_self_collide() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Gazebomodel::has_self_collide() const {
  return _internal_has_self_collide();
}
inline void Gazebomodel::clear_self_collide() {
  self_collide_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool Gazebomodel::_internal_self_collide() const {
  return self_collide_;
}
inline bool Gazebomodel::self_collide() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Gazebomodel.self_collide)
  return _internal_self_collide();
}
inline void Gazebomodel::_internal_set_self_collide(bool value) {
  _has_bits_[0] |= 0x00000008u;
  self_collide_ = value;
}
inline void Gazebomodel::set_self_collide(bool value) {
  _internal_set_self_collide(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Gazebomodel.self_collide)
}

// optional bool is_static = 7;
inline bool Gazebomodel::_internal_has_is_static() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Gazebomodel::has_is_static() const {
  return _internal_has_is_static();
}
inline void Gazebomodel::clear_is_static() {
  is_static_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool Gazebomodel::_internal_is_static() const {
  return is_static_;
}
inline bool Gazebomodel::is_static() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Gazebomodel.is_static)
  return _internal_is_static();
}
inline void Gazebomodel::_internal_set_is_static(bool value) {
  _has_bits_[0] |= 0x00000010u;
  is_static_ = value;
}
inline void Gazebomodel::set_is_static(bool value) {
  _internal_set_is_static(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Gazebomodel.is_static)
}

// -------------------------------------------------------------------

// GetGazeboModelParam

// required string model_name = 1;
inline bool GetGazeboModelParam::_internal_has_model_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetGazeboModelParam::has_model_name() const {
  return _internal_has_model_name();
}
inline void GetGazeboModelParam::clear_model_name() {
  model_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetGazeboModelParam::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name)
  return _internal_model_name();
}
inline void GetGazeboModelParam::set_model_name(const std::string& value) {
  _internal_set_model_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name)
}
inline std::string* GetGazeboModelParam::mutable_model_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name)
  return _internal_mutable_model_name();
}
inline const std::string& GetGazeboModelParam::_internal_model_name() const {
  return model_name_.Get();
}
inline void GetGazeboModelParam::_internal_set_model_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetGazeboModelParam::set_model_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name)
}
inline void GetGazeboModelParam::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name)
}
inline void GetGazeboModelParam::set_model_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name)
}
inline std::string* GetGazeboModelParam::_internal_mutable_model_name() {
  _has_bits_[0] |= 0x00000001u;
  return model_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetGazeboModelParam::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name)
  if (!_internal_has_model_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetGazeboModelParam::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name)
}
inline std::string* GetGazeboModelParam::unsafe_arena_release_model_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetGazeboModelParam::unsafe_arena_set_allocated_model_name(
    std::string* model_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      model_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name)
}

// optional bool is_link = 2;
inline bool GetGazeboModelParam::_internal_has_is_link() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GetGazeboModelParam::has_is_link() const {
  return _internal_has_is_link();
}
inline void GetGazeboModelParam::clear_is_link() {
  is_link_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool GetGazeboModelParam::_internal_is_link() const {
  return is_link_;
}
inline bool GetGazeboModelParam::is_link() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetGazeboModelParam.is_link)
  return _internal_is_link();
}
inline void GetGazeboModelParam::_internal_set_is_link(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_link_ = value;
}
inline void GetGazeboModelParam::set_is_link(bool value) {
  _internal_set_is_link(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetGazeboModelParam.is_link)
}

// optional string link_joint_name = 3;
inline bool GetGazeboModelParam::_internal_has_link_joint_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetGazeboModelParam::has_link_joint_name() const {
  return _internal_has_link_joint_name();
}
inline void GetGazeboModelParam::clear_link_joint_name() {
  link_joint_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GetGazeboModelParam::link_joint_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name)
  return _internal_link_joint_name();
}
inline void GetGazeboModelParam::set_link_joint_name(const std::string& value) {
  _internal_set_link_joint_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name)
}
inline std::string* GetGazeboModelParam::mutable_link_joint_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name)
  return _internal_mutable_link_joint_name();
}
inline const std::string& GetGazeboModelParam::_internal_link_joint_name() const {
  return link_joint_name_.Get();
}
inline void GetGazeboModelParam::_internal_set_link_joint_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  link_joint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetGazeboModelParam::set_link_joint_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  link_joint_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name)
}
inline void GetGazeboModelParam::set_link_joint_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  link_joint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name)
}
inline void GetGazeboModelParam::set_link_joint_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  link_joint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name)
}
inline std::string* GetGazeboModelParam::_internal_mutable_link_joint_name() {
  _has_bits_[0] |= 0x00000002u;
  return link_joint_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetGazeboModelParam::release_link_joint_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name)
  if (!_internal_has_link_joint_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return link_joint_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetGazeboModelParam::set_allocated_link_joint_name(std::string* link_joint_name) {
  if (link_joint_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  link_joint_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), link_joint_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name)
}
inline std::string* GetGazeboModelParam::unsafe_arena_release_link_joint_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return link_joint_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetGazeboModelParam::unsafe_arena_set_allocated_link_joint_name(
    std::string* link_joint_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (link_joint_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  link_joint_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      link_joint_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name)
}

// -------------------------------------------------------------------

// GazeboModelSDF

// required string model_name = 1;
inline bool GazeboModelSDF::_internal_has_model_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GazeboModelSDF::has_model_name() const {
  return _internal_has_model_name();
}
inline void GazeboModelSDF::clear_model_name() {
  model_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GazeboModelSDF::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name)
  return _internal_model_name();
}
inline void GazeboModelSDF::set_model_name(const std::string& value) {
  _internal_set_model_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name)
}
inline std::string* GazeboModelSDF::mutable_model_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name)
  return _internal_mutable_model_name();
}
inline const std::string& GazeboModelSDF::_internal_model_name() const {
  return model_name_.Get();
}
inline void GazeboModelSDF::_internal_set_model_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GazeboModelSDF::set_model_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name)
}
inline void GazeboModelSDF::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name)
}
inline void GazeboModelSDF::set_model_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name)
}
inline std::string* GazeboModelSDF::_internal_mutable_model_name() {
  _has_bits_[0] |= 0x00000001u;
  return model_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GazeboModelSDF::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name)
  if (!_internal_has_model_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GazeboModelSDF::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name)
}
inline std::string* GazeboModelSDF::unsafe_arena_release_model_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GazeboModelSDF::unsafe_arena_set_allocated_model_name(
    std::string* model_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      model_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name)
}

// required string sdf_string = 2;
inline bool GazeboModelSDF::_internal_has_sdf_string() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GazeboModelSDF::has_sdf_string() const {
  return _internal_has_sdf_string();
}
inline void GazeboModelSDF::clear_sdf_string() {
  sdf_string_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GazeboModelSDF::sdf_string() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string)
  return _internal_sdf_string();
}
inline void GazeboModelSDF::set_sdf_string(const std::string& value) {
  _internal_set_sdf_string(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string)
}
inline std::string* GazeboModelSDF::mutable_sdf_string() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string)
  return _internal_mutable_sdf_string();
}
inline const std::string& GazeboModelSDF::_internal_sdf_string() const {
  return sdf_string_.Get();
}
inline void GazeboModelSDF::_internal_set_sdf_string(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  sdf_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GazeboModelSDF::set_sdf_string(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  sdf_string_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string)
}
inline void GazeboModelSDF::set_sdf_string(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  sdf_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string)
}
inline void GazeboModelSDF::set_sdf_string(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  sdf_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string)
}
inline std::string* GazeboModelSDF::_internal_mutable_sdf_string() {
  _has_bits_[0] |= 0x00000002u;
  return sdf_string_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GazeboModelSDF::release_sdf_string() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string)
  if (!_internal_has_sdf_string()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return sdf_string_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GazeboModelSDF::set_allocated_sdf_string(std::string* sdf_string) {
  if (sdf_string != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sdf_string_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sdf_string,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string)
}
inline std::string* GazeboModelSDF::unsafe_arena_release_sdf_string() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return sdf_string_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GazeboModelSDF::unsafe_arena_set_allocated_sdf_string(
    std::string* sdf_string) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (sdf_string != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sdf_string_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      sdf_string, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string)
}

// -------------------------------------------------------------------

// GetGazeboModelSDF

// required string model_name = 1;
inline bool GetGazeboModelSDF::_internal_has_model_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetGazeboModelSDF::has_model_name() const {
  return _internal_has_model_name();
}
inline void GetGazeboModelSDF::clear_model_name() {
  model_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetGazeboModelSDF::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name)
  return _internal_model_name();
}
inline void GetGazeboModelSDF::set_model_name(const std::string& value) {
  _internal_set_model_name(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name)
}
inline std::string* GetGazeboModelSDF::mutable_model_name() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name)
  return _internal_mutable_model_name();
}
inline const std::string& GetGazeboModelSDF::_internal_model_name() const {
  return model_name_.Get();
}
inline void GetGazeboModelSDF::_internal_set_model_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetGazeboModelSDF::set_model_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name)
}
inline void GetGazeboModelSDF::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name)
}
inline void GetGazeboModelSDF::set_model_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name)
}
inline std::string* GetGazeboModelSDF::_internal_mutable_model_name() {
  _has_bits_[0] |= 0x00000001u;
  return model_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetGazeboModelSDF::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name)
  if (!_internal_has_model_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetGazeboModelSDF::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name)
}
inline std::string* GetGazeboModelSDF::unsafe_arena_release_model_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return model_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetGazeboModelSDF::unsafe_arena_set_allocated_model_name(
    std::string* model_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (model_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      model_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace gazebotransport
}  // namespace robotics
}  // namespace internal
}  // namespace mw

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::mw::internal::robotics::gazebotransport::PacketHeader_MsgID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mw::internal::robotics::gazebotransport::PacketHeader_MsgID>() {
  return ::mw::internal::robotics::gazebotransport::PacketHeader_MsgID_descriptor();
}
template <> struct is_proto_enum< ::mw::internal::robotics::gazebotransport::Packet_CoSimError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mw::internal::robotics::gazebotransport::Packet_CoSimError>() {
  return ::mw::internal::robotics::gazebotransport::Packet_CoSimError_descriptor();
}
template <> struct is_proto_enum< ::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior>() {
  return ::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior_descriptor();
}
template <> struct is_proto_enum< ::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE>() {
  return ::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE_descriptor();
}
template <> struct is_proto_enum< ::mw::internal::robotics::gazebotransport::JointState_Joint_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mw::internal::robotics::gazebotransport::JointState_Joint_Type>() {
  return ::mw::internal::robotics::gazebotransport::JointState_Joint_Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto
