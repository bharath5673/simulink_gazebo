// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mw.internal.robotics.gazebotransport.TestMsgs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto;
namespace mw {
namespace internal {
namespace robotics {
namespace gazebotransport {
class TestArrays;
class TestArraysDefaultTypeInternal;
extern TestArraysDefaultTypeInternal _TestArrays_default_instance_;
class TestMessage;
class TestMessageDefaultTypeInternal;
extern TestMessageDefaultTypeInternal _TestMessage_default_instance_;
class TestNestedMessage;
class TestNestedMessageDefaultTypeInternal;
extern TestNestedMessageDefaultTypeInternal _TestNestedMessage_default_instance_;
class TestPose;
class TestPoseDefaultTypeInternal;
extern TestPoseDefaultTypeInternal _TestPose_default_instance_;
class TestScalars;
class TestScalarsDefaultTypeInternal;
extern TestScalarsDefaultTypeInternal _TestScalars_default_instance_;
}  // namespace gazebotransport
}  // namespace robotics
}  // namespace internal
}  // namespace mw
PROTOBUF_NAMESPACE_OPEN
template<> ::mw::internal::robotics::gazebotransport::TestArrays* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::TestArrays>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::TestMessage* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::TestMessage>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::TestNestedMessage* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::TestNestedMessage>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::TestPose* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::TestPose>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::TestScalars* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::TestScalars>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mw {
namespace internal {
namespace robotics {
namespace gazebotransport {

enum TestEnum : int {
  ITEM_A = 0,
  ITEM_B = 1
};
bool TestEnum_IsValid(int value);
constexpr TestEnum TestEnum_MIN = ITEM_A;
constexpr TestEnum TestEnum_MAX = ITEM_B;
constexpr int TestEnum_ARRAYSIZE = TestEnum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TestEnum_descriptor();
template<typename T>
inline const std::string& TestEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TestEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TestEnum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TestEnum_descriptor(), enum_t_value);
}
inline bool TestEnum_Parse(
    const std::string& name, TestEnum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TestEnum>(
    TestEnum_descriptor(), name, value);
}
// ===================================================================

class TestScalars PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.TestScalars) */ {
 public:
  inline TestScalars() : TestScalars(nullptr) {};
  virtual ~TestScalars();

  TestScalars(const TestScalars& from);
  TestScalars(TestScalars&& from) noexcept
    : TestScalars() {
    *this = ::std::move(from);
  }

  inline TestScalars& operator=(const TestScalars& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestScalars& operator=(TestScalars&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TestScalars& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestScalars* internal_default_instance() {
    return reinterpret_cast<const TestScalars*>(
               &_TestScalars_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TestScalars& a, TestScalars& b) {
    a.Swap(&b);
  }
  inline void Swap(TestScalars* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestScalars* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TestScalars* New() const final {
    return CreateMaybeMessage<TestScalars>(nullptr);
  }

  TestScalars* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TestScalars>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TestScalars& from);
  void MergeFrom(const TestScalars& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestScalars* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.TestScalars";
  }
  protected:
  explicit TestScalars(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kByteArrayFieldNumber = 7,
    kCharacterArrayFieldNumber = 8,
    kInteger64FieldNumber = 1,
    kUnsignedInteger64FieldNumber = 2,
    kInteger32FieldNumber = 3,
    kUnsignedInteger32FieldNumber = 4,
    kBinary64FieldNumber = 5,
    kBinary32FieldNumber = 6,
    kEnumItemFieldNumber = 9,
    kLogicalItemFieldNumber = 10,
  };
  // required bytes byte_array = 7;
  bool has_byte_array() const;
  private:
  bool _internal_has_byte_array() const;
  public:
  void clear_byte_array();
  const std::string& byte_array() const;
  void set_byte_array(const std::string& value);
  void set_byte_array(std::string&& value);
  void set_byte_array(const char* value);
  void set_byte_array(const void* value, size_t size);
  std::string* mutable_byte_array();
  std::string* release_byte_array();
  void set_allocated_byte_array(std::string* byte_array);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_byte_array();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_byte_array(
      std::string* byte_array);
  private:
  const std::string& _internal_byte_array() const;
  void _internal_set_byte_array(const std::string& value);
  std::string* _internal_mutable_byte_array();
  public:

  // required string character_array = 8;
  bool has_character_array() const;
  private:
  bool _internal_has_character_array() const;
  public:
  void clear_character_array();
  const std::string& character_array() const;
  void set_character_array(const std::string& value);
  void set_character_array(std::string&& value);
  void set_character_array(const char* value);
  void set_character_array(const char* value, size_t size);
  std::string* mutable_character_array();
  std::string* release_character_array();
  void set_allocated_character_array(std::string* character_array);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_character_array();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_character_array(
      std::string* character_array);
  private:
  const std::string& _internal_character_array() const;
  void _internal_set_character_array(const std::string& value);
  std::string* _internal_mutable_character_array();
  public:

  // required int64 integer_64 = 1;
  bool has_integer_64() const;
  private:
  bool _internal_has_integer_64() const;
  public:
  void clear_integer_64();
  ::PROTOBUF_NAMESPACE_ID::int64 integer_64() const;
  void set_integer_64(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_integer_64() const;
  void _internal_set_integer_64(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required uint64 unsigned_integer_64 = 2;
  bool has_unsigned_integer_64() const;
  private:
  bool _internal_has_unsigned_integer_64() const;
  public:
  void clear_unsigned_integer_64();
  ::PROTOBUF_NAMESPACE_ID::uint64 unsigned_integer_64() const;
  void set_unsigned_integer_64(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_unsigned_integer_64() const;
  void _internal_set_unsigned_integer_64(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required int32 integer_32 = 3;
  bool has_integer_32() const;
  private:
  bool _internal_has_integer_32() const;
  public:
  void clear_integer_32();
  ::PROTOBUF_NAMESPACE_ID::int32 integer_32() const;
  void set_integer_32(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_integer_32() const;
  void _internal_set_integer_32(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required uint32 unsigned_integer_32 = 4;
  bool has_unsigned_integer_32() const;
  private:
  bool _internal_has_unsigned_integer_32() const;
  public:
  void clear_unsigned_integer_32();
  ::PROTOBUF_NAMESPACE_ID::uint32 unsigned_integer_32() const;
  void set_unsigned_integer_32(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_unsigned_integer_32() const;
  void _internal_set_unsigned_integer_32(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required double binary_64 = 5;
  bool has_binary_64() const;
  private:
  bool _internal_has_binary_64() const;
  public:
  void clear_binary_64();
  double binary_64() const;
  void set_binary_64(double value);
  private:
  double _internal_binary_64() const;
  void _internal_set_binary_64(double value);
  public:

  // required float binary_32 = 6;
  bool has_binary_32() const;
  private:
  bool _internal_has_binary_32() const;
  public:
  void clear_binary_32();
  float binary_32() const;
  void set_binary_32(float value);
  private:
  float _internal_binary_32() const;
  void _internal_set_binary_32(float value);
  public:

  // required .mw.internal.robotics.gazebotransport.TestEnum enum_item = 9;
  bool has_enum_item() const;
  private:
  bool _internal_has_enum_item() const;
  public:
  void clear_enum_item();
  ::mw::internal::robotics::gazebotransport::TestEnum enum_item() const;
  void set_enum_item(::mw::internal::robotics::gazebotransport::TestEnum value);
  private:
  ::mw::internal::robotics::gazebotransport::TestEnum _internal_enum_item() const;
  void _internal_set_enum_item(::mw::internal::robotics::gazebotransport::TestEnum value);
  public:

  // required bool logical_item = 10;
  bool has_logical_item() const;
  private:
  bool _internal_has_logical_item() const;
  public:
  void clear_logical_item();
  bool logical_item() const;
  void set_logical_item(bool value);
  private:
  bool _internal_logical_item() const;
  void _internal_set_logical_item(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.TestScalars)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr byte_array_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr character_array_;
  ::PROTOBUF_NAMESPACE_ID::int64 integer_64_;
  ::PROTOBUF_NAMESPACE_ID::uint64 unsigned_integer_64_;
  ::PROTOBUF_NAMESPACE_ID::int32 integer_32_;
  ::PROTOBUF_NAMESPACE_ID::uint32 unsigned_integer_32_;
  double binary_64_;
  float binary_32_;
  int enum_item_;
  bool logical_item_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto;
};
// -------------------------------------------------------------------

class TestArrays PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.TestArrays) */ {
 public:
  inline TestArrays() : TestArrays(nullptr) {};
  virtual ~TestArrays();

  TestArrays(const TestArrays& from);
  TestArrays(TestArrays&& from) noexcept
    : TestArrays() {
    *this = ::std::move(from);
  }

  inline TestArrays& operator=(const TestArrays& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestArrays& operator=(TestArrays&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TestArrays& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestArrays* internal_default_instance() {
    return reinterpret_cast<const TestArrays*>(
               &_TestArrays_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TestArrays& a, TestArrays& b) {
    a.Swap(&b);
  }
  inline void Swap(TestArrays* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestArrays* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TestArrays* New() const final {
    return CreateMaybeMessage<TestArrays>(nullptr);
  }

  TestArrays* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TestArrays>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TestArrays& from);
  void MergeFrom(const TestArrays& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestArrays* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.TestArrays";
  }
  protected:
  explicit TestArrays(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInteger64FieldNumber = 1,
    kUnsignedInteger64FieldNumber = 2,
    kInteger32FieldNumber = 3,
    kUnsignedInteger32FieldNumber = 4,
    kBinary64FieldNumber = 5,
    kBinary32FieldNumber = 6,
    kByteArrayFieldNumber = 7,
    kCharacterArrayFieldNumber = 8,
    kEnumItemFieldNumber = 9,
    kLogicalItemFieldNumber = 10,
  };
  // repeated int64 integer_64 = 1;
  int integer_64_size() const;
  private:
  int _internal_integer_64_size() const;
  public:
  void clear_integer_64();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_integer_64(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_integer_64() const;
  void _internal_add_integer_64(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_integer_64();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 integer_64(int index) const;
  void set_integer_64(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_integer_64(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      integer_64() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_integer_64();

  // repeated uint64 unsigned_integer_64 = 2;
  int unsigned_integer_64_size() const;
  private:
  int _internal_unsigned_integer_64_size() const;
  public:
  void clear_unsigned_integer_64();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_unsigned_integer_64(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      _internal_unsigned_integer_64() const;
  void _internal_add_unsigned_integer_64(::PROTOBUF_NAMESPACE_ID::uint64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      _internal_mutable_unsigned_integer_64();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint64 unsigned_integer_64(int index) const;
  void set_unsigned_integer_64(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_unsigned_integer_64(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      unsigned_integer_64() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_unsigned_integer_64();

  // repeated int32 integer_32 = 3;
  int integer_32_size() const;
  private:
  int _internal_integer_32_size() const;
  public:
  void clear_integer_32();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_integer_32(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_integer_32() const;
  void _internal_add_integer_32(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_integer_32();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 integer_32(int index) const;
  void set_integer_32(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_integer_32(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      integer_32() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_integer_32();

  // repeated uint32 unsigned_integer_32 = 4;
  int unsigned_integer_32_size() const;
  private:
  int _internal_unsigned_integer_32_size() const;
  public:
  void clear_unsigned_integer_32();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_unsigned_integer_32(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_unsigned_integer_32() const;
  void _internal_add_unsigned_integer_32(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_unsigned_integer_32();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 unsigned_integer_32(int index) const;
  void set_unsigned_integer_32(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_unsigned_integer_32(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      unsigned_integer_32() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_unsigned_integer_32();

  // repeated double binary_64 = 5;
  int binary_64_size() const;
  private:
  int _internal_binary_64_size() const;
  public:
  void clear_binary_64();
  private:
  double _internal_binary_64(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_binary_64() const;
  void _internal_add_binary_64(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_binary_64();
  public:
  double binary_64(int index) const;
  void set_binary_64(int index, double value);
  void add_binary_64(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      binary_64() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_binary_64();

  // repeated float binary_32 = 6;
  int binary_32_size() const;
  private:
  int _internal_binary_32_size() const;
  public:
  void clear_binary_32();
  private:
  float _internal_binary_32(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_binary_32() const;
  void _internal_add_binary_32(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_binary_32();
  public:
  float binary_32(int index) const;
  void set_binary_32(int index, float value);
  void add_binary_32(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      binary_32() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_binary_32();

  // repeated bytes byte_array = 7;
  int byte_array_size() const;
  private:
  int _internal_byte_array_size() const;
  public:
  void clear_byte_array();
  const std::string& byte_array(int index) const;
  std::string* mutable_byte_array(int index);
  void set_byte_array(int index, const std::string& value);
  void set_byte_array(int index, std::string&& value);
  void set_byte_array(int index, const char* value);
  void set_byte_array(int index, const void* value, size_t size);
  std::string* add_byte_array();
  void add_byte_array(const std::string& value);
  void add_byte_array(std::string&& value);
  void add_byte_array(const char* value);
  void add_byte_array(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& byte_array() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_byte_array();
  private:
  const std::string& _internal_byte_array(int index) const;
  std::string* _internal_add_byte_array();
  public:

  // repeated string character_array = 8;
  int character_array_size() const;
  private:
  int _internal_character_array_size() const;
  public:
  void clear_character_array();
  const std::string& character_array(int index) const;
  std::string* mutable_character_array(int index);
  void set_character_array(int index, const std::string& value);
  void set_character_array(int index, std::string&& value);
  void set_character_array(int index, const char* value);
  void set_character_array(int index, const char* value, size_t size);
  std::string* add_character_array();
  void add_character_array(const std::string& value);
  void add_character_array(std::string&& value);
  void add_character_array(const char* value);
  void add_character_array(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& character_array() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_character_array();
  private:
  const std::string& _internal_character_array(int index) const;
  std::string* _internal_add_character_array();
  public:

  // repeated .mw.internal.robotics.gazebotransport.TestEnum enum_item = 9;
  int enum_item_size() const;
  private:
  int _internal_enum_item_size() const;
  public:
  void clear_enum_item();
  private:
  ::mw::internal::robotics::gazebotransport::TestEnum _internal_enum_item(int index) const;
  void _internal_add_enum_item(::mw::internal::robotics::gazebotransport::TestEnum value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_enum_item();
  public:
  ::mw::internal::robotics::gazebotransport::TestEnum enum_item(int index) const;
  void set_enum_item(int index, ::mw::internal::robotics::gazebotransport::TestEnum value);
  void add_enum_item(::mw::internal::robotics::gazebotransport::TestEnum value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& enum_item() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_enum_item();

  // repeated bool logical_item = 10;
  int logical_item_size() const;
  private:
  int _internal_logical_item_size() const;
  public:
  void clear_logical_item();
  private:
  bool _internal_logical_item(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_logical_item() const;
  void _internal_add_logical_item(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_logical_item();
  public:
  bool logical_item(int index) const;
  void set_logical_item(int index, bool value);
  void add_logical_item(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      logical_item() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_logical_item();

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.TestArrays)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > integer_64_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > unsigned_integer_64_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > integer_32_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > unsigned_integer_32_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > binary_64_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > binary_32_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> byte_array_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> character_array_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> enum_item_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > logical_item_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto;
};
// -------------------------------------------------------------------

class TestNestedMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.TestNestedMessage) */ {
 public:
  inline TestNestedMessage() : TestNestedMessage(nullptr) {};
  virtual ~TestNestedMessage();

  TestNestedMessage(const TestNestedMessage& from);
  TestNestedMessage(TestNestedMessage&& from) noexcept
    : TestNestedMessage() {
    *this = ::std::move(from);
  }

  inline TestNestedMessage& operator=(const TestNestedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestNestedMessage& operator=(TestNestedMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TestNestedMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestNestedMessage* internal_default_instance() {
    return reinterpret_cast<const TestNestedMessage*>(
               &_TestNestedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TestNestedMessage& a, TestNestedMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TestNestedMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestNestedMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TestNestedMessage* New() const final {
    return CreateMaybeMessage<TestNestedMessage>(nullptr);
  }

  TestNestedMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TestNestedMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TestNestedMessage& from);
  void MergeFrom(const TestNestedMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestNestedMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.TestNestedMessage";
  }
  protected:
  explicit TestNestedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArrayNestedMessageFieldNumber = 2,
    kScalarNestedMessageFieldNumber = 1,
  };
  // repeated .mw.internal.robotics.gazebotransport.TestScalars array_nested_message = 2;
  int array_nested_message_size() const;
  private:
  int _internal_array_nested_message_size() const;
  public:
  void clear_array_nested_message();
  ::mw::internal::robotics::gazebotransport::TestScalars* mutable_array_nested_message(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TestScalars >*
      mutable_array_nested_message();
  private:
  const ::mw::internal::robotics::gazebotransport::TestScalars& _internal_array_nested_message(int index) const;
  ::mw::internal::robotics::gazebotransport::TestScalars* _internal_add_array_nested_message();
  public:
  const ::mw::internal::robotics::gazebotransport::TestScalars& array_nested_message(int index) const;
  ::mw::internal::robotics::gazebotransport::TestScalars* add_array_nested_message();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TestScalars >&
      array_nested_message() const;

  // required .mw.internal.robotics.gazebotransport.TestScalars scalar_nested_message = 1;
  bool has_scalar_nested_message() const;
  private:
  bool _internal_has_scalar_nested_message() const;
  public:
  void clear_scalar_nested_message();
  const ::mw::internal::robotics::gazebotransport::TestScalars& scalar_nested_message() const;
  ::mw::internal::robotics::gazebotransport::TestScalars* release_scalar_nested_message();
  ::mw::internal::robotics::gazebotransport::TestScalars* mutable_scalar_nested_message();
  void set_allocated_scalar_nested_message(::mw::internal::robotics::gazebotransport::TestScalars* scalar_nested_message);
  private:
  const ::mw::internal::robotics::gazebotransport::TestScalars& _internal_scalar_nested_message() const;
  ::mw::internal::robotics::gazebotransport::TestScalars* _internal_mutable_scalar_nested_message();
  public:
  void unsafe_arena_set_allocated_scalar_nested_message(
      ::mw::internal::robotics::gazebotransport::TestScalars* scalar_nested_message);
  ::mw::internal::robotics::gazebotransport::TestScalars* unsafe_arena_release_scalar_nested_message();

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.TestNestedMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TestScalars > array_nested_message_;
  ::mw::internal::robotics::gazebotransport::TestScalars* scalar_nested_message_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto;
};
// -------------------------------------------------------------------

class TestMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.TestMessage) */ {
 public:
  inline TestMessage() : TestMessage(nullptr) {};
  virtual ~TestMessage();

  TestMessage(const TestMessage& from);
  TestMessage(TestMessage&& from) noexcept
    : TestMessage() {
    *this = ::std::move(from);
  }

  inline TestMessage& operator=(const TestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMessage& operator=(TestMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TestMessage& default_instance();

  enum PayloadCase {
    kTestScalar = 2,
    kTestArray = 3,
    kTestNestedMessage = 4,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestMessage* internal_default_instance() {
    return reinterpret_cast<const TestMessage*>(
               &_TestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TestMessage& a, TestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TestMessage* New() const final {
    return CreateMaybeMessage<TestMessage>(nullptr);
  }

  TestMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TestMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TestMessage& from);
  void MergeFrom(const TestMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.TestMessage";
  }
  protected:
  explicit TestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kTestScalarFieldNumber = 2,
    kTestArrayFieldNumber = 3,
    kTestNestedMessageFieldNumber = 4,
  };
  // required double header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  double header() const;
  void set_header(double value);
  private:
  double _internal_header() const;
  void _internal_set_header(double value);
  public:

  // .mw.internal.robotics.gazebotransport.TestScalars test_scalar = 2;
  bool has_test_scalar() const;
  private:
  bool _internal_has_test_scalar() const;
  public:
  void clear_test_scalar();
  const ::mw::internal::robotics::gazebotransport::TestScalars& test_scalar() const;
  ::mw::internal::robotics::gazebotransport::TestScalars* release_test_scalar();
  ::mw::internal::robotics::gazebotransport::TestScalars* mutable_test_scalar();
  void set_allocated_test_scalar(::mw::internal::robotics::gazebotransport::TestScalars* test_scalar);
  private:
  const ::mw::internal::robotics::gazebotransport::TestScalars& _internal_test_scalar() const;
  ::mw::internal::robotics::gazebotransport::TestScalars* _internal_mutable_test_scalar();
  public:
  void unsafe_arena_set_allocated_test_scalar(
      ::mw::internal::robotics::gazebotransport::TestScalars* test_scalar);
  ::mw::internal::robotics::gazebotransport::TestScalars* unsafe_arena_release_test_scalar();

  // .mw.internal.robotics.gazebotransport.TestArrays test_array = 3;
  bool has_test_array() const;
  private:
  bool _internal_has_test_array() const;
  public:
  void clear_test_array();
  const ::mw::internal::robotics::gazebotransport::TestArrays& test_array() const;
  ::mw::internal::robotics::gazebotransport::TestArrays* release_test_array();
  ::mw::internal::robotics::gazebotransport::TestArrays* mutable_test_array();
  void set_allocated_test_array(::mw::internal::robotics::gazebotransport::TestArrays* test_array);
  private:
  const ::mw::internal::robotics::gazebotransport::TestArrays& _internal_test_array() const;
  ::mw::internal::robotics::gazebotransport::TestArrays* _internal_mutable_test_array();
  public:
  void unsafe_arena_set_allocated_test_array(
      ::mw::internal::robotics::gazebotransport::TestArrays* test_array);
  ::mw::internal::robotics::gazebotransport::TestArrays* unsafe_arena_release_test_array();

  // .mw.internal.robotics.gazebotransport.TestNestedMessage test_nested_message = 4;
  bool has_test_nested_message() const;
  private:
  bool _internal_has_test_nested_message() const;
  public:
  void clear_test_nested_message();
  const ::mw::internal::robotics::gazebotransport::TestNestedMessage& test_nested_message() const;
  ::mw::internal::robotics::gazebotransport::TestNestedMessage* release_test_nested_message();
  ::mw::internal::robotics::gazebotransport::TestNestedMessage* mutable_test_nested_message();
  void set_allocated_test_nested_message(::mw::internal::robotics::gazebotransport::TestNestedMessage* test_nested_message);
  private:
  const ::mw::internal::robotics::gazebotransport::TestNestedMessage& _internal_test_nested_message() const;
  ::mw::internal::robotics::gazebotransport::TestNestedMessage* _internal_mutable_test_nested_message();
  public:
  void unsafe_arena_set_allocated_test_nested_message(
      ::mw::internal::robotics::gazebotransport::TestNestedMessage* test_nested_message);
  ::mw::internal::robotics::gazebotransport::TestNestedMessage* unsafe_arena_release_test_nested_message();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.TestMessage)
 private:
  class _Internal;
  void set_has_test_scalar();
  void set_has_test_array();
  void set_has_test_nested_message();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double header_;
  union PayloadUnion {
    PayloadUnion() {}
    ::mw::internal::robotics::gazebotransport::TestScalars* test_scalar_;
    ::mw::internal::robotics::gazebotransport::TestArrays* test_array_;
    ::mw::internal::robotics::gazebotransport::TestNestedMessage* test_nested_message_;
  } payload_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto;
};
// -------------------------------------------------------------------

class TestPose PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.TestPose) */ {
 public:
  inline TestPose() : TestPose(nullptr) {};
  virtual ~TestPose();

  TestPose(const TestPose& from);
  TestPose(TestPose&& from) noexcept
    : TestPose() {
    *this = ::std::move(from);
  }

  inline TestPose& operator=(const TestPose& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestPose& operator=(TestPose&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TestPose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestPose* internal_default_instance() {
    return reinterpret_cast<const TestPose*>(
               &_TestPose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TestPose& a, TestPose& b) {
    a.Swap(&b);
  }
  inline void Swap(TestPose* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestPose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TestPose* New() const final {
    return CreateMaybeMessage<TestPose>(nullptr);
  }

  TestPose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TestPose>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TestPose& from);
  void MergeFrom(const TestPose& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestPose* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mw.internal.robotics.gazebotransport.TestPose";
  }
  protected:
  explicit TestPose(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto);
    return ::descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // required double x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // required double y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // required double z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // required double w = 4;
  bool has_w() const;
  private:
  bool _internal_has_w() const;
  public:
  void clear_w();
  double w() const;
  void set_w(double value);
  private:
  double _internal_w() const;
  void _internal_set_w(double value);
  public:

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.TestPose)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double x_;
  double y_;
  double z_;
  double w_;
  friend struct ::TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TestScalars

// required int64 integer_64 = 1;
inline bool TestScalars::_internal_has_integer_64() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TestScalars::has_integer_64() const {
  return _internal_has_integer_64();
}
inline void TestScalars::clear_integer_64() {
  integer_64_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TestScalars::_internal_integer_64() const {
  return integer_64_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TestScalars::integer_64() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestScalars.integer_64)
  return _internal_integer_64();
}
inline void TestScalars::_internal_set_integer_64(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  integer_64_ = value;
}
inline void TestScalars::set_integer_64(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_integer_64(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestScalars.integer_64)
}

// required uint64 unsigned_integer_64 = 2;
inline bool TestScalars::_internal_has_unsigned_integer_64() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TestScalars::has_unsigned_integer_64() const {
  return _internal_has_unsigned_integer_64();
}
inline void TestScalars::clear_unsigned_integer_64() {
  unsigned_integer_64_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TestScalars::_internal_unsigned_integer_64() const {
  return unsigned_integer_64_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TestScalars::unsigned_integer_64() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestScalars.unsigned_integer_64)
  return _internal_unsigned_integer_64();
}
inline void TestScalars::_internal_set_unsigned_integer_64(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  unsigned_integer_64_ = value;
}
inline void TestScalars::set_unsigned_integer_64(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_unsigned_integer_64(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestScalars.unsigned_integer_64)
}

// required int32 integer_32 = 3;
inline bool TestScalars::_internal_has_integer_32() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TestScalars::has_integer_32() const {
  return _internal_has_integer_32();
}
inline void TestScalars::clear_integer_32() {
  integer_32_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TestScalars::_internal_integer_32() const {
  return integer_32_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TestScalars::integer_32() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestScalars.integer_32)
  return _internal_integer_32();
}
inline void TestScalars::_internal_set_integer_32(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  integer_32_ = value;
}
inline void TestScalars::set_integer_32(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_integer_32(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestScalars.integer_32)
}

// required uint32 unsigned_integer_32 = 4;
inline bool TestScalars::_internal_has_unsigned_integer_32() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TestScalars::has_unsigned_integer_32() const {
  return _internal_has_unsigned_integer_32();
}
inline void TestScalars::clear_unsigned_integer_32() {
  unsigned_integer_32_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TestScalars::_internal_unsigned_integer_32() const {
  return unsigned_integer_32_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TestScalars::unsigned_integer_32() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestScalars.unsigned_integer_32)
  return _internal_unsigned_integer_32();
}
inline void TestScalars::_internal_set_unsigned_integer_32(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  unsigned_integer_32_ = value;
}
inline void TestScalars::set_unsigned_integer_32(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_unsigned_integer_32(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestScalars.unsigned_integer_32)
}

// required double binary_64 = 5;
inline bool TestScalars::_internal_has_binary_64() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TestScalars::has_binary_64() const {
  return _internal_has_binary_64();
}
inline void TestScalars::clear_binary_64() {
  binary_64_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double TestScalars::_internal_binary_64() const {
  return binary_64_;
}
inline double TestScalars::binary_64() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestScalars.binary_64)
  return _internal_binary_64();
}
inline void TestScalars::_internal_set_binary_64(double value) {
  _has_bits_[0] |= 0x00000040u;
  binary_64_ = value;
}
inline void TestScalars::set_binary_64(double value) {
  _internal_set_binary_64(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestScalars.binary_64)
}

// required float binary_32 = 6;
inline bool TestScalars::_internal_has_binary_32() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TestScalars::has_binary_32() const {
  return _internal_has_binary_32();
}
inline void TestScalars::clear_binary_32() {
  binary_32_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float TestScalars::_internal_binary_32() const {
  return binary_32_;
}
inline float TestScalars::binary_32() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestScalars.binary_32)
  return _internal_binary_32();
}
inline void TestScalars::_internal_set_binary_32(float value) {
  _has_bits_[0] |= 0x00000080u;
  binary_32_ = value;
}
inline void TestScalars::set_binary_32(float value) {
  _internal_set_binary_32(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestScalars.binary_32)
}

// required bytes byte_array = 7;
inline bool TestScalars::_internal_has_byte_array() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestScalars::has_byte_array() const {
  return _internal_has_byte_array();
}
inline void TestScalars::clear_byte_array() {
  byte_array_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TestScalars::byte_array() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestScalars.byte_array)
  return _internal_byte_array();
}
inline void TestScalars::set_byte_array(const std::string& value) {
  _internal_set_byte_array(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestScalars.byte_array)
}
inline std::string* TestScalars::mutable_byte_array() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TestScalars.byte_array)
  return _internal_mutable_byte_array();
}
inline const std::string& TestScalars::_internal_byte_array() const {
  return byte_array_.Get();
}
inline void TestScalars::_internal_set_byte_array(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  byte_array_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TestScalars::set_byte_array(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  byte_array_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.TestScalars.byte_array)
}
inline void TestScalars::set_byte_array(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  byte_array_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.TestScalars.byte_array)
}
inline void TestScalars::set_byte_array(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  byte_array_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.TestScalars.byte_array)
}
inline std::string* TestScalars::_internal_mutable_byte_array() {
  _has_bits_[0] |= 0x00000001u;
  return byte_array_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TestScalars::release_byte_array() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.TestScalars.byte_array)
  if (!_internal_has_byte_array()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return byte_array_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TestScalars::set_allocated_byte_array(std::string* byte_array) {
  if (byte_array != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  byte_array_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), byte_array,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.TestScalars.byte_array)
}
inline std::string* TestScalars::unsafe_arena_release_byte_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.TestScalars.byte_array)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return byte_array_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TestScalars::unsafe_arena_set_allocated_byte_array(
    std::string* byte_array) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (byte_array != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  byte_array_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      byte_array, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.TestScalars.byte_array)
}

// required string character_array = 8;
inline bool TestScalars::_internal_has_character_array() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TestScalars::has_character_array() const {
  return _internal_has_character_array();
}
inline void TestScalars::clear_character_array() {
  character_array_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TestScalars::character_array() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestScalars.character_array)
  return _internal_character_array();
}
inline void TestScalars::set_character_array(const std::string& value) {
  _internal_set_character_array(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestScalars.character_array)
}
inline std::string* TestScalars::mutable_character_array() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TestScalars.character_array)
  return _internal_mutable_character_array();
}
inline const std::string& TestScalars::_internal_character_array() const {
  return character_array_.Get();
}
inline void TestScalars::_internal_set_character_array(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  character_array_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TestScalars::set_character_array(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  character_array_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.TestScalars.character_array)
}
inline void TestScalars::set_character_array(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  character_array_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.TestScalars.character_array)
}
inline void TestScalars::set_character_array(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  character_array_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.TestScalars.character_array)
}
inline std::string* TestScalars::_internal_mutable_character_array() {
  _has_bits_[0] |= 0x00000002u;
  return character_array_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TestScalars::release_character_array() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.TestScalars.character_array)
  if (!_internal_has_character_array()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return character_array_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TestScalars::set_allocated_character_array(std::string* character_array) {
  if (character_array != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  character_array_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), character_array,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.TestScalars.character_array)
}
inline std::string* TestScalars::unsafe_arena_release_character_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.TestScalars.character_array)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return character_array_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TestScalars::unsafe_arena_set_allocated_character_array(
    std::string* character_array) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (character_array != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  character_array_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      character_array, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.TestScalars.character_array)
}

// required .mw.internal.robotics.gazebotransport.TestEnum enum_item = 9;
inline bool TestScalars::_internal_has_enum_item() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TestScalars::has_enum_item() const {
  return _internal_has_enum_item();
}
inline void TestScalars::clear_enum_item() {
  enum_item_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::mw::internal::robotics::gazebotransport::TestEnum TestScalars::_internal_enum_item() const {
  return static_cast< ::mw::internal::robotics::gazebotransport::TestEnum >(enum_item_);
}
inline ::mw::internal::robotics::gazebotransport::TestEnum TestScalars::enum_item() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestScalars.enum_item)
  return _internal_enum_item();
}
inline void TestScalars::_internal_set_enum_item(::mw::internal::robotics::gazebotransport::TestEnum value) {
  assert(::mw::internal::robotics::gazebotransport::TestEnum_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  enum_item_ = value;
}
inline void TestScalars::set_enum_item(::mw::internal::robotics::gazebotransport::TestEnum value) {
  _internal_set_enum_item(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestScalars.enum_item)
}

// required bool logical_item = 10;
inline bool TestScalars::_internal_has_logical_item() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TestScalars::has_logical_item() const {
  return _internal_has_logical_item();
}
inline void TestScalars::clear_logical_item() {
  logical_item_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool TestScalars::_internal_logical_item() const {
  return logical_item_;
}
inline bool TestScalars::logical_item() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestScalars.logical_item)
  return _internal_logical_item();
}
inline void TestScalars::_internal_set_logical_item(bool value) {
  _has_bits_[0] |= 0x00000200u;
  logical_item_ = value;
}
inline void TestScalars::set_logical_item(bool value) {
  _internal_set_logical_item(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestScalars.logical_item)
}

// -------------------------------------------------------------------

// TestArrays

// repeated int64 integer_64 = 1;
inline int TestArrays::_internal_integer_64_size() const {
  return integer_64_.size();
}
inline int TestArrays::integer_64_size() const {
  return _internal_integer_64_size();
}
inline void TestArrays::clear_integer_64() {
  integer_64_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TestArrays::_internal_integer_64(int index) const {
  return integer_64_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TestArrays::integer_64(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestArrays.integer_64)
  return _internal_integer_64(index);
}
inline void TestArrays::set_integer_64(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  integer_64_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestArrays.integer_64)
}
inline void TestArrays::_internal_add_integer_64(::PROTOBUF_NAMESPACE_ID::int64 value) {
  integer_64_.Add(value);
}
inline void TestArrays::add_integer_64(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_integer_64(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TestArrays.integer_64)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
TestArrays::_internal_integer_64() const {
  return integer_64_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
TestArrays::integer_64() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.TestArrays.integer_64)
  return _internal_integer_64();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
TestArrays::_internal_mutable_integer_64() {
  return &integer_64_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
TestArrays::mutable_integer_64() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.TestArrays.integer_64)
  return _internal_mutable_integer_64();
}

// repeated uint64 unsigned_integer_64 = 2;
inline int TestArrays::_internal_unsigned_integer_64_size() const {
  return unsigned_integer_64_.size();
}
inline int TestArrays::unsigned_integer_64_size() const {
  return _internal_unsigned_integer_64_size();
}
inline void TestArrays::clear_unsigned_integer_64() {
  unsigned_integer_64_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TestArrays::_internal_unsigned_integer_64(int index) const {
  return unsigned_integer_64_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TestArrays::unsigned_integer_64(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestArrays.unsigned_integer_64)
  return _internal_unsigned_integer_64(index);
}
inline void TestArrays::set_unsigned_integer_64(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  unsigned_integer_64_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestArrays.unsigned_integer_64)
}
inline void TestArrays::_internal_add_unsigned_integer_64(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  unsigned_integer_64_.Add(value);
}
inline void TestArrays::add_unsigned_integer_64(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_add_unsigned_integer_64(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TestArrays.unsigned_integer_64)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
TestArrays::_internal_unsigned_integer_64() const {
  return unsigned_integer_64_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
TestArrays::unsigned_integer_64() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.TestArrays.unsigned_integer_64)
  return _internal_unsigned_integer_64();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
TestArrays::_internal_mutable_unsigned_integer_64() {
  return &unsigned_integer_64_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
TestArrays::mutable_unsigned_integer_64() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.TestArrays.unsigned_integer_64)
  return _internal_mutable_unsigned_integer_64();
}

// repeated int32 integer_32 = 3;
inline int TestArrays::_internal_integer_32_size() const {
  return integer_32_.size();
}
inline int TestArrays::integer_32_size() const {
  return _internal_integer_32_size();
}
inline void TestArrays::clear_integer_32() {
  integer_32_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TestArrays::_internal_integer_32(int index) const {
  return integer_32_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TestArrays::integer_32(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestArrays.integer_32)
  return _internal_integer_32(index);
}
inline void TestArrays::set_integer_32(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  integer_32_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestArrays.integer_32)
}
inline void TestArrays::_internal_add_integer_32(::PROTOBUF_NAMESPACE_ID::int32 value) {
  integer_32_.Add(value);
}
inline void TestArrays::add_integer_32(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_integer_32(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TestArrays.integer_32)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
TestArrays::_internal_integer_32() const {
  return integer_32_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
TestArrays::integer_32() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.TestArrays.integer_32)
  return _internal_integer_32();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
TestArrays::_internal_mutable_integer_32() {
  return &integer_32_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
TestArrays::mutable_integer_32() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.TestArrays.integer_32)
  return _internal_mutable_integer_32();
}

// repeated uint32 unsigned_integer_32 = 4;
inline int TestArrays::_internal_unsigned_integer_32_size() const {
  return unsigned_integer_32_.size();
}
inline int TestArrays::unsigned_integer_32_size() const {
  return _internal_unsigned_integer_32_size();
}
inline void TestArrays::clear_unsigned_integer_32() {
  unsigned_integer_32_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TestArrays::_internal_unsigned_integer_32(int index) const {
  return unsigned_integer_32_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TestArrays::unsigned_integer_32(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestArrays.unsigned_integer_32)
  return _internal_unsigned_integer_32(index);
}
inline void TestArrays::set_unsigned_integer_32(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  unsigned_integer_32_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestArrays.unsigned_integer_32)
}
inline void TestArrays::_internal_add_unsigned_integer_32(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  unsigned_integer_32_.Add(value);
}
inline void TestArrays::add_unsigned_integer_32(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_unsigned_integer_32(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TestArrays.unsigned_integer_32)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
TestArrays::_internal_unsigned_integer_32() const {
  return unsigned_integer_32_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
TestArrays::unsigned_integer_32() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.TestArrays.unsigned_integer_32)
  return _internal_unsigned_integer_32();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
TestArrays::_internal_mutable_unsigned_integer_32() {
  return &unsigned_integer_32_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
TestArrays::mutable_unsigned_integer_32() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.TestArrays.unsigned_integer_32)
  return _internal_mutable_unsigned_integer_32();
}

// repeated double binary_64 = 5;
inline int TestArrays::_internal_binary_64_size() const {
  return binary_64_.size();
}
inline int TestArrays::binary_64_size() const {
  return _internal_binary_64_size();
}
inline void TestArrays::clear_binary_64() {
  binary_64_.Clear();
}
inline double TestArrays::_internal_binary_64(int index) const {
  return binary_64_.Get(index);
}
inline double TestArrays::binary_64(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestArrays.binary_64)
  return _internal_binary_64(index);
}
inline void TestArrays::set_binary_64(int index, double value) {
  binary_64_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestArrays.binary_64)
}
inline void TestArrays::_internal_add_binary_64(double value) {
  binary_64_.Add(value);
}
inline void TestArrays::add_binary_64(double value) {
  _internal_add_binary_64(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TestArrays.binary_64)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
TestArrays::_internal_binary_64() const {
  return binary_64_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
TestArrays::binary_64() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.TestArrays.binary_64)
  return _internal_binary_64();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
TestArrays::_internal_mutable_binary_64() {
  return &binary_64_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
TestArrays::mutable_binary_64() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.TestArrays.binary_64)
  return _internal_mutable_binary_64();
}

// repeated float binary_32 = 6;
inline int TestArrays::_internal_binary_32_size() const {
  return binary_32_.size();
}
inline int TestArrays::binary_32_size() const {
  return _internal_binary_32_size();
}
inline void TestArrays::clear_binary_32() {
  binary_32_.Clear();
}
inline float TestArrays::_internal_binary_32(int index) const {
  return binary_32_.Get(index);
}
inline float TestArrays::binary_32(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestArrays.binary_32)
  return _internal_binary_32(index);
}
inline void TestArrays::set_binary_32(int index, float value) {
  binary_32_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestArrays.binary_32)
}
inline void TestArrays::_internal_add_binary_32(float value) {
  binary_32_.Add(value);
}
inline void TestArrays::add_binary_32(float value) {
  _internal_add_binary_32(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TestArrays.binary_32)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
TestArrays::_internal_binary_32() const {
  return binary_32_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
TestArrays::binary_32() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.TestArrays.binary_32)
  return _internal_binary_32();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
TestArrays::_internal_mutable_binary_32() {
  return &binary_32_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
TestArrays::mutable_binary_32() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.TestArrays.binary_32)
  return _internal_mutable_binary_32();
}

// repeated bytes byte_array = 7;
inline int TestArrays::_internal_byte_array_size() const {
  return byte_array_.size();
}
inline int TestArrays::byte_array_size() const {
  return _internal_byte_array_size();
}
inline void TestArrays::clear_byte_array() {
  byte_array_.Clear();
}
inline std::string* TestArrays::add_byte_array() {
  // @@protoc_insertion_point(field_add_mutable:mw.internal.robotics.gazebotransport.TestArrays.byte_array)
  return _internal_add_byte_array();
}
inline const std::string& TestArrays::_internal_byte_array(int index) const {
  return byte_array_.Get(index);
}
inline const std::string& TestArrays::byte_array(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestArrays.byte_array)
  return _internal_byte_array(index);
}
inline std::string* TestArrays::mutable_byte_array(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TestArrays.byte_array)
  return byte_array_.Mutable(index);
}
inline void TestArrays::set_byte_array(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestArrays.byte_array)
  byte_array_.Mutable(index)->assign(value);
}
inline void TestArrays::set_byte_array(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestArrays.byte_array)
  byte_array_.Mutable(index)->assign(std::move(value));
}
inline void TestArrays::set_byte_array(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  byte_array_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.TestArrays.byte_array)
}
inline void TestArrays::set_byte_array(int index, const void* value, size_t size) {
  byte_array_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.TestArrays.byte_array)
}
inline std::string* TestArrays::_internal_add_byte_array() {
  return byte_array_.Add();
}
inline void TestArrays::add_byte_array(const std::string& value) {
  byte_array_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TestArrays.byte_array)
}
inline void TestArrays::add_byte_array(std::string&& value) {
  byte_array_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TestArrays.byte_array)
}
inline void TestArrays::add_byte_array(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  byte_array_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mw.internal.robotics.gazebotransport.TestArrays.byte_array)
}
inline void TestArrays::add_byte_array(const void* value, size_t size) {
  byte_array_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mw.internal.robotics.gazebotransport.TestArrays.byte_array)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TestArrays::byte_array() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.TestArrays.byte_array)
  return byte_array_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TestArrays::mutable_byte_array() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.TestArrays.byte_array)
  return &byte_array_;
}

// repeated string character_array = 8;
inline int TestArrays::_internal_character_array_size() const {
  return character_array_.size();
}
inline int TestArrays::character_array_size() const {
  return _internal_character_array_size();
}
inline void TestArrays::clear_character_array() {
  character_array_.Clear();
}
inline std::string* TestArrays::add_character_array() {
  // @@protoc_insertion_point(field_add_mutable:mw.internal.robotics.gazebotransport.TestArrays.character_array)
  return _internal_add_character_array();
}
inline const std::string& TestArrays::_internal_character_array(int index) const {
  return character_array_.Get(index);
}
inline const std::string& TestArrays::character_array(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestArrays.character_array)
  return _internal_character_array(index);
}
inline std::string* TestArrays::mutable_character_array(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TestArrays.character_array)
  return character_array_.Mutable(index);
}
inline void TestArrays::set_character_array(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestArrays.character_array)
  character_array_.Mutable(index)->assign(value);
}
inline void TestArrays::set_character_array(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestArrays.character_array)
  character_array_.Mutable(index)->assign(std::move(value));
}
inline void TestArrays::set_character_array(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  character_array_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.TestArrays.character_array)
}
inline void TestArrays::set_character_array(int index, const char* value, size_t size) {
  character_array_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.TestArrays.character_array)
}
inline std::string* TestArrays::_internal_add_character_array() {
  return character_array_.Add();
}
inline void TestArrays::add_character_array(const std::string& value) {
  character_array_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TestArrays.character_array)
}
inline void TestArrays::add_character_array(std::string&& value) {
  character_array_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TestArrays.character_array)
}
inline void TestArrays::add_character_array(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  character_array_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mw.internal.robotics.gazebotransport.TestArrays.character_array)
}
inline void TestArrays::add_character_array(const char* value, size_t size) {
  character_array_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mw.internal.robotics.gazebotransport.TestArrays.character_array)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TestArrays::character_array() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.TestArrays.character_array)
  return character_array_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TestArrays::mutable_character_array() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.TestArrays.character_array)
  return &character_array_;
}

// repeated .mw.internal.robotics.gazebotransport.TestEnum enum_item = 9;
inline int TestArrays::_internal_enum_item_size() const {
  return enum_item_.size();
}
inline int TestArrays::enum_item_size() const {
  return _internal_enum_item_size();
}
inline void TestArrays::clear_enum_item() {
  enum_item_.Clear();
}
inline ::mw::internal::robotics::gazebotransport::TestEnum TestArrays::_internal_enum_item(int index) const {
  return static_cast< ::mw::internal::robotics::gazebotransport::TestEnum >(enum_item_.Get(index));
}
inline ::mw::internal::robotics::gazebotransport::TestEnum TestArrays::enum_item(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestArrays.enum_item)
  return _internal_enum_item(index);
}
inline void TestArrays::set_enum_item(int index, ::mw::internal::robotics::gazebotransport::TestEnum value) {
  assert(::mw::internal::robotics::gazebotransport::TestEnum_IsValid(value));
  enum_item_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestArrays.enum_item)
}
inline void TestArrays::_internal_add_enum_item(::mw::internal::robotics::gazebotransport::TestEnum value) {
  assert(::mw::internal::robotics::gazebotransport::TestEnum_IsValid(value));
  enum_item_.Add(value);
}
inline void TestArrays::add_enum_item(::mw::internal::robotics::gazebotransport::TestEnum value) {
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TestArrays.enum_item)
  _internal_add_enum_item(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
TestArrays::enum_item() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.TestArrays.enum_item)
  return enum_item_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TestArrays::_internal_mutable_enum_item() {
  return &enum_item_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TestArrays::mutable_enum_item() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.TestArrays.enum_item)
  return _internal_mutable_enum_item();
}

// repeated bool logical_item = 10;
inline int TestArrays::_internal_logical_item_size() const {
  return logical_item_.size();
}
inline int TestArrays::logical_item_size() const {
  return _internal_logical_item_size();
}
inline void TestArrays::clear_logical_item() {
  logical_item_.Clear();
}
inline bool TestArrays::_internal_logical_item(int index) const {
  return logical_item_.Get(index);
}
inline bool TestArrays::logical_item(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestArrays.logical_item)
  return _internal_logical_item(index);
}
inline void TestArrays::set_logical_item(int index, bool value) {
  logical_item_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestArrays.logical_item)
}
inline void TestArrays::_internal_add_logical_item(bool value) {
  logical_item_.Add(value);
}
inline void TestArrays::add_logical_item(bool value) {
  _internal_add_logical_item(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TestArrays.logical_item)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
TestArrays::_internal_logical_item() const {
  return logical_item_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
TestArrays::logical_item() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.TestArrays.logical_item)
  return _internal_logical_item();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
TestArrays::_internal_mutable_logical_item() {
  return &logical_item_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
TestArrays::mutable_logical_item() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.TestArrays.logical_item)
  return _internal_mutable_logical_item();
}

// -------------------------------------------------------------------

// TestNestedMessage

// required .mw.internal.robotics.gazebotransport.TestScalars scalar_nested_message = 1;
inline bool TestNestedMessage::_internal_has_scalar_nested_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || scalar_nested_message_ != nullptr);
  return value;
}
inline bool TestNestedMessage::has_scalar_nested_message() const {
  return _internal_has_scalar_nested_message();
}
inline void TestNestedMessage::clear_scalar_nested_message() {
  if (scalar_nested_message_ != nullptr) scalar_nested_message_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mw::internal::robotics::gazebotransport::TestScalars& TestNestedMessage::_internal_scalar_nested_message() const {
  const ::mw::internal::robotics::gazebotransport::TestScalars* p = scalar_nested_message_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::TestScalars*>(
      &::mw::internal::robotics::gazebotransport::_TestScalars_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::TestScalars& TestNestedMessage::scalar_nested_message() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestNestedMessage.scalar_nested_message)
  return _internal_scalar_nested_message();
}
inline void TestNestedMessage::unsafe_arena_set_allocated_scalar_nested_message(
    ::mw::internal::robotics::gazebotransport::TestScalars* scalar_nested_message) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scalar_nested_message_);
  }
  scalar_nested_message_ = scalar_nested_message;
  if (scalar_nested_message) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.TestNestedMessage.scalar_nested_message)
}
inline ::mw::internal::robotics::gazebotransport::TestScalars* TestNestedMessage::release_scalar_nested_message() {
  auto temp = unsafe_arena_release_scalar_nested_message();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::TestScalars* TestNestedMessage::unsafe_arena_release_scalar_nested_message() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.TestNestedMessage.scalar_nested_message)
  _has_bits_[0] &= ~0x00000001u;
  ::mw::internal::robotics::gazebotransport::TestScalars* temp = scalar_nested_message_;
  scalar_nested_message_ = nullptr;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::TestScalars* TestNestedMessage::_internal_mutable_scalar_nested_message() {
  _has_bits_[0] |= 0x00000001u;
  if (scalar_nested_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::TestScalars>(GetArena());
    scalar_nested_message_ = p;
  }
  return scalar_nested_message_;
}
inline ::mw::internal::robotics::gazebotransport::TestScalars* TestNestedMessage::mutable_scalar_nested_message() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TestNestedMessage.scalar_nested_message)
  return _internal_mutable_scalar_nested_message();
}
inline void TestNestedMessage::set_allocated_scalar_nested_message(::mw::internal::robotics::gazebotransport::TestScalars* scalar_nested_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete scalar_nested_message_;
  }
  if (scalar_nested_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(scalar_nested_message);
    if (message_arena != submessage_arena) {
      scalar_nested_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scalar_nested_message, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  scalar_nested_message_ = scalar_nested_message;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.TestNestedMessage.scalar_nested_message)
}

// repeated .mw.internal.robotics.gazebotransport.TestScalars array_nested_message = 2;
inline int TestNestedMessage::_internal_array_nested_message_size() const {
  return array_nested_message_.size();
}
inline int TestNestedMessage::array_nested_message_size() const {
  return _internal_array_nested_message_size();
}
inline void TestNestedMessage::clear_array_nested_message() {
  array_nested_message_.Clear();
}
inline ::mw::internal::robotics::gazebotransport::TestScalars* TestNestedMessage::mutable_array_nested_message(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TestNestedMessage.array_nested_message)
  return array_nested_message_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TestScalars >*
TestNestedMessage::mutable_array_nested_message() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.TestNestedMessage.array_nested_message)
  return &array_nested_message_;
}
inline const ::mw::internal::robotics::gazebotransport::TestScalars& TestNestedMessage::_internal_array_nested_message(int index) const {
  return array_nested_message_.Get(index);
}
inline const ::mw::internal::robotics::gazebotransport::TestScalars& TestNestedMessage::array_nested_message(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestNestedMessage.array_nested_message)
  return _internal_array_nested_message(index);
}
inline ::mw::internal::robotics::gazebotransport::TestScalars* TestNestedMessage::_internal_add_array_nested_message() {
  return array_nested_message_.Add();
}
inline ::mw::internal::robotics::gazebotransport::TestScalars* TestNestedMessage::add_array_nested_message() {
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TestNestedMessage.array_nested_message)
  return _internal_add_array_nested_message();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TestScalars >&
TestNestedMessage::array_nested_message() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.TestNestedMessage.array_nested_message)
  return array_nested_message_;
}

// -------------------------------------------------------------------

// TestMessage

// required double header = 1;
inline bool TestMessage::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestMessage::has_header() const {
  return _internal_has_header();
}
inline void TestMessage::clear_header() {
  header_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double TestMessage::_internal_header() const {
  return header_;
}
inline double TestMessage::header() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestMessage.header)
  return _internal_header();
}
inline void TestMessage::_internal_set_header(double value) {
  _has_bits_[0] |= 0x00000001u;
  header_ = value;
}
inline void TestMessage::set_header(double value) {
  _internal_set_header(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestMessage.header)
}

// .mw.internal.robotics.gazebotransport.TestScalars test_scalar = 2;
inline bool TestMessage::_internal_has_test_scalar() const {
  return payload_case() == kTestScalar;
}
inline bool TestMessage::has_test_scalar() const {
  return _internal_has_test_scalar();
}
inline void TestMessage::set_has_test_scalar() {
  _oneof_case_[0] = kTestScalar;
}
inline void TestMessage::clear_test_scalar() {
  if (_internal_has_test_scalar()) {
    if (GetArena() == nullptr) {
      delete payload_.test_scalar_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::TestScalars* TestMessage::release_test_scalar() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.TestMessage.test_scalar)
  if (_internal_has_test_scalar()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::TestScalars* temp = payload_.test_scalar_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.test_scalar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::TestScalars& TestMessage::_internal_test_scalar() const {
  return _internal_has_test_scalar()
      ? *payload_.test_scalar_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::TestScalars*>(&::mw::internal::robotics::gazebotransport::_TestScalars_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::TestScalars& TestMessage::test_scalar() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestMessage.test_scalar)
  return _internal_test_scalar();
}
inline ::mw::internal::robotics::gazebotransport::TestScalars* TestMessage::unsafe_arena_release_test_scalar() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.TestMessage.test_scalar)
  if (_internal_has_test_scalar()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::TestScalars* temp = payload_.test_scalar_;
    payload_.test_scalar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestMessage::unsafe_arena_set_allocated_test_scalar(::mw::internal::robotics::gazebotransport::TestScalars* test_scalar) {
  clear_payload();
  if (test_scalar) {
    set_has_test_scalar();
    payload_.test_scalar_ = test_scalar;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.TestMessage.test_scalar)
}
inline ::mw::internal::robotics::gazebotransport::TestScalars* TestMessage::_internal_mutable_test_scalar() {
  if (!_internal_has_test_scalar()) {
    clear_payload();
    set_has_test_scalar();
    payload_.test_scalar_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::TestScalars >(GetArena());
  }
  return payload_.test_scalar_;
}
inline ::mw::internal::robotics::gazebotransport::TestScalars* TestMessage::mutable_test_scalar() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TestMessage.test_scalar)
  return _internal_mutable_test_scalar();
}

// .mw.internal.robotics.gazebotransport.TestArrays test_array = 3;
inline bool TestMessage::_internal_has_test_array() const {
  return payload_case() == kTestArray;
}
inline bool TestMessage::has_test_array() const {
  return _internal_has_test_array();
}
inline void TestMessage::set_has_test_array() {
  _oneof_case_[0] = kTestArray;
}
inline void TestMessage::clear_test_array() {
  if (_internal_has_test_array()) {
    if (GetArena() == nullptr) {
      delete payload_.test_array_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::TestArrays* TestMessage::release_test_array() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.TestMessage.test_array)
  if (_internal_has_test_array()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::TestArrays* temp = payload_.test_array_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.test_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::TestArrays& TestMessage::_internal_test_array() const {
  return _internal_has_test_array()
      ? *payload_.test_array_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::TestArrays*>(&::mw::internal::robotics::gazebotransport::_TestArrays_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::TestArrays& TestMessage::test_array() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestMessage.test_array)
  return _internal_test_array();
}
inline ::mw::internal::robotics::gazebotransport::TestArrays* TestMessage::unsafe_arena_release_test_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.TestMessage.test_array)
  if (_internal_has_test_array()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::TestArrays* temp = payload_.test_array_;
    payload_.test_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestMessage::unsafe_arena_set_allocated_test_array(::mw::internal::robotics::gazebotransport::TestArrays* test_array) {
  clear_payload();
  if (test_array) {
    set_has_test_array();
    payload_.test_array_ = test_array;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.TestMessage.test_array)
}
inline ::mw::internal::robotics::gazebotransport::TestArrays* TestMessage::_internal_mutable_test_array() {
  if (!_internal_has_test_array()) {
    clear_payload();
    set_has_test_array();
    payload_.test_array_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::TestArrays >(GetArena());
  }
  return payload_.test_array_;
}
inline ::mw::internal::robotics::gazebotransport::TestArrays* TestMessage::mutable_test_array() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TestMessage.test_array)
  return _internal_mutable_test_array();
}

// .mw.internal.robotics.gazebotransport.TestNestedMessage test_nested_message = 4;
inline bool TestMessage::_internal_has_test_nested_message() const {
  return payload_case() == kTestNestedMessage;
}
inline bool TestMessage::has_test_nested_message() const {
  return _internal_has_test_nested_message();
}
inline void TestMessage::set_has_test_nested_message() {
  _oneof_case_[0] = kTestNestedMessage;
}
inline void TestMessage::clear_test_nested_message() {
  if (_internal_has_test_nested_message()) {
    if (GetArena() == nullptr) {
      delete payload_.test_nested_message_;
    }
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::TestNestedMessage* TestMessage::release_test_nested_message() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.TestMessage.test_nested_message)
  if (_internal_has_test_nested_message()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::TestNestedMessage* temp = payload_.test_nested_message_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.test_nested_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mw::internal::robotics::gazebotransport::TestNestedMessage& TestMessage::_internal_test_nested_message() const {
  return _internal_has_test_nested_message()
      ? *payload_.test_nested_message_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::TestNestedMessage*>(&::mw::internal::robotics::gazebotransport::_TestNestedMessage_default_instance_);
}
inline const ::mw::internal::robotics::gazebotransport::TestNestedMessage& TestMessage::test_nested_message() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestMessage.test_nested_message)
  return _internal_test_nested_message();
}
inline ::mw::internal::robotics::gazebotransport::TestNestedMessage* TestMessage::unsafe_arena_release_test_nested_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mw.internal.robotics.gazebotransport.TestMessage.test_nested_message)
  if (_internal_has_test_nested_message()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::TestNestedMessage* temp = payload_.test_nested_message_;
    payload_.test_nested_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestMessage::unsafe_arena_set_allocated_test_nested_message(::mw::internal::robotics::gazebotransport::TestNestedMessage* test_nested_message) {
  clear_payload();
  if (test_nested_message) {
    set_has_test_nested_message();
    payload_.test_nested_message_ = test_nested_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mw.internal.robotics.gazebotransport.TestMessage.test_nested_message)
}
inline ::mw::internal::robotics::gazebotransport::TestNestedMessage* TestMessage::_internal_mutable_test_nested_message() {
  if (!_internal_has_test_nested_message()) {
    clear_payload();
    set_has_test_nested_message();
    payload_.test_nested_message_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::TestNestedMessage >(GetArena());
  }
  return payload_.test_nested_message_;
}
inline ::mw::internal::robotics::gazebotransport::TestNestedMessage* TestMessage::mutable_test_nested_message() {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TestMessage.test_nested_message)
  return _internal_mutable_test_nested_message();
}

inline bool TestMessage::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void TestMessage::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline TestMessage::PayloadCase TestMessage::payload_case() const {
  return TestMessage::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TestPose

// required double x = 1;
inline bool TestPose::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestPose::has_x() const {
  return _internal_has_x();
}
inline void TestPose::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double TestPose::_internal_x() const {
  return x_;
}
inline double TestPose::x() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestPose.x)
  return _internal_x();
}
inline void TestPose::_internal_set_x(double value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void TestPose::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestPose.x)
}

// required double y = 2;
inline bool TestPose::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TestPose::has_y() const {
  return _internal_has_y();
}
inline void TestPose::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double TestPose::_internal_y() const {
  return y_;
}
inline double TestPose::y() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestPose.y)
  return _internal_y();
}
inline void TestPose::_internal_set_y(double value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void TestPose::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestPose.y)
}

// required double z = 3;
inline bool TestPose::_internal_has_z() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TestPose::has_z() const {
  return _internal_has_z();
}
inline void TestPose::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double TestPose::_internal_z() const {
  return z_;
}
inline double TestPose::z() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestPose.z)
  return _internal_z();
}
inline void TestPose::_internal_set_z(double value) {
  _has_bits_[0] |= 0x00000004u;
  z_ = value;
}
inline void TestPose::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestPose.z)
}

// required double w = 4;
inline bool TestPose::_internal_has_w() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TestPose::has_w() const {
  return _internal_has_w();
}
inline void TestPose::clear_w() {
  w_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double TestPose::_internal_w() const {
  return w_;
}
inline double TestPose::w() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestPose.w)
  return _internal_w();
}
inline void TestPose::_internal_set_w(double value) {
  _has_bits_[0] |= 0x00000008u;
  w_ = value;
}
inline void TestPose::set_w(double value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestPose.w)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace gazebotransport
}  // namespace robotics
}  // namespace internal
}  // namespace mw

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::mw::internal::robotics::gazebotransport::TestEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mw::internal::robotics::gazebotransport::TestEnum>() {
  return ::mw::internal::robotics::gazebotransport::TestEnum_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto
