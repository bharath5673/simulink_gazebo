// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mw.internal.robotics.gazebotransport.CoSimMsgs.proto

#include "mw.internal.robotics.gazebotransport.CoSimMsgs.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ApplyJointTorque_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ApplyLinkWrench_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Axis_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CustomMessageSupport_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GazeboModelSDF_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_Gazebomodel_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GetGazeboModelParam_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GetGazeboModelSDF_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GetGroundTruthWorldPose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GetJointState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GetLinkState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GetModelInfo_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GetPose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GetTopicList_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Image_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_ImuData_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_InitCustomPublisher_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_InitCustomSubscriber_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_JointState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_LaserData_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_LinkState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ML_Axis_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ML_Inertial_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_ML_Joints_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_ML_Links_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ML_Point_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_ML_Pose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ML_Quat_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MaxStepSize_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ModelInfo_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ModelInfo_JOINTS_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ModelInfo_LINKS_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_ModelInfo_Model_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_PacketHeader_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Point_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_Pose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Quaternion_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RequestCoSim_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RequestCustomMessageSupport_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RequestImage_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RequestImu_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RequestLaser_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ResetSimulation_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_SetJointPosition_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_SetJointVelocity_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_SetLinkAngularVelocity_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_SetLinkLinearVelocity_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_SetLinkWorldPose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StepSimulation_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StopCoSim_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StopSimulation_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SubscribeImage_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SubscribeImu_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SubscribeLaser_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Time_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TopicList_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TopicList_TopicInfo_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto;
namespace mw {
namespace internal {
namespace robotics {
namespace gazebotransport {
class PluginVersionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PluginVersion> _instance;
} _PluginVersion_default_instance_;
class TimeDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Time> _instance;
} _Time_default_instance_;
class PacketHeaderDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PacketHeader> _instance;
} _PacketHeader_default_instance_;
class PacketDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Packet> _instance;
  int status_;
  const ::mw::internal::robotics::gazebotransport::StepSimulation* step_simulation_;
  const ::mw::internal::robotics::gazebotransport::ResetSimulation* reset_simulation_;
  const ::mw::internal::robotics::gazebotransport::Image* image_;
  const ::mw::internal::robotics::gazebotransport::RequestImage* request_image_;
  const ::mw::internal::robotics::gazebotransport::RequestCoSim* request_cosim_;
  const ::mw::internal::robotics::gazebotransport::StopCoSim* stop_cosim_;
  const ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* get_ground_truth_world_pose_;
  const ::mw::internal::robotics::gazebotransport::Pose* pose_;
  const ::mw::internal::robotics::gazebotransport::StopSimulation* stop_simulation_;
  const ::mw::internal::robotics::gazebotransport::LaserData* laser_data_;
  const ::mw::internal::robotics::gazebotransport::RequestLaser* request_laser_;
  const ::mw::internal::robotics::gazebotransport::ImuData* imu_data_;
  const ::mw::internal::robotics::gazebotransport::RequestImu* request_imu_;
  const ::mw::internal::robotics::gazebotransport::SubscribeImage* subscribe_image_;
  const ::mw::internal::robotics::gazebotransport::SubscribeLaser* subscribe_laser_;
  const ::mw::internal::robotics::gazebotransport::SubscribeImu* subscribe_imu_;
  const ::mw::internal::robotics::gazebotransport::ApplyJointTorque* apply_joint_torque_;
  const ::mw::internal::robotics::gazebotransport::GetPose* get_pose_;
  const ::mw::internal::robotics::gazebotransport::GetTopicList* get_topic_list_;
  const ::mw::internal::robotics::gazebotransport::TopicList* topic_list_;
  const ::mw::internal::robotics::gazebotransport::GetModelInfo* get_model_info_;
  const ::mw::internal::robotics::gazebotransport::ModelInfo* model_info_;
  const ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* apply_link_wrench_;
  const ::mw::internal::robotics::gazebotransport::MaxStepSize* max_step_size_;
  const ::mw::internal::robotics::gazebotransport::CustomMessageSupport* custom_message_support_;
  const ::mw::internal::robotics::gazebotransport::InitCustomPublisher* init_custom_publisher_;
  const ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* init_custom_subscriber_;
  const ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* request_custom_message_support_;
  const ::mw::internal::robotics::gazebotransport::SetJointPosition* set_joint_position_;
  const ::mw::internal::robotics::gazebotransport::SetJointVelocity* set_joint_velocity_;
  const ::mw::internal::robotics::gazebotransport::GetJointState* get_joint_state_;
  const ::mw::internal::robotics::gazebotransport::JointState* joint_state_;
  const ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* set_link_world_pose_;
  const ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* set_link_linear_velocity_;
  const ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* set_link_angular_velocity_;
  const ::mw::internal::robotics::gazebotransport::GetLinkState* get_link_state_;
  const ::mw::internal::robotics::gazebotransport::LinkState* link_state_;
  const ::mw::internal::robotics::gazebotransport::Gazebomodel* gazebo_model_;
  const ::mw::internal::robotics::gazebotransport::GetGazeboModelParam* get_gazebo_model_param_;
  const ::mw::internal::robotics::gazebotransport::GazeboModelSDF* gazebo_model_sdf_;
  const ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* get_gazebo_model_sdf_;
} _Packet_default_instance_;
class StepSimulationDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StepSimulation> _instance;
} _StepSimulation_default_instance_;
class ResetSimulationDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ResetSimulation> _instance;
} _ResetSimulation_default_instance_;
class ImageDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Image> _instance;
} _Image_default_instance_;
class RequestImageDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RequestImage> _instance;
} _RequestImage_default_instance_;
class RequestCoSimDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RequestCoSim> _instance;
} _RequestCoSim_default_instance_;
class StopCoSimDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StopCoSim> _instance;
} _StopCoSim_default_instance_;
class GetGroundTruthWorldPoseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<GetGroundTruthWorldPose> _instance;
} _GetGroundTruthWorldPose_default_instance_;
class PointDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Point> _instance;
} _Point_default_instance_;
class QuaternionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Quaternion> _instance;
} _Quaternion_default_instance_;
class PoseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Pose> _instance;
} _Pose_default_instance_;
class StopSimulationDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StopSimulation> _instance;
} _StopSimulation_default_instance_;
class LaserDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LaserData> _instance;
} _LaserData_default_instance_;
class RequestLaserDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RequestLaser> _instance;
} _RequestLaser_default_instance_;
class ImuDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ImuData> _instance;
} _ImuData_default_instance_;
class RequestImuDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RequestImu> _instance;
} _RequestImu_default_instance_;
class SubscribeImageDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SubscribeImage> _instance;
} _SubscribeImage_default_instance_;
class SubscribeLaserDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SubscribeLaser> _instance;
} _SubscribeLaser_default_instance_;
class SubscribeImuDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SubscribeImu> _instance;
} _SubscribeImu_default_instance_;
class ApplyLinkWrenchDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ApplyLinkWrench> _instance;
} _ApplyLinkWrench_default_instance_;
class ApplyJointTorqueDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ApplyJointTorque> _instance;
} _ApplyJointTorque_default_instance_;
class GetPoseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<GetPose> _instance;
} _GetPose_default_instance_;
class GetTopicListDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<GetTopicList> _instance;
} _GetTopicList_default_instance_;
class TopicList_TopicInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TopicList_TopicInfo> _instance;
} _TopicList_TopicInfo_default_instance_;
class TopicListDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TopicList> _instance;
} _TopicList_default_instance_;
class GetModelInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<GetModelInfo> _instance;
} _GetModelInfo_default_instance_;
class ModelInfo_LINKSDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ModelInfo_LINKS> _instance;
} _ModelInfo_LINKS_default_instance_;
class ModelInfo_JOINTSDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ModelInfo_JOINTS> _instance;
} _ModelInfo_JOINTS_default_instance_;
class ModelInfo_ModelDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ModelInfo_Model> _instance;
} _ModelInfo_Model_default_instance_;
class ModelInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ModelInfo> _instance;
} _ModelInfo_default_instance_;
class MaxStepSizeDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MaxStepSize> _instance;
} _MaxStepSize_default_instance_;
class InitCustomPublisherDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<InitCustomPublisher> _instance;
} _InitCustomPublisher_default_instance_;
class InitCustomSubscriberDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<InitCustomSubscriber> _instance;
} _InitCustomSubscriber_default_instance_;
class CustomMessageSupportDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CustomMessageSupport> _instance;
} _CustomMessageSupport_default_instance_;
class RequestCustomMessageSupportDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RequestCustomMessageSupport> _instance;
} _RequestCustomMessageSupport_default_instance_;
class SetJointPositionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SetJointPosition> _instance;
} _SetJointPosition_default_instance_;
class SetJointVelocityDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SetJointVelocity> _instance;
} _SetJointVelocity_default_instance_;
class GetJointStateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<GetJointState> _instance;
} _GetJointState_default_instance_;
class AxisDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Axis> _instance;
} _Axis_default_instance_;
class JointStateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<JointState> _instance;
} _JointState_default_instance_;
class SetLinkWorldPoseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SetLinkWorldPose> _instance;
} _SetLinkWorldPose_default_instance_;
class SetLinkLinearVelocityDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SetLinkLinearVelocity> _instance;
} _SetLinkLinearVelocity_default_instance_;
class SetLinkAngularVelocityDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SetLinkAngularVelocity> _instance;
} _SetLinkAngularVelocity_default_instance_;
class GetLinkStateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<GetLinkState> _instance;
} _GetLinkState_default_instance_;
class LinkStateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LinkState> _instance;
} _LinkState_default_instance_;
class ML_CordDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ML_Cord> _instance;
} _ML_Cord_default_instance_;
class ML_PointDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ML_Point> _instance;
} _ML_Point_default_instance_;
class ML_QuatDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ML_Quat> _instance;
} _ML_Quat_default_instance_;
class ML_PoseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ML_Pose> _instance;
} _ML_Pose_default_instance_;
class ML_InertialDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ML_Inertial> _instance;
} _ML_Inertial_default_instance_;
class ML_LinksDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ML_Links> _instance;
} _ML_Links_default_instance_;
class ML_AxisDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ML_Axis> _instance;
} _ML_Axis_default_instance_;
class ML_JointsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ML_Joints> _instance;
} _ML_Joints_default_instance_;
class GazebomodelDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Gazebomodel> _instance;
} _Gazebomodel_default_instance_;
class GetGazeboModelParamDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<GetGazeboModelParam> _instance;
} _GetGazeboModelParam_default_instance_;
class GazeboModelSDFDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<GazeboModelSDF> _instance;
} _GazeboModelSDF_default_instance_;
class GetGazeboModelSDFDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<GetGazeboModelSDF> _instance;
} _GetGazeboModelSDF_default_instance_;
}  // namespace gazebotransport
}  // namespace robotics
}  // namespace internal
}  // namespace mw
static void InitDefaultsscc_info_ApplyJointTorque_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_ApplyJointTorque_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::ApplyJointTorque();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::ApplyJointTorque::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ApplyJointTorque_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_ApplyJointTorque_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {
      &scc_info_Time_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,}};

static void InitDefaultsscc_info_ApplyLinkWrench_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_ApplyLinkWrench_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::ApplyLinkWrench();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::ApplyLinkWrench::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ApplyLinkWrench_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_ApplyLinkWrench_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {
      &scc_info_Time_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,}};

static void InitDefaultsscc_info_Axis_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_Axis_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::Axis();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::Axis::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Axis_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_Axis_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {
      &scc_info_Point_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,}};

static void InitDefaultsscc_info_CustomMessageSupport_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_CustomMessageSupport_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::CustomMessageSupport();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::CustomMessageSupport::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CustomMessageSupport_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_CustomMessageSupport_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_GazeboModelSDF_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_GazeboModelSDF_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::GazeboModelSDF();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::GazeboModelSDF::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GazeboModelSDF_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_GazeboModelSDF_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_Gazebomodel_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_Gazebomodel_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::Gazebomodel();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::Gazebomodel::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_Gazebomodel_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, 0, InitDefaultsscc_info_Gazebomodel_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {
      &scc_info_ML_Links_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_ML_Joints_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_ML_Pose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,}};

static void InitDefaultsscc_info_GetGazeboModelParam_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_GetGazeboModelParam_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::GetGazeboModelParam();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::GetGazeboModelParam::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GetGazeboModelParam_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_GetGazeboModelParam_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_GetGazeboModelSDF_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_GetGazeboModelSDF_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GetGazeboModelSDF_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_GetGazeboModelSDF_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_GetGroundTruthWorldPose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_GetGroundTruthWorldPose_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GetGroundTruthWorldPose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_GetGroundTruthWorldPose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_GetJointState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_GetJointState_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::GetJointState();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::GetJointState::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GetJointState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_GetJointState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_GetLinkState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_GetLinkState_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::GetLinkState();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::GetLinkState::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GetLinkState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_GetLinkState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_GetModelInfo_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_GetModelInfo_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::GetModelInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::GetModelInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GetModelInfo_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_GetModelInfo_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_GetPose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_GetPose_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::GetPose();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::GetPose::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GetPose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_GetPose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_GetTopicList_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_GetTopicList_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::GetTopicList();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::GetTopicList::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GetTopicList_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_GetTopicList_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_Image_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_Image_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::Image();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::Image::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Image_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Image_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_ImuData_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_ImuData_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::ImuData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::ImuData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_ImuData_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_ImuData_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {
      &scc_info_Point_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_Quaternion_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,}};

static void InitDefaultsscc_info_InitCustomPublisher_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_InitCustomPublisher_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::InitCustomPublisher();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::InitCustomPublisher::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_InitCustomPublisher_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_InitCustomPublisher_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_InitCustomSubscriber_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_InitCustomSubscriber_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::InitCustomSubscriber();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::InitCustomSubscriber::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_InitCustomSubscriber_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_InitCustomSubscriber_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_JointState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_JointState_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::JointState();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::JointState::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_JointState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_JointState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {
      &scc_info_Pose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_Axis_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,}};

static void InitDefaultsscc_info_LaserData_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_LaserData_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::LaserData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::LaserData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_LaserData_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_LaserData_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_LinkState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_LinkState_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::LinkState();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::LinkState::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_LinkState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_LinkState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {
      &scc_info_Point_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_Pose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,}};

static void InitDefaultsscc_info_ML_Axis_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_ML_Axis_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::ML_Axis();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::ML_Axis::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ML_Axis_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_ML_Axis_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {
      &scc_info_ML_Point_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,}};

static void InitDefaultsscc_info_ML_Cord_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_ML_Cord_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::ML_Cord();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::ML_Cord::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ML_Cord_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_ML_Cord_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_ML_Inertial_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_ML_Inertial_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::ML_Inertial();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::ML_Inertial::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ML_Inertial_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_ML_Inertial_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_ML_Joints_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_ML_Joints_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::ML_Joints();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::ML_Joints::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_ML_Joints_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_ML_Joints_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {
      &scc_info_ML_Pose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_ML_Axis_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,}};

static void InitDefaultsscc_info_ML_Links_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_ML_Links_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::ML_Links();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::ML_Links::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_ML_Links_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_ML_Links_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {
      &scc_info_ML_Pose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_ML_Inertial_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,}};

static void InitDefaultsscc_info_ML_Point_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_ML_Point_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::ML_Point();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::ML_Point::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ML_Point_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_ML_Point_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_ML_Pose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_ML_Pose_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::ML_Pose();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::ML_Pose::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_ML_Pose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_ML_Pose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {
      &scc_info_ML_Point_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_ML_Quat_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,}};

static void InitDefaultsscc_info_ML_Quat_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_ML_Quat_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::ML_Quat();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::ML_Quat::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ML_Quat_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_ML_Quat_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_MaxStepSize_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_MaxStepSize_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::MaxStepSize();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::MaxStepSize::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MaxStepSize_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_MaxStepSize_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_ModelInfo_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_ModelInfo_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::ModelInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::ModelInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ModelInfo_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_ModelInfo_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {
      &scc_info_ModelInfo_Model_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,}};

static void InitDefaultsscc_info_ModelInfo_JOINTS_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_ModelInfo_JOINTS_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ModelInfo_JOINTS_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_ModelInfo_JOINTS_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_ModelInfo_LINKS_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_ModelInfo_LINKS_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ModelInfo_LINKS_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_ModelInfo_LINKS_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_ModelInfo_Model_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_ModelInfo_Model_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::ModelInfo_Model();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::ModelInfo_Model::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_ModelInfo_Model_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_ModelInfo_Model_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {
      &scc_info_ModelInfo_LINKS_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_ModelInfo_JOINTS_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,}};

static void InitDefaultsscc_info_Packet_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_Packet_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::Packet();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::Packet::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<42> scc_info_Packet_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 42, 0, InitDefaultsscc_info_Packet_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {
      &scc_info_PacketHeader_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_StepSimulation_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_ResetSimulation_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_Image_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_RequestImage_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_RequestCoSim_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_StopCoSim_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_GetGroundTruthWorldPose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_Pose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_StopSimulation_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_LaserData_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_RequestLaser_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_ImuData_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_RequestImu_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_SubscribeImage_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_SubscribeLaser_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_SubscribeImu_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_ApplyJointTorque_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_GetPose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_GetTopicList_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_TopicList_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_GetModelInfo_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_ModelInfo_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_ApplyLinkWrench_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_MaxStepSize_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_CustomMessageSupport_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_InitCustomPublisher_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_InitCustomSubscriber_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_RequestCustomMessageSupport_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_SetJointPosition_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_SetJointVelocity_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_GetJointState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_JointState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_SetLinkWorldPose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_SetLinkLinearVelocity_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_SetLinkAngularVelocity_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_GetLinkState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_LinkState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_Gazebomodel_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_GetGazeboModelParam_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_GazeboModelSDF_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_GetGazeboModelSDF_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,}};

static void InitDefaultsscc_info_PacketHeader_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_PacketHeader_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::PacketHeader();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::PacketHeader::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_PacketHeader_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_PacketHeader_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {
      &scc_info_Time_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,}};

static void InitDefaultsscc_info_PluginVersion_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::mw::internal::robotics::gazebotransport::PluginVersion::_i_give_permission_to_break_this_code_default_version_.DefaultConstruct();
  *::mw::internal::robotics::gazebotransport::PluginVersion::_i_give_permission_to_break_this_code_default_version_.get_mutable() = std::string("R2022b", 6);
  ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyString(
      ::mw::internal::robotics::gazebotransport::PluginVersion::_i_give_permission_to_break_this_code_default_version_.get_mutable());
  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_PluginVersion_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::PluginVersion();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::PluginVersion::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PluginVersion_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_PluginVersion_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_Point_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_Point_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::Point();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::Point::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Point_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Point_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_Pose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_Pose_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::Pose();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::Pose::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_Pose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_Pose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {
      &scc_info_Point_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_Quaternion_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,}};

static void InitDefaultsscc_info_Quaternion_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_Quaternion_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::Quaternion();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::Quaternion::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Quaternion_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Quaternion_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_RequestCoSim_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_RequestCoSim_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::RequestCoSim();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::RequestCoSim::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RequestCoSim_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_RequestCoSim_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_RequestCustomMessageSupport_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_RequestCustomMessageSupport_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RequestCustomMessageSupport_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_RequestCustomMessageSupport_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_RequestImage_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_RequestImage_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::RequestImage();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::RequestImage::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RequestImage_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_RequestImage_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_RequestImu_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_RequestImu_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::RequestImu();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::RequestImu::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RequestImu_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_RequestImu_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_RequestLaser_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_RequestLaser_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::RequestLaser();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::RequestLaser::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RequestLaser_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_RequestLaser_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_ResetSimulation_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_ResetSimulation_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::ResetSimulation();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::ResetSimulation::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ResetSimulation_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_ResetSimulation_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_SetJointPosition_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_SetJointPosition_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::SetJointPosition();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::SetJointPosition::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_SetJointPosition_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_SetJointPosition_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {
      &scc_info_Time_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,}};

static void InitDefaultsscc_info_SetJointVelocity_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_SetJointVelocity_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::SetJointVelocity();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::SetJointVelocity::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_SetJointVelocity_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_SetJointVelocity_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {
      &scc_info_Time_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,}};

static void InitDefaultsscc_info_SetLinkAngularVelocity_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_SetLinkAngularVelocity_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_SetLinkAngularVelocity_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_SetLinkAngularVelocity_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {
      &scc_info_Point_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_Time_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,}};

static void InitDefaultsscc_info_SetLinkLinearVelocity_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_SetLinkLinearVelocity_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_SetLinkLinearVelocity_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_SetLinkLinearVelocity_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {
      &scc_info_Point_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_Time_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,}};

static void InitDefaultsscc_info_SetLinkWorldPose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_SetLinkWorldPose_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::SetLinkWorldPose();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::SetLinkWorldPose::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_SetLinkWorldPose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_SetLinkWorldPose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {
      &scc_info_Pose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
      &scc_info_Time_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,}};

static void InitDefaultsscc_info_StepSimulation_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_StepSimulation_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::StepSimulation();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::StepSimulation::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StepSimulation_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_StepSimulation_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_StopCoSim_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_StopCoSim_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::StopCoSim();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::StopCoSim::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StopCoSim_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_StopCoSim_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_StopSimulation_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_StopSimulation_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::StopSimulation();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::StopSimulation::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StopSimulation_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_StopSimulation_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_SubscribeImage_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_SubscribeImage_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::SubscribeImage();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::SubscribeImage::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SubscribeImage_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_SubscribeImage_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_SubscribeImu_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_SubscribeImu_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::SubscribeImu();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::SubscribeImu::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SubscribeImu_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_SubscribeImu_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_SubscribeLaser_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_SubscribeLaser_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::SubscribeLaser();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::SubscribeLaser::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SubscribeLaser_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_SubscribeLaser_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_Time_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_Time_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::Time();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::Time::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Time_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Time_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static void InitDefaultsscc_info_TopicList_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_TopicList_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::TopicList();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::TopicList::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TopicList_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TopicList_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {
      &scc_info_TopicList_TopicInfo_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,}};

static void InitDefaultsscc_info_TopicList_TopicInfo_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mw::internal::robotics::gazebotransport::_TopicList_TopicInfo_default_instance_;
    new (ptr) ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TopicList_TopicInfo_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TopicList_TopicInfo_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto}, {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto[60];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto[5];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::PluginVersion, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::PluginVersion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::PluginVersion, version_),
  0,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Time, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Time, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Time, seconds_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Time, nano_seconds_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::PacketHeader, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::PacketHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::PacketHeader, id_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::PacketHeader, time_stamp_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Packet, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Packet, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Packet, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Packet, header_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, status_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, step_simulation_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, reset_simulation_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, image_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, request_image_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, request_cosim_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, stop_cosim_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, get_ground_truth_world_pose_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, pose_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, stop_simulation_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, laser_data_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, request_laser_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, imu_data_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, request_imu_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, subscribe_image_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, subscribe_laser_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, subscribe_imu_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, apply_joint_torque_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, get_pose_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, get_topic_list_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, topic_list_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, get_model_info_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, model_info_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, apply_link_wrench_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, max_step_size_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, custom_message_support_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, init_custom_publisher_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, init_custom_subscriber_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, request_custom_message_support_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, set_joint_position_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, set_joint_velocity_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, get_joint_state_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, joint_state_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, set_link_world_pose_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, set_link_linear_velocity_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, set_link_angular_velocity_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, get_link_state_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, link_state_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, gazebo_model_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, get_gazebo_model_param_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, gazebo_model_sdf_),
  offsetof(::mw::internal::robotics::gazebotransport::PacketDefaultTypeInternal, get_gazebo_model_sdf_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Packet, error_message_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Packet, is_new_reading_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Packet, payload_),
  1,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::StepSimulation, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::StepSimulation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::StepSimulation, num_steps_),
  0,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ResetSimulation, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ResetSimulation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ResetSimulation, behavior_),
  0,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Image, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Image, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Image, width_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Image, height_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Image, data_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Image, data_type_),
  2,
  3,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::RequestImage, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::RequestImage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::RequestImage, topic_name_),
  0,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::RequestCoSim, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::RequestCoSim, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::RequestCoSim, client_id_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::RequestCoSim, duration_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::StopCoSim, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::StopCoSim, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::StopCoSim, client_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose, model_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose, link_name_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Point, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Point, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Point, x_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Point, y_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Point, z_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Quaternion, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Quaternion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Quaternion, x_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Quaternion, y_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Quaternion, z_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Quaternion, w_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Pose, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Pose, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Pose, position_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Pose, orientation_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::StopSimulation, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::StopSimulation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::StopSimulation, stop_scene_),
  0,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LaserData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LaserData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LaserData, angle_min_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LaserData, angle_max_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LaserData, angle_step_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LaserData, range_min_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LaserData, range_max_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LaserData, count_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LaserData, vertical_angle_min_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LaserData, vertical_angle_max_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LaserData, vertical_angle_step_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LaserData, range_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LaserData, intensities_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::RequestLaser, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::RequestLaser, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::RequestLaser, topic_name_),
  0,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ImuData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ImuData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ImuData, linear_acceleration_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ImuData, angular_velocity_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ImuData, orientation_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::RequestImu, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::RequestImu, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::RequestImu, topic_name_),
  0,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SubscribeImage, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SubscribeImage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SubscribeImage, topic_name_),
  0,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SubscribeLaser, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SubscribeLaser, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SubscribeLaser, topic_name_),
  0,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SubscribeImu, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SubscribeImu, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SubscribeImu, topic_name_),
  0,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ApplyLinkWrench, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ApplyLinkWrench, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ApplyLinkWrench, model_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ApplyLinkWrench, link_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ApplyLinkWrench, force_type_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ApplyLinkWrench, fx_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ApplyLinkWrench, fy_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ApplyLinkWrench, fz_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ApplyLinkWrench, torque_type_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ApplyLinkWrench, tx_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ApplyLinkWrench, ty_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ApplyLinkWrench, tz_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ApplyLinkWrench, duration_),
  0,
  1,
  2,
  5,
  6,
  7,
  3,
  8,
  9,
  10,
  4,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ApplyJointTorque, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ApplyJointTorque, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ApplyJointTorque, model_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ApplyJointTorque, joint_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ApplyJointTorque, index_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ApplyJointTorque, effort_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ApplyJointTorque, duration_),
  0,
  1,
  4,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetPose, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetPose, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetPose, model_name_),
  0,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetTopicList, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetTopicList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetTopicList, topic_name_),
  0,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::TopicList_TopicInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::TopicList_TopicInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::TopicList_TopicInfo, name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::TopicList_TopicInfo, type_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::TopicList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::TopicList, data_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetModelInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetModelInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetModelInfo, topic_name_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ModelInfo_LINKS, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ModelInfo_LINKS, link_name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS, joint_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ModelInfo_Model, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ModelInfo_Model, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ModelInfo_Model, model_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ModelInfo_Model, links_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ModelInfo_Model, joints_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ModelInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ModelInfo, model_data_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::MaxStepSize, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::MaxStepSize, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::MaxStepSize, type_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::MaxStepSize, size_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::InitCustomPublisher, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::InitCustomPublisher, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::InitCustomPublisher, topic_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::InitCustomPublisher, message_type_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::InitCustomSubscriber, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::InitCustomSubscriber, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::InitCustomSubscriber, topic_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::InitCustomSubscriber, message_type_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::CustomMessageSupport, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::CustomMessageSupport, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::CustomMessageSupport, topic_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::CustomMessageSupport, message_type_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::CustomMessageSupport, data_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::CustomMessageSupport, is_new_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport, topic_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport, message_type_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetJointPosition, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetJointPosition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetJointPosition, model_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetJointPosition, joint_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetJointPosition, index_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetJointPosition, position_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetJointPosition, duration_),
  0,
  1,
  4,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetJointVelocity, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetJointVelocity, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetJointVelocity, model_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetJointVelocity, joint_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetJointVelocity, index_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetJointVelocity, velocity_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetJointVelocity, duration_),
  0,
  1,
  4,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetJointState, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetJointState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetJointState, model_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetJointState, joint_name_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Axis, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Axis, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Axis, xyz_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Axis, limit_lower_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Axis, limit_upper_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Axis, limit_effort_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Axis, limit_velocity_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Axis, damping_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Axis, friction_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Axis, use_parent_model_frame_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::JointState, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::JointState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::JointState, model_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::JointState, joint_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::JointState, joint_id_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::JointState, joint_position_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::JointState, joint_velocity_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::JointState, joint_type_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::JointState, parent_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::JointState, parent_id_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::JointState, child_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::JointState, child_id_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::JointState, initial_anchor_pose_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::JointState, world_pose_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::JointState, parent_world_pose_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::JointState, axis_),
  0,
  1,
  7,
  ~0u,
  ~0u,
  10,
  2,
  8,
  3,
  9,
  4,
  5,
  6,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetLinkWorldPose, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetLinkWorldPose, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetLinkWorldPose, model_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetLinkWorldPose, link_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetLinkWorldPose, pose_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetLinkWorldPose, duration_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity, model_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity, link_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity, velocity_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity, duration_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity, model_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity, link_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity, velocity_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity, duration_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetLinkState, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetLinkState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetLinkState, model_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetLinkState, link_name_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LinkState, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LinkState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LinkState, model_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LinkState, link_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LinkState, link_id_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LinkState, world_linear_velocity_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LinkState, world_angular_velocity_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LinkState, relative_linear_velocity_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LinkState, relative_angular_velocity_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LinkState, world_pose_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LinkState, relative_pose_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LinkState, self_collide_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LinkState, gravity_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LinkState, kinematic_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LinkState, enable_wind_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::LinkState, canonical_),
  0,
  1,
  8,
  2,
  3,
  4,
  5,
  6,
  7,
  9,
  10,
  11,
  12,
  13,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Cord, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Cord, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Cord, x_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Cord, y_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Point, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Point, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Point, x_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Point, y_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Point, z_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Quat, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Quat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Quat, x_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Quat, y_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Quat, z_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Quat, w_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Pose, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Pose, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Pose, position_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Pose, orientation_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Inertial, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Inertial, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Inertial, mass_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Inertial, ixx_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Inertial, ixy_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Inertial, ixz_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Inertial, iyy_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Inertial, iyz_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Inertial, izz_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Links, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Links, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Links, name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Links, pose_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Links, inertial_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Links, self_collide_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Links, gravity_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Links, kinematic_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Links, enabled_wind_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Links, is_static_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Links, canonical_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Axis, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Axis, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Axis, xyz_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Axis, damping_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Axis, friction_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Axis, angle_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Joints, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Joints, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Joints, name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Joints, pose_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Joints, axis1_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Joints, axis2_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Joints, cfm_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Joints, fudge_factor_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Joints, suspension_cfm_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Joints, suspension_erp_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::ML_Joints, dof_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Gazebomodel, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Gazebomodel, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Gazebomodel, name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Gazebomodel, links_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Gazebomodel, joints_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Gazebomodel, pose_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Gazebomodel, enable_wind_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Gazebomodel, self_collide_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::Gazebomodel, is_static_),
  0,
  ~0u,
  ~0u,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetGazeboModelParam, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetGazeboModelParam, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetGazeboModelParam, model_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetGazeboModelParam, is_link_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetGazeboModelParam, link_joint_name_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GazeboModelSDF, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GazeboModelSDF, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GazeboModelSDF, model_name_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GazeboModelSDF, sdf_string_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetGazeboModelSDF, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetGazeboModelSDF, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mw::internal::robotics::gazebotransport::GetGazeboModelSDF, model_name_),
  0,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 6, sizeof(::mw::internal::robotics::gazebotransport::PluginVersion)},
  { 7, 14, sizeof(::mw::internal::robotics::gazebotransport::Time)},
  { 16, 23, sizeof(::mw::internal::robotics::gazebotransport::PacketHeader)},
  { 25, 76, sizeof(::mw::internal::robotics::gazebotransport::Packet)},
  { 121, 127, sizeof(::mw::internal::robotics::gazebotransport::StepSimulation)},
  { 128, 134, sizeof(::mw::internal::robotics::gazebotransport::ResetSimulation)},
  { 135, 144, sizeof(::mw::internal::robotics::gazebotransport::Image)},
  { 148, 154, sizeof(::mw::internal::robotics::gazebotransport::RequestImage)},
  { 155, 162, sizeof(::mw::internal::robotics::gazebotransport::RequestCoSim)},
  { 164, 170, sizeof(::mw::internal::robotics::gazebotransport::StopCoSim)},
  { 171, 178, sizeof(::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose)},
  { 180, 188, sizeof(::mw::internal::robotics::gazebotransport::Point)},
  { 191, 200, sizeof(::mw::internal::robotics::gazebotransport::Quaternion)},
  { 204, 211, sizeof(::mw::internal::robotics::gazebotransport::Pose)},
  { 213, 219, sizeof(::mw::internal::robotics::gazebotransport::StopSimulation)},
  { 220, 236, sizeof(::mw::internal::robotics::gazebotransport::LaserData)},
  { 247, 253, sizeof(::mw::internal::robotics::gazebotransport::RequestLaser)},
  { 254, 262, sizeof(::mw::internal::robotics::gazebotransport::ImuData)},
  { 265, 271, sizeof(::mw::internal::robotics::gazebotransport::RequestImu)},
  { 272, 278, sizeof(::mw::internal::robotics::gazebotransport::SubscribeImage)},
  { 279, 285, sizeof(::mw::internal::robotics::gazebotransport::SubscribeLaser)},
  { 286, 292, sizeof(::mw::internal::robotics::gazebotransport::SubscribeImu)},
  { 293, 309, sizeof(::mw::internal::robotics::gazebotransport::ApplyLinkWrench)},
  { 320, 330, sizeof(::mw::internal::robotics::gazebotransport::ApplyJointTorque)},
  { 335, 341, sizeof(::mw::internal::robotics::gazebotransport::GetPose)},
  { 342, 348, sizeof(::mw::internal::robotics::gazebotransport::GetTopicList)},
  { 349, 356, sizeof(::mw::internal::robotics::gazebotransport::TopicList_TopicInfo)},
  { 358, -1, sizeof(::mw::internal::robotics::gazebotransport::TopicList)},
  { 364, 370, sizeof(::mw::internal::robotics::gazebotransport::GetModelInfo)},
  { 371, -1, sizeof(::mw::internal::robotics::gazebotransport::ModelInfo_LINKS)},
  { 377, -1, sizeof(::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS)},
  { 383, 391, sizeof(::mw::internal::robotics::gazebotransport::ModelInfo_Model)},
  { 394, -1, sizeof(::mw::internal::robotics::gazebotransport::ModelInfo)},
  { 400, 407, sizeof(::mw::internal::robotics::gazebotransport::MaxStepSize)},
  { 409, 416, sizeof(::mw::internal::robotics::gazebotransport::InitCustomPublisher)},
  { 418, 425, sizeof(::mw::internal::robotics::gazebotransport::InitCustomSubscriber)},
  { 427, 436, sizeof(::mw::internal::robotics::gazebotransport::CustomMessageSupport)},
  { 440, 447, sizeof(::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport)},
  { 449, 459, sizeof(::mw::internal::robotics::gazebotransport::SetJointPosition)},
  { 464, 474, sizeof(::mw::internal::robotics::gazebotransport::SetJointVelocity)},
  { 479, 486, sizeof(::mw::internal::robotics::gazebotransport::GetJointState)},
  { 488, 501, sizeof(::mw::internal::robotics::gazebotransport::Axis)},
  { 509, 528, sizeof(::mw::internal::robotics::gazebotransport::JointState)},
  { 542, 551, sizeof(::mw::internal::robotics::gazebotransport::SetLinkWorldPose)},
  { 555, 564, sizeof(::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity)},
  { 568, 577, sizeof(::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity)},
  { 581, 588, sizeof(::mw::internal::robotics::gazebotransport::GetLinkState)},
  { 590, 609, sizeof(::mw::internal::robotics::gazebotransport::LinkState)},
  { 623, 630, sizeof(::mw::internal::robotics::gazebotransport::ML_Cord)},
  { 632, 640, sizeof(::mw::internal::robotics::gazebotransport::ML_Point)},
  { 643, 652, sizeof(::mw::internal::robotics::gazebotransport::ML_Quat)},
  { 656, 663, sizeof(::mw::internal::robotics::gazebotransport::ML_Pose)},
  { 665, 677, sizeof(::mw::internal::robotics::gazebotransport::ML_Inertial)},
  { 684, 698, sizeof(::mw::internal::robotics::gazebotransport::ML_Links)},
  { 707, 716, sizeof(::mw::internal::robotics::gazebotransport::ML_Axis)},
  { 720, 734, sizeof(::mw::internal::robotics::gazebotransport::ML_Joints)},
  { 743, 755, sizeof(::mw::internal::robotics::gazebotransport::Gazebomodel)},
  { 762, 770, sizeof(::mw::internal::robotics::gazebotransport::GetGazeboModelParam)},
  { 773, 780, sizeof(::mw::internal::robotics::gazebotransport::GazeboModelSDF)},
  { 782, 788, sizeof(::mw::internal::robotics::gazebotransport::GetGazeboModelSDF)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_PluginVersion_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_Time_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_PacketHeader_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_Packet_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_StepSimulation_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_ResetSimulation_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_Image_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_RequestImage_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_RequestCoSim_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_StopCoSim_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_GetGroundTruthWorldPose_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_Point_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_Quaternion_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_Pose_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_StopSimulation_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_LaserData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_RequestLaser_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_ImuData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_RequestImu_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_SubscribeImage_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_SubscribeLaser_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_SubscribeImu_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_ApplyLinkWrench_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_ApplyJointTorque_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_GetPose_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_GetTopicList_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_TopicList_TopicInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_TopicList_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_GetModelInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_ModelInfo_LINKS_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_ModelInfo_JOINTS_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_ModelInfo_Model_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_ModelInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_MaxStepSize_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_InitCustomPublisher_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_InitCustomSubscriber_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_CustomMessageSupport_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_RequestCustomMessageSupport_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_SetJointPosition_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_SetJointVelocity_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_GetJointState_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_Axis_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_JointState_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_SetLinkWorldPose_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_SetLinkLinearVelocity_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_SetLinkAngularVelocity_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_GetLinkState_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_LinkState_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_ML_Cord_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_ML_Point_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_ML_Quat_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_ML_Pose_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_ML_Inertial_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_ML_Links_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_ML_Axis_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_ML_Joints_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_Gazebomodel_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_GetGazeboModelParam_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_GazeboModelSDF_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mw::internal::robotics::gazebotransport::_GetGazeboModelSDF_default_instance_),
};

const char descriptor_table_protodef_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n4mw.internal.robotics.gazebotransport.C"
  "oSimMsgs.proto\022$mw.internal.robotics.gaz"
  "ebotransport\"(\n\rPluginVersion\022\027\n\007version"
  "\030\001 \002(\t:\006R2022b\"-\n\004Time\022\017\n\007seconds\030\001 \002(\004\022"
  "\024\n\014nano_seconds\030\002 \002(\004\"\273\010\n\014PacketHeader\022D"
  "\n\002id\030\001 \002(\01628.mw.internal.robotics.gazebo"
  "transport.PacketHeader.MsgID\022>\n\ntime_sta"
  "mp\030\002 \002(\0132*.mw.internal.robotics.gazebotr"
  "ansport.Time\"\244\007\n\005MsgID\022\n\n\006STATUS\020\000\022\023\n\017ST"
  "EP_SIMULATION\020\001\022\024\n\020RESET_SIMULATION\020\002\022\t\n"
  "\005IMAGE\020\003\022\021\n\rREQUEST_IMAGE\020\004\022\021\n\rREQUEST_C"
  "OSIM\020\005\022\016\n\nSTOP_COSIM\020\006\022\037\n\033GET_GROUND_TRU"
  "TH_WORLD_POSE\020\007\022\010\n\004POSE\020\010\022\023\n\017STOP_SIMULA"
  "TION\020\t\022\016\n\nLASER_DATA\020\n\022\021\n\rREQUEST_LASER\020"
  "\013\022\014\n\010IMU_DATA\020\014\022\017\n\013REQUEST_IMU\020\r\022\023\n\017SUBS"
  "CRIBE_IMAGE\020\016\022\023\n\017SUBSCRIBE_LASER\020\017\022\021\n\rSU"
  "BSCRIBE_IMU\020\020\022\026\n\022APPLY_JOINT_TORQUE\020\021\022\014\n"
  "\010GET_POSE\020\022\022\022\n\016GET_TOPIC_LIST\020\023\022\016\n\nTOPIC"
  "_LIST\020\024\022\022\n\016GET_MODEL_INFO\020\025\022\016\n\nMODEL_INF"
  "O\020\026\022\025\n\021APPLY_LINK_WRENCH\020\027\022\021\n\rMAX_STEP_S"
  "IZE\020\030\022\035\n\031CUSTOM_MESSAGE_SUBSCRIBER\020\031\022\034\n\030"
  "CUSTOM_MESSAGE_PUBLISHER\020\032\022!\n\035INIT_CUSTO"
  "M_MESSAGE_PUBLISHER\020\033\022\"\n\036INIT_CUSTOM_MES"
  "SAGE_SUBSCRIBER\020\034\022\026\n\022SET_JOINT_POSITION\020"
  "\035\022\026\n\022SET_JOINT_VELOCITY\020\036\022\023\n\017GET_JOINT_S"
  "TATE\020\037\022\017\n\013JOINT_STATE\020 \022\027\n\023SET_LINK_WORL"
  "D_POSE\020!\022\034\n\030SET_LINK_LINEAR_VELOCITY\020\"\022\035"
  "\n\031SET_LINK_ANGULAR_VELOCITY\020#\022\022\n\016GET_LIN"
  "K_STATE\020$\022\016\n\nLINK_STATE\020%\022\020\n\014GAZEBO_MODE"
  "L\020&\022\032\n\026SET_GAZEBO_MODEL_PARAM\020\'\022\032\n\026GET_G"
  "AZEBO_MODEL_PARAM\020(\022\024\n\020GAZEBO_MODEL_SDF\020"
  ")\022\030\n\024GET_GAZEBO_MODEL_SDF\020*\"\310\037\n\006Packet\022B"
  "\n\006header\030\001 \002(\01322.mw.internal.robotics.ga"
  "zebotransport.PacketHeader\022I\n\006status\030\002 \001"
  "(\01627.mw.internal.robotics.gazebotranspor"
  "t.Packet.CoSimErrorH\000\022O\n\017step_simulation"
  "\030\003 \001(\01324.mw.internal.robotics.gazebotran"
  "sport.StepSimulationH\000\022Q\n\020reset_simulati"
  "on\030\004 \001(\01325.mw.internal.robotics.gazebotr"
  "ansport.ResetSimulationH\000\022<\n\005image\030\005 \001(\013"
  "2+.mw.internal.robotics.gazebotransport."
  "ImageH\000\022K\n\rrequest_image\030\006 \001(\01322.mw.inte"
  "rnal.robotics.gazebotransport.RequestIma"
  "geH\000\022K\n\rrequest_cosim\030\007 \001(\01322.mw.interna"
  "l.robotics.gazebotransport.RequestCoSimH"
  "\000\022E\n\nstop_cosim\030\010 \001(\0132/.mw.internal.robo"
  "tics.gazebotransport.StopCoSimH\000\022d\n\033get_"
  "ground_truth_world_pose\030\t \001(\0132=.mw.inter"
  "nal.robotics.gazebotransport.GetGroundTr"
  "uthWorldPoseH\000\022:\n\004pose\030\n \001(\0132*.mw.intern"
  "al.robotics.gazebotransport.PoseH\000\022O\n\017st"
  "op_simulation\030\013 \001(\01324.mw.internal.roboti"
  "cs.gazebotransport.StopSimulationH\000\022E\n\nl"
  "aser_data\030\014 \001(\0132/.mw.internal.robotics.g"
  "azebotransport.LaserDataH\000\022K\n\rrequest_la"
  "ser\030\r \001(\01322.mw.internal.robotics.gazebot"
  "ransport.RequestLaserH\000\022A\n\010imu_data\030\016 \001("
  "\0132-.mw.internal.robotics.gazebotransport"
  ".ImuDataH\000\022G\n\013request_imu\030\017 \001(\01320.mw.int"
  "ernal.robotics.gazebotransport.RequestIm"
  "uH\000\022O\n\017subscribe_image\030\020 \001(\01324.mw.intern"
  "al.robotics.gazebotransport.SubscribeIma"
  "geH\000\022O\n\017subscribe_laser\030\021 \001(\01324.mw.inter"
  "nal.robotics.gazebotransport.SubscribeLa"
  "serH\000\022K\n\rsubscribe_imu\030\022 \001(\01322.mw.intern"
  "al.robotics.gazebotransport.SubscribeImu"
  "H\000\022T\n\022apply_joint_torque\030\023 \001(\01326.mw.inte"
  "rnal.robotics.gazebotransport.ApplyJoint"
  "TorqueH\000\022A\n\010get_pose\030\024 \001(\0132-.mw.internal"
  ".robotics.gazebotransport.GetPoseH\000\022L\n\016g"
  "et_topic_list\030\025 \001(\01322.mw.internal.roboti"
  "cs.gazebotransport.GetTopicListH\000\022E\n\ntop"
  "ic_list\030\026 \001(\0132/.mw.internal.robotics.gaz"
  "ebotransport.TopicListH\000\022L\n\016get_model_in"
  "fo\030\027 \001(\01322.mw.internal.robotics.gazebotr"
  "ansport.GetModelInfoH\000\022E\n\nmodel_info\030\030 \001"
  "(\0132/.mw.internal.robotics.gazebotranspor"
  "t.ModelInfoH\000\022R\n\021apply_link_wrench\030\031 \001(\013"
  "25.mw.internal.robotics.gazebotransport."
  "ApplyLinkWrenchH\000\022J\n\rmax_step_size\030\032 \001(\013"
  "21.mw.internal.robotics.gazebotransport."
  "MaxStepSizeH\000\022\\\n\026custom_message_support\030"
  "\033 \001(\0132:.mw.internal.robotics.gazebotrans"
  "port.CustomMessageSupportH\000\022Z\n\025init_cust"
  "om_publisher\030\034 \001(\01329.mw.internal.robotic"
  "s.gazebotransport.InitCustomPublisherH\000\022"
  "\\\n\026init_custom_subscriber\030\035 \001(\0132:.mw.int"
  "ernal.robotics.gazebotransport.InitCusto"
  "mSubscriberH\000\022k\n\036request_custom_message_"
  "support\030\036 \001(\0132A.mw.internal.robotics.gaz"
  "ebotransport.RequestCustomMessageSupport"
  "H\000\022T\n\022set_joint_position\030\037 \001(\01326.mw.inte"
  "rnal.robotics.gazebotransport.SetJointPo"
  "sitionH\000\022T\n\022set_joint_velocity\030  \001(\01326.m"
  "w.internal.robotics.gazebotransport.SetJ"
  "ointVelocityH\000\022N\n\017get_joint_state\030! \001(\0132"
  "3.mw.internal.robotics.gazebotransport.G"
  "etJointStateH\000\022G\n\013joint_state\030\" \001(\01320.mw"
  ".internal.robotics.gazebotransport.Joint"
  "StateH\000\022U\n\023set_link_world_pose\030# \001(\01326.m"
  "w.internal.robotics.gazebotransport.SetL"
  "inkWorldPoseH\000\022_\n\030set_link_linear_veloci"
  "ty\030$ \001(\0132;.mw.internal.robotics.gazebotr"
  "ansport.SetLinkLinearVelocityH\000\022a\n\031set_l"
  "ink_angular_velocity\030% \001(\0132<.mw.internal"
  ".robotics.gazebotransport.SetLinkAngular"
  "VelocityH\000\022L\n\016get_link_state\030& \001(\01322.mw."
  "internal.robotics.gazebotransport.GetLin"
  "kStateH\000\022E\n\nlink_state\030\' \001(\0132/.mw.intern"
  "al.robotics.gazebotransport.LinkStateH\000\022"
  "I\n\014gazebo_model\030( \001(\01321.mw.internal.robo"
  "tics.gazebotransport.GazebomodelH\000\022[\n\026ge"
  "t_gazebo_model_param\030) \001(\01329.mw.internal"
  ".robotics.gazebotransport.GetGazeboModel"
  "ParamH\000\022P\n\020gazebo_model_sdf\030* \001(\01324.mw.i"
  "nternal.robotics.gazebotransport.GazeboM"
  "odelSDFH\000\022W\n\024get_gazebo_model_sdf\030+ \001(\0132"
  "7.mw.internal.robotics.gazebotransport.G"
  "etGazeboModelSDFH\000\022\025\n\rerror_message\030, \001("
  "\t\022\026\n\016is_new_reading\030- \001(\010\"\377\003\n\nCoSimError"
  "\022\010\n\004NONE\020\000\022\017\n\013STEP_FAILED\020\001\022\017\n\013MSG_INVAL"
  "ID\020\002\022\021\n\rSOCKET_FAILED\020\003\022\020\n\014RESET_FAILED\020"
  "\004\022\020\n\014COSIM_FAILED\020\005\022\025\n\021STOP_COSIM_FAILED"
  "\020\006\022&\n\"GET_GROUND_TRUTH_WORLD_POSE_FAILED"
  "\020\007\022\033\n\027RESET_TIME_SCENE_FAILED\020\010\022\025\n\021RESET"
  "_TIME_FAILED\020\t\022\017\n\013STOP_FAILED\020\n\022\026\n\022FORCE"
  "_TYPE_INVALID\020\013\022\026\n\022MODEL_NAME_INVALID\020\014\022"
  "\025\n\021LINK_NAME_INVALID\020\r\022\026\n\022JOINT_NAME_INV"
  "ALID\020\016\022\026\n\022TOPIC_NAME_INVALID\020\017\022\027\n\023TORQUE"
  "_TYPE_INVALID\020\020\022\027\n\023MAX_STEP_SIZE_ERROR\020\021"
  "\022\032\n\026CUSTOM_MESSAGE_INVALID\020\022\022\030\n\024MESSAGE_"
  "TYPE_INVALID\020\023\022\023\n\017JOINT_AXIS_NONE\020\024\022\026\n\022I"
  "NVALID_JOINT_AXIS\020\025B\t\n\007payload\"#\n\016StepSi"
  "mulation\022\021\n\tnum_steps\030\001 \002(\r\"\243\001\n\017ResetSim"
  "ulation\022U\n\010behavior\030\001 \002(\0162C.mw.internal."
  "robotics.gazebotransport.ResetSimulation"
  ".ResetBehavior\"9\n\rResetBehavior\022\016\n\nRESET"
  "_TIME\020\000\022\030\n\024RESET_TIME_AND_SCENE\020\001\"G\n\005Ima"
  "ge\022\r\n\005width\030\001 \001(\r\022\016\n\006height\030\002 \001(\r\022\014\n\004dat"
  "a\030\003 \001(\014\022\021\n\tdata_type\030\004 \001(\t\"\"\n\014RequestIma"
  "ge\022\022\n\ntopic_name\030\001 \002(\t\"3\n\014RequestCoSim\022\021"
  "\n\tclient_id\030\001 \002(\t\022\020\n\010duration\030\002 \002(\001\"\036\n\tS"
  "topCoSim\022\021\n\tclient_id\030\001 \002(\t\"@\n\027GetGround"
  "TruthWorldPose\022\022\n\nmodel_name\030\001 \002(\t\022\021\n\tli"
  "nk_name\030\002 \002(\t\"(\n\005Point\022\t\n\001x\030\001 \002(\001\022\t\n\001y\030\002"
  " \002(\001\022\t\n\001z\030\003 \002(\001\"8\n\nQuaternion\022\t\n\001x\030\001 \002(\001"
  "\022\t\n\001y\030\002 \002(\001\022\t\n\001z\030\003 \002(\001\022\t\n\001w\030\004 \002(\001\"\214\001\n\004Po"
  "se\022=\n\010position\030\001 \002(\0132+.mw.internal.robot"
  "ics.gazebotransport.Point\022E\n\013orientation"
  "\030\002 \002(\01320.mw.internal.robotics.gazebotran"
  "sport.Quaternion\"$\n\016StopSimulation\022\022\n\nst"
  "op_scene\030\001 \002(\010\"\363\001\n\tLaserData\022\021\n\tangle_mi"
  "n\030\001 \001(\001\022\021\n\tangle_max\030\002 \001(\001\022\022\n\nangle_step"
  "\030\003 \001(\001\022\021\n\trange_min\030\004 \001(\001\022\021\n\trange_max\030\005"
  " \001(\001\022\r\n\005count\030\006 \001(\001\022\032\n\022vertical_angle_mi"
  "n\030\007 \001(\001\022\032\n\022vertical_angle_max\030\010 \001(\001\022\033\n\023v"
  "ertical_angle_step\030\t \001(\001\022\r\n\005range\030\n \003(\001\022"
  "\023\n\013intensities\030\013 \003(\001\"\"\n\014RequestLaser\022\022\n\n"
  "topic_name\030\001 \002(\t\"\341\001\n\007ImuData\022H\n\023linear_a"
  "cceleration\030\001 \001(\0132+.mw.internal.robotics"
  ".gazebotransport.Point\022E\n\020angular_veloci"
  "ty\030\002 \001(\0132+.mw.internal.robotics.gazebotr"
  "ansport.Point\022E\n\013orientation\030\003 \001(\01320.mw."
  "internal.robotics.gazebotransport.Quater"
  "nion\" \n\nRequestImu\022\022\n\ntopic_name\030\001 \002(\t\"$"
  "\n\016SubscribeImage\022\022\n\ntopic_name\030\001 \002(\t\"$\n\016"
  "SubscribeLaser\022\022\n\ntopic_name\030\001 \002(\t\"\"\n\014Su"
  "bscribeImu\022\022\n\ntopic_name\030\001 \002(\t\"\347\001\n\017Apply"
  "LinkWrench\022\022\n\nmodel_name\030\001 \002(\t\022\021\n\tlink_n"
  "ame\030\002 \002(\t\022\022\n\nforce_type\030\003 \002(\t\022\n\n\002fx\030\004 \002("
  "\001\022\n\n\002fy\030\005 \002(\001\022\n\n\002fz\030\006 \002(\001\022\023\n\013torque_type"
  "\030\007 \002(\t\022\n\n\002tx\030\010 \002(\001\022\n\n\002ty\030\t \002(\001\022\n\n\002tz\030\n \002"
  "(\001\022<\n\010duration\030\013 \002(\0132*.mw.internal.robot"
  "ics.gazebotransport.Time\"\227\001\n\020ApplyJointT"
  "orque\022\022\n\nmodel_name\030\001 \002(\t\022\022\n\njoint_name\030"
  "\002 \002(\t\022\r\n\005index\030\003 \002(\r\022\016\n\006effort\030\004 \002(\001\022<\n\010"
  "duration\030\005 \002(\0132*.mw.internal.robotics.ga"
  "zebotransport.Time\"\035\n\007GetPose\022\022\n\nmodel_n"
  "ame\030\001 \002(\t\"\"\n\014GetTopicList\022\022\n\ntopic_name\030"
  "\001 \002(\t\"}\n\tTopicList\022G\n\004data\030\001 \003(\01329.mw.in"
  "ternal.robotics.gazebotransport.TopicLis"
  "t.TopicInfo\032\'\n\tTopicInfo\022\014\n\004name\030\001 \002(\t\022\014"
  "\n\004type\030\002 \002(\t\"\"\n\014GetModelInfo\022\022\n\ntopic_na"
  "me\030\001 \002(\t\"\274\002\n\tModelInfo\022I\n\nmodel_data\030\001 \003"
  "(\01325.mw.internal.robotics.gazebotranspor"
  "t.ModelInfo.Model\032\032\n\005LINKS\022\021\n\tlink_name\030"
  "\001 \003(\t\032\034\n\006JOINTS\022\022\n\njoint_name\030\001 \003(\t\032\251\001\n\005"
  "Model\022\022\n\nmodel_name\030\001 \002(\t\022D\n\005links\030\002 \001(\013"
  "25.mw.internal.robotics.gazebotransport."
  "ModelInfo.LINKS\022F\n\006joints\030\003 \001(\01326.mw.int"
  "ernal.robotics.gazebotransport.ModelInfo"
  ".JOINTS\"\217\001\n\013MaxStepSize\022D\n\004type\030\001 \002(\01626."
  "mw.internal.robotics.gazebotransport.Max"
  "StepSize.TYPE\022\014\n\004size\030\002 \002(\001\",\n\004TYPE\022\021\n\rS"
  "ET_STEP_SIZE\020\000\022\021\n\rGET_STEP_SIZE\020\001\"\?\n\023Ini"
  "tCustomPublisher\022\022\n\ntopic_name\030\001 \002(\t\022\024\n\014"
  "message_type\030\002 \002(\t\"@\n\024InitCustomSubscrib"
  "er\022\022\n\ntopic_name\030\001 \002(\t\022\024\n\014message_type\030\002"
  " \002(\t\"^\n\024CustomMessageSupport\022\022\n\ntopic_na"
  "me\030\001 \002(\t\022\024\n\014message_type\030\002 \002(\t\022\014\n\004data\030\003"
  " \002(\014\022\016\n\006is_new\030\004 \001(\010\"G\n\033RequestCustomMes"
  "sageSupport\022\022\n\ntopic_name\030\001 \002(\t\022\024\n\014messa"
  "ge_type\030\002 \002(\t\"\231\001\n\020SetJointPosition\022\022\n\nmo"
  "del_name\030\001 \002(\t\022\022\n\njoint_name\030\002 \002(\t\022\r\n\005in"
  "dex\030\003 \002(\r\022\020\n\010position\030\004 \002(\001\022<\n\010duration\030"
  "\005 \002(\0132*.mw.internal.robotics.gazebotrans"
  "port.Time\"\231\001\n\020SetJointVelocity\022\022\n\nmodel_"
  "name\030\001 \002(\t\022\022\n\njoint_name\030\002 \002(\t\022\r\n\005index\030"
  "\003 \002(\r\022\020\n\010velocity\030\004 \002(\001\022<\n\010duration\030\005 \002("
  "\0132*.mw.internal.robotics.gazebotransport"
  ".Time\"7\n\rGetJointState\022\022\n\nmodel_name\030\001 \002"
  "(\t\022\022\n\njoint_name\030\002 \002(\t\"\333\001\n\004Axis\0228\n\003xyz\030\001"
  " \002(\0132+.mw.internal.robotics.gazebotransp"
  "ort.Point\022\023\n\013limit_lower\030\002 \002(\001\022\023\n\013limit_"
  "upper\030\003 \002(\001\022\024\n\014limit_effort\030\004 \002(\001\022\026\n\016lim"
  "it_velocity\030\005 \002(\001\022\017\n\007damping\030\006 \002(\001\022\020\n\010fr"
  "iction\030\007 \002(\001\022\036\n\026use_parent_model_frame\030\010"
  " \002(\010\"\225\005\n\nJointState\022\022\n\nmodel_name\030\001 \002(\t\022"
  "\022\n\njoint_name\030\002 \002(\t\022\020\n\010joint_id\030\003 \002(\r\022\026\n"
  "\016joint_position\030\004 \003(\001\022\026\n\016joint_velocity\030"
  "\005 \003(\001\022O\n\njoint_type\030\006 \001(\0162;.mw.internal."
  "robotics.gazebotransport.JointState.Join"
  "t_Type\022\023\n\013parent_name\030\007 \001(\t\022\021\n\tparent_id"
  "\030\010 \001(\r\022\022\n\nchild_name\030\t \001(\t\022\020\n\010child_id\030\n"
  " \001(\r\022G\n\023initial_anchor_pose\030\013 \001(\0132*.mw.i"
  "nternal.robotics.gazebotransport.Pose\022>\n"
  "\nworld_pose\030\014 \001(\0132*.mw.internal.robotics"
  ".gazebotransport.Pose\022E\n\021parent_world_po"
  "se\030\r \001(\0132*.mw.internal.robotics.gazebotr"
  "ansport.Pose\0228\n\004axis\030\016 \003(\0132*.mw.internal"
  ".robotics.gazebotransport.Axis\"t\n\nJoint_"
  "Type\022\014\n\010REVOLUTE\020\001\022\r\n\tREVOLUTE2\020\002\022\r\n\tPRI"
  "SMATIC\020\003\022\r\n\tUNIVERSAL\020\004\022\010\n\004BALL\020\005\022\t\n\005SCR"
  "EW\020\006\022\013\n\007GEARBOX\020\007\022\t\n\005FIXED\020\010\"\261\001\n\020SetLink"
  "WorldPose\022\022\n\nmodel_name\030\001 \002(\t\022\021\n\tlink_na"
  "me\030\002 \002(\t\0228\n\004pose\030\003 \002(\0132*.mw.internal.rob"
  "otics.gazebotransport.Pose\022<\n\010duration\030\004"
  " \002(\0132*.mw.internal.robotics.gazebotransp"
  "ort.Time\"\273\001\n\025SetLinkLinearVelocity\022\022\n\nmo"
  "del_name\030\001 \002(\t\022\021\n\tlink_name\030\002 \002(\t\022=\n\010vel"
  "ocity\030\003 \002(\0132+.mw.internal.robotics.gazeb"
  "otransport.Point\022<\n\010duration\030\004 \002(\0132*.mw."
  "internal.robotics.gazebotransport.Time\"\274"
  "\001\n\026SetLinkAngularVelocity\022\022\n\nmodel_name\030"
  "\001 \002(\t\022\021\n\tlink_name\030\002 \002(\t\022=\n\010velocity\030\003 \002"
  "(\0132+.mw.internal.robotics.gazebotranspor"
  "t.Point\022<\n\010duration\030\004 \002(\0132*.mw.internal."
  "robotics.gazebotransport.Time\"5\n\014GetLink"
  "State\022\022\n\nmodel_name\030\001 \002(\t\022\021\n\tlink_name\030\002"
  " \002(\t\"\340\004\n\tLinkState\022\022\n\nmodel_name\030\001 \002(\t\022\021"
  "\n\tlink_name\030\002 \002(\t\022\017\n\007link_id\030\003 \002(\r\022J\n\025wo"
  "rld_linear_velocity\030\004 \002(\0132+.mw.internal."
  "robotics.gazebotransport.Point\022K\n\026world_"
  "angular_velocity\030\005 \002(\0132+.mw.internal.rob"
  "otics.gazebotransport.Point\022M\n\030relative_"
  "linear_velocity\030\006 \002(\0132+.mw.internal.robo"
  "tics.gazebotransport.Point\022N\n\031relative_a"
  "ngular_velocity\030\007 \002(\0132+.mw.internal.robo"
  "tics.gazebotransport.Point\022>\n\nworld_pose"
  "\030\010 \001(\0132*.mw.internal.robotics.gazebotran"
  "sport.Pose\022A\n\rrelative_pose\030\t \001(\0132*.mw.i"
  "nternal.robotics.gazebotransport.Pose\022\024\n"
  "\014self_collide\030\n \001(\010\022\017\n\007gravity\030\013 \001(\010\022\021\n\t"
  "kinematic\030\014 \001(\010\022\023\n\013enable_wind\030\r \001(\010\022\021\n\t"
  "canonical\030\016 \001(\010\"\037\n\007ML_Cord\022\t\n\001x\030\001 \001(\001\022\t\n"
  "\001y\030\002 \001(\001\"+\n\010ML_Point\022\t\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001"
  "(\001\022\t\n\001z\030\003 \001(\001\"5\n\007ML_Quat\022\t\n\001x\030\001 \001(\001\022\t\n\001y"
  "\030\002 \001(\001\022\t\n\001z\030\003 \001(\001\022\t\n\001w\030\004 \001(\001\"\217\001\n\007ML_Pose"
  "\022@\n\010position\030\001 \001(\0132..mw.internal.robotic"
  "s.gazebotransport.ML_Point\022B\n\013orientatio"
  "n\030\002 \001(\0132-.mw.internal.robotics.gazebotra"
  "nsport.ML_Quat\"i\n\013ML_Inertial\022\014\n\004mass\030\001 "
  "\001(\001\022\013\n\003ixx\030\002 \001(\001\022\013\n\003ixy\030\003 \001(\001\022\013\n\003ixz\030\004 \001"
  "(\001\022\013\n\003iyy\030\005 \001(\001\022\013\n\003iyz\030\006 \001(\001\022\013\n\003izz\030\007 \001("
  "\001\"\220\002\n\010ML_Links\022\014\n\004name\030\001 \001(\t\022;\n\004pose\030\002 \001"
  "(\0132-.mw.internal.robotics.gazebotranspor"
  "t.ML_Pose\022C\n\010inertial\030\003 \001(\01321.mw.interna"
  "l.robotics.gazebotransport.ML_Inertial\022\024"
  "\n\014self_collide\030\004 \001(\010\022\017\n\007gravity\030\005 \001(\010\022\021\n"
  "\tkinematic\030\006 \001(\010\022\024\n\014enabled_wind\030\007 \001(\010\022\021"
  "\n\tis_static\030\010 \001(\010\022\021\n\tcanonical\030\t \001(\010\"x\n\007"
  "ML_Axis\022;\n\003xyz\030\001 \001(\0132..mw.internal.robot"
  "ics.gazebotransport.ML_Point\022\017\n\007damping\030"
  "\002 \001(\001\022\020\n\010friction\030\003 \001(\001\022\r\n\005angle\030\004 \001(\001\"\262"
  "\002\n\tML_Joints\022\014\n\004name\030\001 \001(\t\022;\n\004pose\030\002 \001(\013"
  "2-.mw.internal.robotics.gazebotransport."
  "ML_Pose\022<\n\005axis1\030\003 \001(\0132-.mw.internal.rob"
  "otics.gazebotransport.ML_Axis\022<\n\005axis2\030\004"
  " \001(\0132-.mw.internal.robotics.gazebotransp"
  "ort.ML_Axis\022\013\n\003cfm\030\005 \001(\001\022\024\n\014fudge_factor"
  "\030\006 \001(\001\022\026\n\016suspension_cfm\030\007 \001(\001\022\026\n\016suspen"
  "sion_erp\030\010 \001(\001\022\013\n\003dof\030\t \001(\r\"\226\002\n\013Gazebomo"
  "del\022\014\n\004name\030\001 \002(\t\022=\n\005links\030\002 \003(\0132..mw.in"
  "ternal.robotics.gazebotransport.ML_Links"
  "\022\?\n\006joints\030\003 \003(\0132/.mw.internal.robotics."
  "gazebotransport.ML_Joints\022;\n\004pose\030\004 \001(\0132"
  "-.mw.internal.robotics.gazebotransport.M"
  "L_Pose\022\023\n\013enable_wind\030\005 \001(\010\022\024\n\014self_coll"
  "ide\030\006 \001(\010\022\021\n\tis_static\030\007 \001(\010\"S\n\023GetGazeb"
  "oModelParam\022\022\n\nmodel_name\030\001 \002(\t\022\017\n\007is_li"
  "nk\030\002 \001(\010\022\027\n\017link_joint_name\030\003 \001(\t\"8\n\016Gaz"
  "eboModelSDF\022\022\n\nmodel_name\030\001 \002(\t\022\022\n\nsdf_s"
  "tring\030\002 \002(\t\"\'\n\021GetGazeboModelSDF\022\022\n\nmode"
  "l_name\030\001 \002(\t"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto_sccs[60] = {
  &scc_info_ApplyJointTorque_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_ApplyLinkWrench_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_Axis_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_CustomMessageSupport_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_GazeboModelSDF_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_Gazebomodel_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_GetGazeboModelParam_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_GetGazeboModelSDF_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_GetGroundTruthWorldPose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_GetJointState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_GetLinkState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_GetModelInfo_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_GetPose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_GetTopicList_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_Image_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_ImuData_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_InitCustomPublisher_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_InitCustomSubscriber_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_JointState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_LaserData_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_LinkState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_ML_Axis_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_ML_Cord_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_ML_Inertial_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_ML_Joints_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_ML_Links_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_ML_Point_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_ML_Pose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_ML_Quat_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_MaxStepSize_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_ModelInfo_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_ModelInfo_JOINTS_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_ModelInfo_LINKS_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_ModelInfo_Model_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_Packet_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_PacketHeader_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_PluginVersion_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_Point_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_Pose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_Quaternion_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_RequestCoSim_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_RequestCustomMessageSupport_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_RequestImage_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_RequestImu_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_RequestLaser_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_ResetSimulation_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_SetJointPosition_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_SetJointVelocity_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_SetLinkAngularVelocity_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_SetLinkLinearVelocity_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_SetLinkWorldPose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_StepSimulation_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_StopCoSim_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_StopSimulation_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_SubscribeImage_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_SubscribeImu_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_SubscribeLaser_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_Time_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_TopicList_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
  &scc_info_TopicList_TopicInfo_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto = {
  false, false, descriptor_table_protodef_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto, "mw.internal.robotics.gazebotransport.CoSimMsgs.proto", 12132,
  &descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto_once, descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto_sccs, descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto_deps, 60, 0,
  schemas, file_default_instances, TableStruct_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::offsets,
  file_level_metadata_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto, 60, file_level_enum_descriptors_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto, file_level_service_descriptors_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto = (static_cast<void>(::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto)), true);
namespace mw {
namespace internal {
namespace robotics {
namespace gazebotransport {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PacketHeader_MsgID_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
  return file_level_enum_descriptors_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto[0];
}
bool PacketHeader_MsgID_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr PacketHeader_MsgID PacketHeader::STATUS;
constexpr PacketHeader_MsgID PacketHeader::STEP_SIMULATION;
constexpr PacketHeader_MsgID PacketHeader::RESET_SIMULATION;
constexpr PacketHeader_MsgID PacketHeader::IMAGE;
constexpr PacketHeader_MsgID PacketHeader::REQUEST_IMAGE;
constexpr PacketHeader_MsgID PacketHeader::REQUEST_COSIM;
constexpr PacketHeader_MsgID PacketHeader::STOP_COSIM;
constexpr PacketHeader_MsgID PacketHeader::GET_GROUND_TRUTH_WORLD_POSE;
constexpr PacketHeader_MsgID PacketHeader::POSE;
constexpr PacketHeader_MsgID PacketHeader::STOP_SIMULATION;
constexpr PacketHeader_MsgID PacketHeader::LASER_DATA;
constexpr PacketHeader_MsgID PacketHeader::REQUEST_LASER;
constexpr PacketHeader_MsgID PacketHeader::IMU_DATA;
constexpr PacketHeader_MsgID PacketHeader::REQUEST_IMU;
constexpr PacketHeader_MsgID PacketHeader::SUBSCRIBE_IMAGE;
constexpr PacketHeader_MsgID PacketHeader::SUBSCRIBE_LASER;
constexpr PacketHeader_MsgID PacketHeader::SUBSCRIBE_IMU;
constexpr PacketHeader_MsgID PacketHeader::APPLY_JOINT_TORQUE;
constexpr PacketHeader_MsgID PacketHeader::GET_POSE;
constexpr PacketHeader_MsgID PacketHeader::GET_TOPIC_LIST;
constexpr PacketHeader_MsgID PacketHeader::TOPIC_LIST;
constexpr PacketHeader_MsgID PacketHeader::GET_MODEL_INFO;
constexpr PacketHeader_MsgID PacketHeader::MODEL_INFO;
constexpr PacketHeader_MsgID PacketHeader::APPLY_LINK_WRENCH;
constexpr PacketHeader_MsgID PacketHeader::MAX_STEP_SIZE;
constexpr PacketHeader_MsgID PacketHeader::CUSTOM_MESSAGE_SUBSCRIBER;
constexpr PacketHeader_MsgID PacketHeader::CUSTOM_MESSAGE_PUBLISHER;
constexpr PacketHeader_MsgID PacketHeader::INIT_CUSTOM_MESSAGE_PUBLISHER;
constexpr PacketHeader_MsgID PacketHeader::INIT_CUSTOM_MESSAGE_SUBSCRIBER;
constexpr PacketHeader_MsgID PacketHeader::SET_JOINT_POSITION;
constexpr PacketHeader_MsgID PacketHeader::SET_JOINT_VELOCITY;
constexpr PacketHeader_MsgID PacketHeader::GET_JOINT_STATE;
constexpr PacketHeader_MsgID PacketHeader::JOINT_STATE;
constexpr PacketHeader_MsgID PacketHeader::SET_LINK_WORLD_POSE;
constexpr PacketHeader_MsgID PacketHeader::SET_LINK_LINEAR_VELOCITY;
constexpr PacketHeader_MsgID PacketHeader::SET_LINK_ANGULAR_VELOCITY;
constexpr PacketHeader_MsgID PacketHeader::GET_LINK_STATE;
constexpr PacketHeader_MsgID PacketHeader::LINK_STATE;
constexpr PacketHeader_MsgID PacketHeader::GAZEBO_MODEL;
constexpr PacketHeader_MsgID PacketHeader::SET_GAZEBO_MODEL_PARAM;
constexpr PacketHeader_MsgID PacketHeader::GET_GAZEBO_MODEL_PARAM;
constexpr PacketHeader_MsgID PacketHeader::GAZEBO_MODEL_SDF;
constexpr PacketHeader_MsgID PacketHeader::GET_GAZEBO_MODEL_SDF;
constexpr PacketHeader_MsgID PacketHeader::MsgID_MIN;
constexpr PacketHeader_MsgID PacketHeader::MsgID_MAX;
constexpr int PacketHeader::MsgID_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Packet_CoSimError_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
  return file_level_enum_descriptors_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto[1];
}
bool Packet_CoSimError_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Packet_CoSimError Packet::NONE;
constexpr Packet_CoSimError Packet::STEP_FAILED;
constexpr Packet_CoSimError Packet::MSG_INVALID;
constexpr Packet_CoSimError Packet::SOCKET_FAILED;
constexpr Packet_CoSimError Packet::RESET_FAILED;
constexpr Packet_CoSimError Packet::COSIM_FAILED;
constexpr Packet_CoSimError Packet::STOP_COSIM_FAILED;
constexpr Packet_CoSimError Packet::GET_GROUND_TRUTH_WORLD_POSE_FAILED;
constexpr Packet_CoSimError Packet::RESET_TIME_SCENE_FAILED;
constexpr Packet_CoSimError Packet::RESET_TIME_FAILED;
constexpr Packet_CoSimError Packet::STOP_FAILED;
constexpr Packet_CoSimError Packet::FORCE_TYPE_INVALID;
constexpr Packet_CoSimError Packet::MODEL_NAME_INVALID;
constexpr Packet_CoSimError Packet::LINK_NAME_INVALID;
constexpr Packet_CoSimError Packet::JOINT_NAME_INVALID;
constexpr Packet_CoSimError Packet::TOPIC_NAME_INVALID;
constexpr Packet_CoSimError Packet::TORQUE_TYPE_INVALID;
constexpr Packet_CoSimError Packet::MAX_STEP_SIZE_ERROR;
constexpr Packet_CoSimError Packet::CUSTOM_MESSAGE_INVALID;
constexpr Packet_CoSimError Packet::MESSAGE_TYPE_INVALID;
constexpr Packet_CoSimError Packet::JOINT_AXIS_NONE;
constexpr Packet_CoSimError Packet::INVALID_JOINT_AXIS;
constexpr Packet_CoSimError Packet::CoSimError_MIN;
constexpr Packet_CoSimError Packet::CoSimError_MAX;
constexpr int Packet::CoSimError_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResetSimulation_ResetBehavior_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
  return file_level_enum_descriptors_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto[2];
}
bool ResetSimulation_ResetBehavior_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr ResetSimulation_ResetBehavior ResetSimulation::RESET_TIME;
constexpr ResetSimulation_ResetBehavior ResetSimulation::RESET_TIME_AND_SCENE;
constexpr ResetSimulation_ResetBehavior ResetSimulation::ResetBehavior_MIN;
constexpr ResetSimulation_ResetBehavior ResetSimulation::ResetBehavior_MAX;
constexpr int ResetSimulation::ResetBehavior_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MaxStepSize_TYPE_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
  return file_level_enum_descriptors_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto[3];
}
bool MaxStepSize_TYPE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr MaxStepSize_TYPE MaxStepSize::SET_STEP_SIZE;
constexpr MaxStepSize_TYPE MaxStepSize::GET_STEP_SIZE;
constexpr MaxStepSize_TYPE MaxStepSize::TYPE_MIN;
constexpr MaxStepSize_TYPE MaxStepSize::TYPE_MAX;
constexpr int MaxStepSize::TYPE_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JointState_Joint_Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
  return file_level_enum_descriptors_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto[4];
}
bool JointState_Joint_Type_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr JointState_Joint_Type JointState::REVOLUTE;
constexpr JointState_Joint_Type JointState::REVOLUTE2;
constexpr JointState_Joint_Type JointState::PRISMATIC;
constexpr JointState_Joint_Type JointState::UNIVERSAL;
constexpr JointState_Joint_Type JointState::BALL;
constexpr JointState_Joint_Type JointState::SCREW;
constexpr JointState_Joint_Type JointState::GEARBOX;
constexpr JointState_Joint_Type JointState::FIXED;
constexpr JointState_Joint_Type JointState::Joint_Type_MIN;
constexpr JointState_Joint_Type JointState::Joint_Type_MAX;
constexpr int JointState::Joint_Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

void PluginVersion::InitAsDefaultInstance() {
}
class PluginVersion::_Internal {
 public:
  using HasBits = decltype(std::declval<PluginVersion>()._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PluginVersion::_i_give_permission_to_break_this_code_default_version_;
PluginVersion::PluginVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.PluginVersion)
}
PluginVersion::PluginVersion(const PluginVersion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  version_.UnsafeSetDefault(&::mw::internal::robotics::gazebotransport::PluginVersion::_i_give_permission_to_break_this_code_default_version_.get());
  if (from._internal_has_version()) {
    version_.Set(&::mw::internal::robotics::gazebotransport::PluginVersion::_i_give_permission_to_break_this_code_default_version_.get(), from._internal_version(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.PluginVersion)
}

void PluginVersion::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_PluginVersion_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  version_.UnsafeSetDefault(&::mw::internal::robotics::gazebotransport::PluginVersion::_i_give_permission_to_break_this_code_default_version_.get());
}

PluginVersion::~PluginVersion() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.PluginVersion)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void PluginVersion::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  version_.DestroyNoArena(&::mw::internal::robotics::gazebotransport::PluginVersion::_i_give_permission_to_break_this_code_default_version_.get());
}

void PluginVersion::ArenaDtor(void* object) {
  PluginVersion* _this = reinterpret_cast< PluginVersion* >(object);
  (void)_this;
}
void PluginVersion::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PluginVersion::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PluginVersion& PluginVersion::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PluginVersion_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void PluginVersion::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.PluginVersion)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    version_.ClearToDefault(&::mw::internal::robotics::gazebotransport::PluginVersion::_i_give_permission_to_break_this_code_default_version_.get(), GetArena());
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PluginVersion::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string version = 1 [default = "R2022b"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_version();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.PluginVersion.version");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PluginVersion::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.PluginVersion)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string version = 1 [default = "R2022b"];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.PluginVersion.version");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.PluginVersion)
  return target;
}

size_t PluginVersion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.PluginVersion)
  size_t total_size = 0;

  // required string version = 1 [default = "R2022b"];
  if (_internal_has_version()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_version());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PluginVersion::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.PluginVersion)
  GOOGLE_DCHECK_NE(&from, this);
  const PluginVersion* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<PluginVersion>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.PluginVersion)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.PluginVersion)
    MergeFrom(*source);
  }
}

void PluginVersion::MergeFrom(const PluginVersion& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.PluginVersion)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_version()) {
    _internal_set_version(from._internal_version());
  }
}

void PluginVersion::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.PluginVersion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PluginVersion::CopyFrom(const PluginVersion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.PluginVersion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PluginVersion::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void PluginVersion::InternalSwap(PluginVersion* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  version_.Swap(&other->version_, &::mw::internal::robotics::gazebotransport::PluginVersion::_i_give_permission_to_break_this_code_default_version_.get(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata PluginVersion::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Time::InitAsDefaultInstance() {
}
class Time::_Internal {
 public:
  using HasBits = decltype(std::declval<Time>()._has_bits_);
  static void set_has_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nano_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

Time::Time(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.Time)
}
Time::Time(const Time& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&seconds_, &from.seconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&nano_seconds_) -
    reinterpret_cast<char*>(&seconds_)) + sizeof(nano_seconds_));
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.Time)
}

void Time::SharedCtor() {
  ::memset(&seconds_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&nano_seconds_) -
      reinterpret_cast<char*>(&seconds_)) + sizeof(nano_seconds_));
}

Time::~Time() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.Time)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Time::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Time::ArenaDtor(void* object) {
  Time* _this = reinterpret_cast< Time* >(object);
  (void)_this;
}
void Time::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Time::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Time& Time::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Time_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void Time::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.Time)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&seconds_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&nano_seconds_) -
        reinterpret_cast<char*>(&seconds_)) + sizeof(nano_seconds_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Time::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint64 seconds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_seconds(&has_bits);
          seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 nano_seconds = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_nano_seconds(&has_bits);
          nano_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Time::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.Time)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 seconds = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_seconds(), target);
  }

  // required uint64 nano_seconds = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_nano_seconds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.Time)
  return target;
}

size_t Time::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.Time)
  size_t total_size = 0;

  if (_internal_has_seconds()) {
    // required uint64 seconds = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_seconds());
  }

  if (_internal_has_nano_seconds()) {
    // required uint64 nano_seconds = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_nano_seconds());
  }

  return total_size;
}
size_t Time::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.Time)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 seconds = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_seconds());

    // required uint64 nano_seconds = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_nano_seconds());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Time::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.Time)
  GOOGLE_DCHECK_NE(&from, this);
  const Time* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Time>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.Time)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.Time)
    MergeFrom(*source);
  }
}

void Time::MergeFrom(const Time& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.Time)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      seconds_ = from.seconds_;
    }
    if (cached_has_bits & 0x00000002u) {
      nano_seconds_ = from.nano_seconds_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Time::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.Time)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Time::CopyFrom(const Time& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.Time)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Time::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void Time::InternalSwap(Time* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Time, nano_seconds_)
      + sizeof(Time::nano_seconds_)
      - PROTOBUF_FIELD_OFFSET(Time, seconds_)>(
          reinterpret_cast<char*>(&seconds_),
          reinterpret_cast<char*>(&other->seconds_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Time::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void PacketHeader::InitAsDefaultInstance() {
  ::mw::internal::robotics::gazebotransport::_PacketHeader_default_instance_._instance.get_mutable()->time_stamp_ = const_cast< ::mw::internal::robotics::gazebotransport::Time*>(
      ::mw::internal::robotics::gazebotransport::Time::internal_default_instance());
}
class PacketHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<PacketHeader>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::mw::internal::robotics::gazebotransport::Time& time_stamp(const PacketHeader* msg);
  static void set_has_time_stamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::mw::internal::robotics::gazebotransport::Time&
PacketHeader::_Internal::time_stamp(const PacketHeader* msg) {
  return *msg->time_stamp_;
}
PacketHeader::PacketHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.PacketHeader)
}
PacketHeader::PacketHeader(const PacketHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_time_stamp()) {
    time_stamp_ = new ::mw::internal::robotics::gazebotransport::Time(*from.time_stamp_);
  } else {
    time_stamp_ = nullptr;
  }
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.PacketHeader)
}

void PacketHeader::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_PacketHeader_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  ::memset(&time_stamp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&id_) -
      reinterpret_cast<char*>(&time_stamp_)) + sizeof(id_));
}

PacketHeader::~PacketHeader() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.PacketHeader)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void PacketHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete time_stamp_;
}

void PacketHeader::ArenaDtor(void* object) {
  PacketHeader* _this = reinterpret_cast< PacketHeader* >(object);
  (void)_this;
}
void PacketHeader::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PacketHeader::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PacketHeader& PacketHeader::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PacketHeader_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void PacketHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.PacketHeader)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(time_stamp_ != nullptr);
    time_stamp_->Clear();
  }
  id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PacketHeader::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .mw.internal.robotics.gazebotransport.PacketHeader.MsgID id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mw::internal::robotics::gazebotransport::PacketHeader_MsgID_IsValid(val))) {
            _internal_set_id(static_cast<::mw::internal::robotics::gazebotransport::PacketHeader_MsgID>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // required .mw.internal.robotics.gazebotransport.Time time_stamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_time_stamp(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PacketHeader::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.PacketHeader)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .mw.internal.robotics.gazebotransport.PacketHeader.MsgID id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_id(), target);
  }

  // required .mw.internal.robotics.gazebotransport.Time time_stamp = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::time_stamp(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.PacketHeader)
  return target;
}

size_t PacketHeader::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.PacketHeader)
  size_t total_size = 0;

  if (_internal_has_time_stamp()) {
    // required .mw.internal.robotics.gazebotransport.Time time_stamp = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *time_stamp_);
  }

  if (_internal_has_id()) {
    // required .mw.internal.robotics.gazebotransport.PacketHeader.MsgID id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_id());
  }

  return total_size;
}
size_t PacketHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.PacketHeader)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .mw.internal.robotics.gazebotransport.Time time_stamp = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *time_stamp_);

    // required .mw.internal.robotics.gazebotransport.PacketHeader.MsgID id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PacketHeader::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.PacketHeader)
  GOOGLE_DCHECK_NE(&from, this);
  const PacketHeader* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<PacketHeader>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.PacketHeader)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.PacketHeader)
    MergeFrom(*source);
  }
}

void PacketHeader::MergeFrom(const PacketHeader& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.PacketHeader)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_time_stamp()->::mw::internal::robotics::gazebotransport::Time::MergeFrom(from._internal_time_stamp());
    }
    if (cached_has_bits & 0x00000002u) {
      id_ = from.id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PacketHeader::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.PacketHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PacketHeader::CopyFrom(const PacketHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.PacketHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PacketHeader::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_time_stamp()) {
    if (!time_stamp_->IsInitialized()) return false;
  }
  return true;
}

void PacketHeader::InternalSwap(PacketHeader* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PacketHeader, id_)
      + sizeof(PacketHeader::id_)
      - PROTOBUF_FIELD_OFFSET(PacketHeader, time_stamp_)>(
          reinterpret_cast<char*>(&time_stamp_),
          reinterpret_cast<char*>(&other->time_stamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PacketHeader::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Packet::InitAsDefaultInstance() {
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_._instance.get_mutable()->header_ = const_cast< ::mw::internal::robotics::gazebotransport::PacketHeader*>(
      ::mw::internal::robotics::gazebotransport::PacketHeader::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.status_ = 0;
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.step_simulation_ = const_cast< ::mw::internal::robotics::gazebotransport::StepSimulation*>(
      ::mw::internal::robotics::gazebotransport::StepSimulation::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.reset_simulation_ = const_cast< ::mw::internal::robotics::gazebotransport::ResetSimulation*>(
      ::mw::internal::robotics::gazebotransport::ResetSimulation::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.image_ = const_cast< ::mw::internal::robotics::gazebotransport::Image*>(
      ::mw::internal::robotics::gazebotransport::Image::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.request_image_ = const_cast< ::mw::internal::robotics::gazebotransport::RequestImage*>(
      ::mw::internal::robotics::gazebotransport::RequestImage::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.request_cosim_ = const_cast< ::mw::internal::robotics::gazebotransport::RequestCoSim*>(
      ::mw::internal::robotics::gazebotransport::RequestCoSim::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.stop_cosim_ = const_cast< ::mw::internal::robotics::gazebotransport::StopCoSim*>(
      ::mw::internal::robotics::gazebotransport::StopCoSim::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.get_ground_truth_world_pose_ = const_cast< ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose*>(
      ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.pose_ = const_cast< ::mw::internal::robotics::gazebotransport::Pose*>(
      ::mw::internal::robotics::gazebotransport::Pose::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.stop_simulation_ = const_cast< ::mw::internal::robotics::gazebotransport::StopSimulation*>(
      ::mw::internal::robotics::gazebotransport::StopSimulation::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.laser_data_ = const_cast< ::mw::internal::robotics::gazebotransport::LaserData*>(
      ::mw::internal::robotics::gazebotransport::LaserData::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.request_laser_ = const_cast< ::mw::internal::robotics::gazebotransport::RequestLaser*>(
      ::mw::internal::robotics::gazebotransport::RequestLaser::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.imu_data_ = const_cast< ::mw::internal::robotics::gazebotransport::ImuData*>(
      ::mw::internal::robotics::gazebotransport::ImuData::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.request_imu_ = const_cast< ::mw::internal::robotics::gazebotransport::RequestImu*>(
      ::mw::internal::robotics::gazebotransport::RequestImu::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.subscribe_image_ = const_cast< ::mw::internal::robotics::gazebotransport::SubscribeImage*>(
      ::mw::internal::robotics::gazebotransport::SubscribeImage::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.subscribe_laser_ = const_cast< ::mw::internal::robotics::gazebotransport::SubscribeLaser*>(
      ::mw::internal::robotics::gazebotransport::SubscribeLaser::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.subscribe_imu_ = const_cast< ::mw::internal::robotics::gazebotransport::SubscribeImu*>(
      ::mw::internal::robotics::gazebotransport::SubscribeImu::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.apply_joint_torque_ = const_cast< ::mw::internal::robotics::gazebotransport::ApplyJointTorque*>(
      ::mw::internal::robotics::gazebotransport::ApplyJointTorque::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.get_pose_ = const_cast< ::mw::internal::robotics::gazebotransport::GetPose*>(
      ::mw::internal::robotics::gazebotransport::GetPose::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.get_topic_list_ = const_cast< ::mw::internal::robotics::gazebotransport::GetTopicList*>(
      ::mw::internal::robotics::gazebotransport::GetTopicList::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.topic_list_ = const_cast< ::mw::internal::robotics::gazebotransport::TopicList*>(
      ::mw::internal::robotics::gazebotransport::TopicList::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.get_model_info_ = const_cast< ::mw::internal::robotics::gazebotransport::GetModelInfo*>(
      ::mw::internal::robotics::gazebotransport::GetModelInfo::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.model_info_ = const_cast< ::mw::internal::robotics::gazebotransport::ModelInfo*>(
      ::mw::internal::robotics::gazebotransport::ModelInfo::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.apply_link_wrench_ = const_cast< ::mw::internal::robotics::gazebotransport::ApplyLinkWrench*>(
      ::mw::internal::robotics::gazebotransport::ApplyLinkWrench::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.max_step_size_ = const_cast< ::mw::internal::robotics::gazebotransport::MaxStepSize*>(
      ::mw::internal::robotics::gazebotransport::MaxStepSize::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.custom_message_support_ = const_cast< ::mw::internal::robotics::gazebotransport::CustomMessageSupport*>(
      ::mw::internal::robotics::gazebotransport::CustomMessageSupport::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.init_custom_publisher_ = const_cast< ::mw::internal::robotics::gazebotransport::InitCustomPublisher*>(
      ::mw::internal::robotics::gazebotransport::InitCustomPublisher::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.init_custom_subscriber_ = const_cast< ::mw::internal::robotics::gazebotransport::InitCustomSubscriber*>(
      ::mw::internal::robotics::gazebotransport::InitCustomSubscriber::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.request_custom_message_support_ = const_cast< ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport*>(
      ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.set_joint_position_ = const_cast< ::mw::internal::robotics::gazebotransport::SetJointPosition*>(
      ::mw::internal::robotics::gazebotransport::SetJointPosition::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.set_joint_velocity_ = const_cast< ::mw::internal::robotics::gazebotransport::SetJointVelocity*>(
      ::mw::internal::robotics::gazebotransport::SetJointVelocity::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.get_joint_state_ = const_cast< ::mw::internal::robotics::gazebotransport::GetJointState*>(
      ::mw::internal::robotics::gazebotransport::GetJointState::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.joint_state_ = const_cast< ::mw::internal::robotics::gazebotransport::JointState*>(
      ::mw::internal::robotics::gazebotransport::JointState::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.set_link_world_pose_ = const_cast< ::mw::internal::robotics::gazebotransport::SetLinkWorldPose*>(
      ::mw::internal::robotics::gazebotransport::SetLinkWorldPose::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.set_link_linear_velocity_ = const_cast< ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity*>(
      ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.set_link_angular_velocity_ = const_cast< ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity*>(
      ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.get_link_state_ = const_cast< ::mw::internal::robotics::gazebotransport::GetLinkState*>(
      ::mw::internal::robotics::gazebotransport::GetLinkState::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.link_state_ = const_cast< ::mw::internal::robotics::gazebotransport::LinkState*>(
      ::mw::internal::robotics::gazebotransport::LinkState::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.gazebo_model_ = const_cast< ::mw::internal::robotics::gazebotransport::Gazebomodel*>(
      ::mw::internal::robotics::gazebotransport::Gazebomodel::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.get_gazebo_model_param_ = const_cast< ::mw::internal::robotics::gazebotransport::GetGazeboModelParam*>(
      ::mw::internal::robotics::gazebotransport::GetGazeboModelParam::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.gazebo_model_sdf_ = const_cast< ::mw::internal::robotics::gazebotransport::GazeboModelSDF*>(
      ::mw::internal::robotics::gazebotransport::GazeboModelSDF::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Packet_default_instance_.get_gazebo_model_sdf_ = const_cast< ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF*>(
      ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF::internal_default_instance());
}
class Packet::_Internal {
 public:
  using HasBits = decltype(std::declval<Packet>()._has_bits_);
  static const ::mw::internal::robotics::gazebotransport::PacketHeader& header(const Packet* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::mw::internal::robotics::gazebotransport::StepSimulation& step_simulation(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::ResetSimulation& reset_simulation(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::Image& image(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::RequestImage& request_image(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::RequestCoSim& request_cosim(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::StopCoSim& stop_cosim(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose& get_ground_truth_world_pose(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::Pose& pose(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::StopSimulation& stop_simulation(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::LaserData& laser_data(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::RequestLaser& request_laser(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::ImuData& imu_data(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::RequestImu& request_imu(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::SubscribeImage& subscribe_image(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::SubscribeLaser& subscribe_laser(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::SubscribeImu& subscribe_imu(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::ApplyJointTorque& apply_joint_torque(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::GetPose& get_pose(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::GetTopicList& get_topic_list(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::TopicList& topic_list(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::GetModelInfo& get_model_info(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::ModelInfo& model_info(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::ApplyLinkWrench& apply_link_wrench(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::MaxStepSize& max_step_size(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::CustomMessageSupport& custom_message_support(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::InitCustomPublisher& init_custom_publisher(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::InitCustomSubscriber& init_custom_subscriber(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport& request_custom_message_support(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::SetJointPosition& set_joint_position(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::SetJointVelocity& set_joint_velocity(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::GetJointState& get_joint_state(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::JointState& joint_state(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::SetLinkWorldPose& set_link_world_pose(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity& set_link_linear_velocity(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity& set_link_angular_velocity(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::GetLinkState& get_link_state(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::LinkState& link_state(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::Gazebomodel& gazebo_model(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::GetGazeboModelParam& get_gazebo_model_param(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::GazeboModelSDF& gazebo_model_sdf(const Packet* msg);
  static const ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF& get_gazebo_model_sdf(const Packet* msg);
  static void set_has_error_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_new_reading(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

const ::mw::internal::robotics::gazebotransport::PacketHeader&
Packet::_Internal::header(const Packet* msg) {
  return *msg->header_;
}
const ::mw::internal::robotics::gazebotransport::StepSimulation&
Packet::_Internal::step_simulation(const Packet* msg) {
  return *msg->payload_.step_simulation_;
}
const ::mw::internal::robotics::gazebotransport::ResetSimulation&
Packet::_Internal::reset_simulation(const Packet* msg) {
  return *msg->payload_.reset_simulation_;
}
const ::mw::internal::robotics::gazebotransport::Image&
Packet::_Internal::image(const Packet* msg) {
  return *msg->payload_.image_;
}
const ::mw::internal::robotics::gazebotransport::RequestImage&
Packet::_Internal::request_image(const Packet* msg) {
  return *msg->payload_.request_image_;
}
const ::mw::internal::robotics::gazebotransport::RequestCoSim&
Packet::_Internal::request_cosim(const Packet* msg) {
  return *msg->payload_.request_cosim_;
}
const ::mw::internal::robotics::gazebotransport::StopCoSim&
Packet::_Internal::stop_cosim(const Packet* msg) {
  return *msg->payload_.stop_cosim_;
}
const ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose&
Packet::_Internal::get_ground_truth_world_pose(const Packet* msg) {
  return *msg->payload_.get_ground_truth_world_pose_;
}
const ::mw::internal::robotics::gazebotransport::Pose&
Packet::_Internal::pose(const Packet* msg) {
  return *msg->payload_.pose_;
}
const ::mw::internal::robotics::gazebotransport::StopSimulation&
Packet::_Internal::stop_simulation(const Packet* msg) {
  return *msg->payload_.stop_simulation_;
}
const ::mw::internal::robotics::gazebotransport::LaserData&
Packet::_Internal::laser_data(const Packet* msg) {
  return *msg->payload_.laser_data_;
}
const ::mw::internal::robotics::gazebotransport::RequestLaser&
Packet::_Internal::request_laser(const Packet* msg) {
  return *msg->payload_.request_laser_;
}
const ::mw::internal::robotics::gazebotransport::ImuData&
Packet::_Internal::imu_data(const Packet* msg) {
  return *msg->payload_.imu_data_;
}
const ::mw::internal::robotics::gazebotransport::RequestImu&
Packet::_Internal::request_imu(const Packet* msg) {
  return *msg->payload_.request_imu_;
}
const ::mw::internal::robotics::gazebotransport::SubscribeImage&
Packet::_Internal::subscribe_image(const Packet* msg) {
  return *msg->payload_.subscribe_image_;
}
const ::mw::internal::robotics::gazebotransport::SubscribeLaser&
Packet::_Internal::subscribe_laser(const Packet* msg) {
  return *msg->payload_.subscribe_laser_;
}
const ::mw::internal::robotics::gazebotransport::SubscribeImu&
Packet::_Internal::subscribe_imu(const Packet* msg) {
  return *msg->payload_.subscribe_imu_;
}
const ::mw::internal::robotics::gazebotransport::ApplyJointTorque&
Packet::_Internal::apply_joint_torque(const Packet* msg) {
  return *msg->payload_.apply_joint_torque_;
}
const ::mw::internal::robotics::gazebotransport::GetPose&
Packet::_Internal::get_pose(const Packet* msg) {
  return *msg->payload_.get_pose_;
}
const ::mw::internal::robotics::gazebotransport::GetTopicList&
Packet::_Internal::get_topic_list(const Packet* msg) {
  return *msg->payload_.get_topic_list_;
}
const ::mw::internal::robotics::gazebotransport::TopicList&
Packet::_Internal::topic_list(const Packet* msg) {
  return *msg->payload_.topic_list_;
}
const ::mw::internal::robotics::gazebotransport::GetModelInfo&
Packet::_Internal::get_model_info(const Packet* msg) {
  return *msg->payload_.get_model_info_;
}
const ::mw::internal::robotics::gazebotransport::ModelInfo&
Packet::_Internal::model_info(const Packet* msg) {
  return *msg->payload_.model_info_;
}
const ::mw::internal::robotics::gazebotransport::ApplyLinkWrench&
Packet::_Internal::apply_link_wrench(const Packet* msg) {
  return *msg->payload_.apply_link_wrench_;
}
const ::mw::internal::robotics::gazebotransport::MaxStepSize&
Packet::_Internal::max_step_size(const Packet* msg) {
  return *msg->payload_.max_step_size_;
}
const ::mw::internal::robotics::gazebotransport::CustomMessageSupport&
Packet::_Internal::custom_message_support(const Packet* msg) {
  return *msg->payload_.custom_message_support_;
}
const ::mw::internal::robotics::gazebotransport::InitCustomPublisher&
Packet::_Internal::init_custom_publisher(const Packet* msg) {
  return *msg->payload_.init_custom_publisher_;
}
const ::mw::internal::robotics::gazebotransport::InitCustomSubscriber&
Packet::_Internal::init_custom_subscriber(const Packet* msg) {
  return *msg->payload_.init_custom_subscriber_;
}
const ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport&
Packet::_Internal::request_custom_message_support(const Packet* msg) {
  return *msg->payload_.request_custom_message_support_;
}
const ::mw::internal::robotics::gazebotransport::SetJointPosition&
Packet::_Internal::set_joint_position(const Packet* msg) {
  return *msg->payload_.set_joint_position_;
}
const ::mw::internal::robotics::gazebotransport::SetJointVelocity&
Packet::_Internal::set_joint_velocity(const Packet* msg) {
  return *msg->payload_.set_joint_velocity_;
}
const ::mw::internal::robotics::gazebotransport::GetJointState&
Packet::_Internal::get_joint_state(const Packet* msg) {
  return *msg->payload_.get_joint_state_;
}
const ::mw::internal::robotics::gazebotransport::JointState&
Packet::_Internal::joint_state(const Packet* msg) {
  return *msg->payload_.joint_state_;
}
const ::mw::internal::robotics::gazebotransport::SetLinkWorldPose&
Packet::_Internal::set_link_world_pose(const Packet* msg) {
  return *msg->payload_.set_link_world_pose_;
}
const ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity&
Packet::_Internal::set_link_linear_velocity(const Packet* msg) {
  return *msg->payload_.set_link_linear_velocity_;
}
const ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity&
Packet::_Internal::set_link_angular_velocity(const Packet* msg) {
  return *msg->payload_.set_link_angular_velocity_;
}
const ::mw::internal::robotics::gazebotransport::GetLinkState&
Packet::_Internal::get_link_state(const Packet* msg) {
  return *msg->payload_.get_link_state_;
}
const ::mw::internal::robotics::gazebotransport::LinkState&
Packet::_Internal::link_state(const Packet* msg) {
  return *msg->payload_.link_state_;
}
const ::mw::internal::robotics::gazebotransport::Gazebomodel&
Packet::_Internal::gazebo_model(const Packet* msg) {
  return *msg->payload_.gazebo_model_;
}
const ::mw::internal::robotics::gazebotransport::GetGazeboModelParam&
Packet::_Internal::get_gazebo_model_param(const Packet* msg) {
  return *msg->payload_.get_gazebo_model_param_;
}
const ::mw::internal::robotics::gazebotransport::GazeboModelSDF&
Packet::_Internal::gazebo_model_sdf(const Packet* msg) {
  return *msg->payload_.gazebo_model_sdf_;
}
const ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF&
Packet::_Internal::get_gazebo_model_sdf(const Packet* msg) {
  return *msg->payload_.get_gazebo_model_sdf_;
}
void Packet::set_allocated_step_simulation(::mw::internal::robotics::gazebotransport::StepSimulation* step_simulation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (step_simulation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(step_simulation);
    if (message_arena != submessage_arena) {
      step_simulation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, step_simulation, submessage_arena);
    }
    set_has_step_simulation();
    payload_.step_simulation_ = step_simulation;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.step_simulation)
}
void Packet::set_allocated_reset_simulation(::mw::internal::robotics::gazebotransport::ResetSimulation* reset_simulation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (reset_simulation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(reset_simulation);
    if (message_arena != submessage_arena) {
      reset_simulation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reset_simulation, submessage_arena);
    }
    set_has_reset_simulation();
    payload_.reset_simulation_ = reset_simulation;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.reset_simulation)
}
void Packet::set_allocated_image(::mw::internal::robotics::gazebotransport::Image* image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(image);
    if (message_arena != submessage_arena) {
      image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    set_has_image();
    payload_.image_ = image;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.image)
}
void Packet::set_allocated_request_image(::mw::internal::robotics::gazebotransport::RequestImage* request_image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (request_image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(request_image);
    if (message_arena != submessage_arena) {
      request_image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_image, submessage_arena);
    }
    set_has_request_image();
    payload_.request_image_ = request_image;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.request_image)
}
void Packet::set_allocated_request_cosim(::mw::internal::robotics::gazebotransport::RequestCoSim* request_cosim) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (request_cosim) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(request_cosim);
    if (message_arena != submessage_arena) {
      request_cosim = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_cosim, submessage_arena);
    }
    set_has_request_cosim();
    payload_.request_cosim_ = request_cosim;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.request_cosim)
}
void Packet::set_allocated_stop_cosim(::mw::internal::robotics::gazebotransport::StopCoSim* stop_cosim) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (stop_cosim) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stop_cosim);
    if (message_arena != submessage_arena) {
      stop_cosim = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stop_cosim, submessage_arena);
    }
    set_has_stop_cosim();
    payload_.stop_cosim_ = stop_cosim;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.stop_cosim)
}
void Packet::set_allocated_get_ground_truth_world_pose(::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* get_ground_truth_world_pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (get_ground_truth_world_pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(get_ground_truth_world_pose);
    if (message_arena != submessage_arena) {
      get_ground_truth_world_pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_ground_truth_world_pose, submessage_arena);
    }
    set_has_get_ground_truth_world_pose();
    payload_.get_ground_truth_world_pose_ = get_ground_truth_world_pose;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_ground_truth_world_pose)
}
void Packet::set_allocated_pose(::mw::internal::robotics::gazebotransport::Pose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pose);
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    set_has_pose();
    payload_.pose_ = pose;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.pose)
}
void Packet::set_allocated_stop_simulation(::mw::internal::robotics::gazebotransport::StopSimulation* stop_simulation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (stop_simulation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stop_simulation);
    if (message_arena != submessage_arena) {
      stop_simulation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stop_simulation, submessage_arena);
    }
    set_has_stop_simulation();
    payload_.stop_simulation_ = stop_simulation;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.stop_simulation)
}
void Packet::set_allocated_laser_data(::mw::internal::robotics::gazebotransport::LaserData* laser_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (laser_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(laser_data);
    if (message_arena != submessage_arena) {
      laser_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, laser_data, submessage_arena);
    }
    set_has_laser_data();
    payload_.laser_data_ = laser_data;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.laser_data)
}
void Packet::set_allocated_request_laser(::mw::internal::robotics::gazebotransport::RequestLaser* request_laser) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (request_laser) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(request_laser);
    if (message_arena != submessage_arena) {
      request_laser = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_laser, submessage_arena);
    }
    set_has_request_laser();
    payload_.request_laser_ = request_laser;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.request_laser)
}
void Packet::set_allocated_imu_data(::mw::internal::robotics::gazebotransport::ImuData* imu_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (imu_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(imu_data);
    if (message_arena != submessage_arena) {
      imu_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, imu_data, submessage_arena);
    }
    set_has_imu_data();
    payload_.imu_data_ = imu_data;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.imu_data)
}
void Packet::set_allocated_request_imu(::mw::internal::robotics::gazebotransport::RequestImu* request_imu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (request_imu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(request_imu);
    if (message_arena != submessage_arena) {
      request_imu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_imu, submessage_arena);
    }
    set_has_request_imu();
    payload_.request_imu_ = request_imu;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.request_imu)
}
void Packet::set_allocated_subscribe_image(::mw::internal::robotics::gazebotransport::SubscribeImage* subscribe_image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (subscribe_image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(subscribe_image);
    if (message_arena != submessage_arena) {
      subscribe_image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscribe_image, submessage_arena);
    }
    set_has_subscribe_image();
    payload_.subscribe_image_ = subscribe_image;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.subscribe_image)
}
void Packet::set_allocated_subscribe_laser(::mw::internal::robotics::gazebotransport::SubscribeLaser* subscribe_laser) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (subscribe_laser) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(subscribe_laser);
    if (message_arena != submessage_arena) {
      subscribe_laser = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscribe_laser, submessage_arena);
    }
    set_has_subscribe_laser();
    payload_.subscribe_laser_ = subscribe_laser;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.subscribe_laser)
}
void Packet::set_allocated_subscribe_imu(::mw::internal::robotics::gazebotransport::SubscribeImu* subscribe_imu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (subscribe_imu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(subscribe_imu);
    if (message_arena != submessage_arena) {
      subscribe_imu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscribe_imu, submessage_arena);
    }
    set_has_subscribe_imu();
    payload_.subscribe_imu_ = subscribe_imu;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.subscribe_imu)
}
void Packet::set_allocated_apply_joint_torque(::mw::internal::robotics::gazebotransport::ApplyJointTorque* apply_joint_torque) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (apply_joint_torque) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(apply_joint_torque);
    if (message_arena != submessage_arena) {
      apply_joint_torque = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, apply_joint_torque, submessage_arena);
    }
    set_has_apply_joint_torque();
    payload_.apply_joint_torque_ = apply_joint_torque;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.apply_joint_torque)
}
void Packet::set_allocated_get_pose(::mw::internal::robotics::gazebotransport::GetPose* get_pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (get_pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(get_pose);
    if (message_arena != submessage_arena) {
      get_pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_pose, submessage_arena);
    }
    set_has_get_pose();
    payload_.get_pose_ = get_pose;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_pose)
}
void Packet::set_allocated_get_topic_list(::mw::internal::robotics::gazebotransport::GetTopicList* get_topic_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (get_topic_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(get_topic_list);
    if (message_arena != submessage_arena) {
      get_topic_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_topic_list, submessage_arena);
    }
    set_has_get_topic_list();
    payload_.get_topic_list_ = get_topic_list;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_topic_list)
}
void Packet::set_allocated_topic_list(::mw::internal::robotics::gazebotransport::TopicList* topic_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (topic_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(topic_list);
    if (message_arena != submessage_arena) {
      topic_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topic_list, submessage_arena);
    }
    set_has_topic_list();
    payload_.topic_list_ = topic_list;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.topic_list)
}
void Packet::set_allocated_get_model_info(::mw::internal::robotics::gazebotransport::GetModelInfo* get_model_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (get_model_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(get_model_info);
    if (message_arena != submessage_arena) {
      get_model_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_model_info, submessage_arena);
    }
    set_has_get_model_info();
    payload_.get_model_info_ = get_model_info;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_model_info)
}
void Packet::set_allocated_model_info(::mw::internal::robotics::gazebotransport::ModelInfo* model_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (model_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(model_info);
    if (message_arena != submessage_arena) {
      model_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model_info, submessage_arena);
    }
    set_has_model_info();
    payload_.model_info_ = model_info;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.model_info)
}
void Packet::set_allocated_apply_link_wrench(::mw::internal::robotics::gazebotransport::ApplyLinkWrench* apply_link_wrench) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (apply_link_wrench) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(apply_link_wrench);
    if (message_arena != submessage_arena) {
      apply_link_wrench = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, apply_link_wrench, submessage_arena);
    }
    set_has_apply_link_wrench();
    payload_.apply_link_wrench_ = apply_link_wrench;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.apply_link_wrench)
}
void Packet::set_allocated_max_step_size(::mw::internal::robotics::gazebotransport::MaxStepSize* max_step_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (max_step_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(max_step_size);
    if (message_arena != submessage_arena) {
      max_step_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, max_step_size, submessage_arena);
    }
    set_has_max_step_size();
    payload_.max_step_size_ = max_step_size;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.max_step_size)
}
void Packet::set_allocated_custom_message_support(::mw::internal::robotics::gazebotransport::CustomMessageSupport* custom_message_support) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (custom_message_support) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(custom_message_support);
    if (message_arena != submessage_arena) {
      custom_message_support = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, custom_message_support, submessage_arena);
    }
    set_has_custom_message_support();
    payload_.custom_message_support_ = custom_message_support;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.custom_message_support)
}
void Packet::set_allocated_init_custom_publisher(::mw::internal::robotics::gazebotransport::InitCustomPublisher* init_custom_publisher) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (init_custom_publisher) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(init_custom_publisher);
    if (message_arena != submessage_arena) {
      init_custom_publisher = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, init_custom_publisher, submessage_arena);
    }
    set_has_init_custom_publisher();
    payload_.init_custom_publisher_ = init_custom_publisher;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.init_custom_publisher)
}
void Packet::set_allocated_init_custom_subscriber(::mw::internal::robotics::gazebotransport::InitCustomSubscriber* init_custom_subscriber) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (init_custom_subscriber) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(init_custom_subscriber);
    if (message_arena != submessage_arena) {
      init_custom_subscriber = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, init_custom_subscriber, submessage_arena);
    }
    set_has_init_custom_subscriber();
    payload_.init_custom_subscriber_ = init_custom_subscriber;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.init_custom_subscriber)
}
void Packet::set_allocated_request_custom_message_support(::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* request_custom_message_support) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (request_custom_message_support) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(request_custom_message_support);
    if (message_arena != submessage_arena) {
      request_custom_message_support = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_custom_message_support, submessage_arena);
    }
    set_has_request_custom_message_support();
    payload_.request_custom_message_support_ = request_custom_message_support;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.request_custom_message_support)
}
void Packet::set_allocated_set_joint_position(::mw::internal::robotics::gazebotransport::SetJointPosition* set_joint_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (set_joint_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(set_joint_position);
    if (message_arena != submessage_arena) {
      set_joint_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_joint_position, submessage_arena);
    }
    set_has_set_joint_position();
    payload_.set_joint_position_ = set_joint_position;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.set_joint_position)
}
void Packet::set_allocated_set_joint_velocity(::mw::internal::robotics::gazebotransport::SetJointVelocity* set_joint_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (set_joint_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(set_joint_velocity);
    if (message_arena != submessage_arena) {
      set_joint_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_joint_velocity, submessage_arena);
    }
    set_has_set_joint_velocity();
    payload_.set_joint_velocity_ = set_joint_velocity;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.set_joint_velocity)
}
void Packet::set_allocated_get_joint_state(::mw::internal::robotics::gazebotransport::GetJointState* get_joint_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (get_joint_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(get_joint_state);
    if (message_arena != submessage_arena) {
      get_joint_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_joint_state, submessage_arena);
    }
    set_has_get_joint_state();
    payload_.get_joint_state_ = get_joint_state;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_joint_state)
}
void Packet::set_allocated_joint_state(::mw::internal::robotics::gazebotransport::JointState* joint_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (joint_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(joint_state);
    if (message_arena != submessage_arena) {
      joint_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, joint_state, submessage_arena);
    }
    set_has_joint_state();
    payload_.joint_state_ = joint_state;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.joint_state)
}
void Packet::set_allocated_set_link_world_pose(::mw::internal::robotics::gazebotransport::SetLinkWorldPose* set_link_world_pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (set_link_world_pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(set_link_world_pose);
    if (message_arena != submessage_arena) {
      set_link_world_pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_link_world_pose, submessage_arena);
    }
    set_has_set_link_world_pose();
    payload_.set_link_world_pose_ = set_link_world_pose;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.set_link_world_pose)
}
void Packet::set_allocated_set_link_linear_velocity(::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* set_link_linear_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (set_link_linear_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(set_link_linear_velocity);
    if (message_arena != submessage_arena) {
      set_link_linear_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_link_linear_velocity, submessage_arena);
    }
    set_has_set_link_linear_velocity();
    payload_.set_link_linear_velocity_ = set_link_linear_velocity;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.set_link_linear_velocity)
}
void Packet::set_allocated_set_link_angular_velocity(::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* set_link_angular_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (set_link_angular_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(set_link_angular_velocity);
    if (message_arena != submessage_arena) {
      set_link_angular_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_link_angular_velocity, submessage_arena);
    }
    set_has_set_link_angular_velocity();
    payload_.set_link_angular_velocity_ = set_link_angular_velocity;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.set_link_angular_velocity)
}
void Packet::set_allocated_get_link_state(::mw::internal::robotics::gazebotransport::GetLinkState* get_link_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (get_link_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(get_link_state);
    if (message_arena != submessage_arena) {
      get_link_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_link_state, submessage_arena);
    }
    set_has_get_link_state();
    payload_.get_link_state_ = get_link_state;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_link_state)
}
void Packet::set_allocated_link_state(::mw::internal::robotics::gazebotransport::LinkState* link_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (link_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(link_state);
    if (message_arena != submessage_arena) {
      link_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, link_state, submessage_arena);
    }
    set_has_link_state();
    payload_.link_state_ = link_state;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.link_state)
}
void Packet::set_allocated_gazebo_model(::mw::internal::robotics::gazebotransport::Gazebomodel* gazebo_model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (gazebo_model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(gazebo_model);
    if (message_arena != submessage_arena) {
      gazebo_model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gazebo_model, submessage_arena);
    }
    set_has_gazebo_model();
    payload_.gazebo_model_ = gazebo_model;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.gazebo_model)
}
void Packet::set_allocated_get_gazebo_model_param(::mw::internal::robotics::gazebotransport::GetGazeboModelParam* get_gazebo_model_param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (get_gazebo_model_param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(get_gazebo_model_param);
    if (message_arena != submessage_arena) {
      get_gazebo_model_param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_gazebo_model_param, submessage_arena);
    }
    set_has_get_gazebo_model_param();
    payload_.get_gazebo_model_param_ = get_gazebo_model_param;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_param)
}
void Packet::set_allocated_gazebo_model_sdf(::mw::internal::robotics::gazebotransport::GazeboModelSDF* gazebo_model_sdf) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (gazebo_model_sdf) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(gazebo_model_sdf);
    if (message_arena != submessage_arena) {
      gazebo_model_sdf = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gazebo_model_sdf, submessage_arena);
    }
    set_has_gazebo_model_sdf();
    payload_.gazebo_model_sdf_ = gazebo_model_sdf;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.gazebo_model_sdf)
}
void Packet::set_allocated_get_gazebo_model_sdf(::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* get_gazebo_model_sdf) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_payload();
  if (get_gazebo_model_sdf) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(get_gazebo_model_sdf);
    if (message_arena != submessage_arena) {
      get_gazebo_model_sdf = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_gazebo_model_sdf, submessage_arena);
    }
    set_has_get_gazebo_model_sdf();
    payload_.get_gazebo_model_sdf_ = get_gazebo_model_sdf;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_sdf)
}
Packet::Packet(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.Packet)
}
Packet::Packet(const Packet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  error_message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_error_message()) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_error_message(),
      GetArena());
  }
  if (from._internal_has_header()) {
    header_ = new ::mw::internal::robotics::gazebotransport::PacketHeader(*from.header_);
  } else {
    header_ = nullptr;
  }
  is_new_reading_ = from.is_new_reading_;
  clear_has_payload();
  switch (from.payload_case()) {
    case kStatus: {
      _internal_set_status(from._internal_status());
      break;
    }
    case kStepSimulation: {
      _internal_mutable_step_simulation()->::mw::internal::robotics::gazebotransport::StepSimulation::MergeFrom(from._internal_step_simulation());
      break;
    }
    case kResetSimulation: {
      _internal_mutable_reset_simulation()->::mw::internal::robotics::gazebotransport::ResetSimulation::MergeFrom(from._internal_reset_simulation());
      break;
    }
    case kImage: {
      _internal_mutable_image()->::mw::internal::robotics::gazebotransport::Image::MergeFrom(from._internal_image());
      break;
    }
    case kRequestImage: {
      _internal_mutable_request_image()->::mw::internal::robotics::gazebotransport::RequestImage::MergeFrom(from._internal_request_image());
      break;
    }
    case kRequestCosim: {
      _internal_mutable_request_cosim()->::mw::internal::robotics::gazebotransport::RequestCoSim::MergeFrom(from._internal_request_cosim());
      break;
    }
    case kStopCosim: {
      _internal_mutable_stop_cosim()->::mw::internal::robotics::gazebotransport::StopCoSim::MergeFrom(from._internal_stop_cosim());
      break;
    }
    case kGetGroundTruthWorldPose: {
      _internal_mutable_get_ground_truth_world_pose()->::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose::MergeFrom(from._internal_get_ground_truth_world_pose());
      break;
    }
    case kPose: {
      _internal_mutable_pose()->::mw::internal::robotics::gazebotransport::Pose::MergeFrom(from._internal_pose());
      break;
    }
    case kStopSimulation: {
      _internal_mutable_stop_simulation()->::mw::internal::robotics::gazebotransport::StopSimulation::MergeFrom(from._internal_stop_simulation());
      break;
    }
    case kLaserData: {
      _internal_mutable_laser_data()->::mw::internal::robotics::gazebotransport::LaserData::MergeFrom(from._internal_laser_data());
      break;
    }
    case kRequestLaser: {
      _internal_mutable_request_laser()->::mw::internal::robotics::gazebotransport::RequestLaser::MergeFrom(from._internal_request_laser());
      break;
    }
    case kImuData: {
      _internal_mutable_imu_data()->::mw::internal::robotics::gazebotransport::ImuData::MergeFrom(from._internal_imu_data());
      break;
    }
    case kRequestImu: {
      _internal_mutable_request_imu()->::mw::internal::robotics::gazebotransport::RequestImu::MergeFrom(from._internal_request_imu());
      break;
    }
    case kSubscribeImage: {
      _internal_mutable_subscribe_image()->::mw::internal::robotics::gazebotransport::SubscribeImage::MergeFrom(from._internal_subscribe_image());
      break;
    }
    case kSubscribeLaser: {
      _internal_mutable_subscribe_laser()->::mw::internal::robotics::gazebotransport::SubscribeLaser::MergeFrom(from._internal_subscribe_laser());
      break;
    }
    case kSubscribeImu: {
      _internal_mutable_subscribe_imu()->::mw::internal::robotics::gazebotransport::SubscribeImu::MergeFrom(from._internal_subscribe_imu());
      break;
    }
    case kApplyJointTorque: {
      _internal_mutable_apply_joint_torque()->::mw::internal::robotics::gazebotransport::ApplyJointTorque::MergeFrom(from._internal_apply_joint_torque());
      break;
    }
    case kGetPose: {
      _internal_mutable_get_pose()->::mw::internal::robotics::gazebotransport::GetPose::MergeFrom(from._internal_get_pose());
      break;
    }
    case kGetTopicList: {
      _internal_mutable_get_topic_list()->::mw::internal::robotics::gazebotransport::GetTopicList::MergeFrom(from._internal_get_topic_list());
      break;
    }
    case kTopicList: {
      _internal_mutable_topic_list()->::mw::internal::robotics::gazebotransport::TopicList::MergeFrom(from._internal_topic_list());
      break;
    }
    case kGetModelInfo: {
      _internal_mutable_get_model_info()->::mw::internal::robotics::gazebotransport::GetModelInfo::MergeFrom(from._internal_get_model_info());
      break;
    }
    case kModelInfo: {
      _internal_mutable_model_info()->::mw::internal::robotics::gazebotransport::ModelInfo::MergeFrom(from._internal_model_info());
      break;
    }
    case kApplyLinkWrench: {
      _internal_mutable_apply_link_wrench()->::mw::internal::robotics::gazebotransport::ApplyLinkWrench::MergeFrom(from._internal_apply_link_wrench());
      break;
    }
    case kMaxStepSize: {
      _internal_mutable_max_step_size()->::mw::internal::robotics::gazebotransport::MaxStepSize::MergeFrom(from._internal_max_step_size());
      break;
    }
    case kCustomMessageSupport: {
      _internal_mutable_custom_message_support()->::mw::internal::robotics::gazebotransport::CustomMessageSupport::MergeFrom(from._internal_custom_message_support());
      break;
    }
    case kInitCustomPublisher: {
      _internal_mutable_init_custom_publisher()->::mw::internal::robotics::gazebotransport::InitCustomPublisher::MergeFrom(from._internal_init_custom_publisher());
      break;
    }
    case kInitCustomSubscriber: {
      _internal_mutable_init_custom_subscriber()->::mw::internal::robotics::gazebotransport::InitCustomSubscriber::MergeFrom(from._internal_init_custom_subscriber());
      break;
    }
    case kRequestCustomMessageSupport: {
      _internal_mutable_request_custom_message_support()->::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport::MergeFrom(from._internal_request_custom_message_support());
      break;
    }
    case kSetJointPosition: {
      _internal_mutable_set_joint_position()->::mw::internal::robotics::gazebotransport::SetJointPosition::MergeFrom(from._internal_set_joint_position());
      break;
    }
    case kSetJointVelocity: {
      _internal_mutable_set_joint_velocity()->::mw::internal::robotics::gazebotransport::SetJointVelocity::MergeFrom(from._internal_set_joint_velocity());
      break;
    }
    case kGetJointState: {
      _internal_mutable_get_joint_state()->::mw::internal::robotics::gazebotransport::GetJointState::MergeFrom(from._internal_get_joint_state());
      break;
    }
    case kJointState: {
      _internal_mutable_joint_state()->::mw::internal::robotics::gazebotransport::JointState::MergeFrom(from._internal_joint_state());
      break;
    }
    case kSetLinkWorldPose: {
      _internal_mutable_set_link_world_pose()->::mw::internal::robotics::gazebotransport::SetLinkWorldPose::MergeFrom(from._internal_set_link_world_pose());
      break;
    }
    case kSetLinkLinearVelocity: {
      _internal_mutable_set_link_linear_velocity()->::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity::MergeFrom(from._internal_set_link_linear_velocity());
      break;
    }
    case kSetLinkAngularVelocity: {
      _internal_mutable_set_link_angular_velocity()->::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity::MergeFrom(from._internal_set_link_angular_velocity());
      break;
    }
    case kGetLinkState: {
      _internal_mutable_get_link_state()->::mw::internal::robotics::gazebotransport::GetLinkState::MergeFrom(from._internal_get_link_state());
      break;
    }
    case kLinkState: {
      _internal_mutable_link_state()->::mw::internal::robotics::gazebotransport::LinkState::MergeFrom(from._internal_link_state());
      break;
    }
    case kGazeboModel: {
      _internal_mutable_gazebo_model()->::mw::internal::robotics::gazebotransport::Gazebomodel::MergeFrom(from._internal_gazebo_model());
      break;
    }
    case kGetGazeboModelParam: {
      _internal_mutable_get_gazebo_model_param()->::mw::internal::robotics::gazebotransport::GetGazeboModelParam::MergeFrom(from._internal_get_gazebo_model_param());
      break;
    }
    case kGazeboModelSdf: {
      _internal_mutable_gazebo_model_sdf()->::mw::internal::robotics::gazebotransport::GazeboModelSDF::MergeFrom(from._internal_gazebo_model_sdf());
      break;
    }
    case kGetGazeboModelSdf: {
      _internal_mutable_get_gazebo_model_sdf()->::mw::internal::robotics::gazebotransport::GetGazeboModelSDF::MergeFrom(from._internal_get_gazebo_model_sdf());
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.Packet)
}

void Packet::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Packet_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  error_message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&header_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_new_reading_) -
      reinterpret_cast<char*>(&header_)) + sizeof(is_new_reading_));
  clear_has_payload();
}

Packet::~Packet() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.Packet)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Packet::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  error_message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete header_;
  if (has_payload()) {
    clear_payload();
  }
}

void Packet::ArenaDtor(void* object) {
  Packet* _this = reinterpret_cast< Packet* >(object);
  (void)_this;
}
void Packet::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Packet::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Packet& Packet::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Packet_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void Packet::clear_payload() {
// @@protoc_insertion_point(one_of_clear_start:mw.internal.robotics.gazebotransport.Packet)
  switch (payload_case()) {
    case kStatus: {
      // No need to clear
      break;
    }
    case kStepSimulation: {
      if (GetArena() == nullptr) {
        delete payload_.step_simulation_;
      }
      break;
    }
    case kResetSimulation: {
      if (GetArena() == nullptr) {
        delete payload_.reset_simulation_;
      }
      break;
    }
    case kImage: {
      if (GetArena() == nullptr) {
        delete payload_.image_;
      }
      break;
    }
    case kRequestImage: {
      if (GetArena() == nullptr) {
        delete payload_.request_image_;
      }
      break;
    }
    case kRequestCosim: {
      if (GetArena() == nullptr) {
        delete payload_.request_cosim_;
      }
      break;
    }
    case kStopCosim: {
      if (GetArena() == nullptr) {
        delete payload_.stop_cosim_;
      }
      break;
    }
    case kGetGroundTruthWorldPose: {
      if (GetArena() == nullptr) {
        delete payload_.get_ground_truth_world_pose_;
      }
      break;
    }
    case kPose: {
      if (GetArena() == nullptr) {
        delete payload_.pose_;
      }
      break;
    }
    case kStopSimulation: {
      if (GetArena() == nullptr) {
        delete payload_.stop_simulation_;
      }
      break;
    }
    case kLaserData: {
      if (GetArena() == nullptr) {
        delete payload_.laser_data_;
      }
      break;
    }
    case kRequestLaser: {
      if (GetArena() == nullptr) {
        delete payload_.request_laser_;
      }
      break;
    }
    case kImuData: {
      if (GetArena() == nullptr) {
        delete payload_.imu_data_;
      }
      break;
    }
    case kRequestImu: {
      if (GetArena() == nullptr) {
        delete payload_.request_imu_;
      }
      break;
    }
    case kSubscribeImage: {
      if (GetArena() == nullptr) {
        delete payload_.subscribe_image_;
      }
      break;
    }
    case kSubscribeLaser: {
      if (GetArena() == nullptr) {
        delete payload_.subscribe_laser_;
      }
      break;
    }
    case kSubscribeImu: {
      if (GetArena() == nullptr) {
        delete payload_.subscribe_imu_;
      }
      break;
    }
    case kApplyJointTorque: {
      if (GetArena() == nullptr) {
        delete payload_.apply_joint_torque_;
      }
      break;
    }
    case kGetPose: {
      if (GetArena() == nullptr) {
        delete payload_.get_pose_;
      }
      break;
    }
    case kGetTopicList: {
      if (GetArena() == nullptr) {
        delete payload_.get_topic_list_;
      }
      break;
    }
    case kTopicList: {
      if (GetArena() == nullptr) {
        delete payload_.topic_list_;
      }
      break;
    }
    case kGetModelInfo: {
      if (GetArena() == nullptr) {
        delete payload_.get_model_info_;
      }
      break;
    }
    case kModelInfo: {
      if (GetArena() == nullptr) {
        delete payload_.model_info_;
      }
      break;
    }
    case kApplyLinkWrench: {
      if (GetArena() == nullptr) {
        delete payload_.apply_link_wrench_;
      }
      break;
    }
    case kMaxStepSize: {
      if (GetArena() == nullptr) {
        delete payload_.max_step_size_;
      }
      break;
    }
    case kCustomMessageSupport: {
      if (GetArena() == nullptr) {
        delete payload_.custom_message_support_;
      }
      break;
    }
    case kInitCustomPublisher: {
      if (GetArena() == nullptr) {
        delete payload_.init_custom_publisher_;
      }
      break;
    }
    case kInitCustomSubscriber: {
      if (GetArena() == nullptr) {
        delete payload_.init_custom_subscriber_;
      }
      break;
    }
    case kRequestCustomMessageSupport: {
      if (GetArena() == nullptr) {
        delete payload_.request_custom_message_support_;
      }
      break;
    }
    case kSetJointPosition: {
      if (GetArena() == nullptr) {
        delete payload_.set_joint_position_;
      }
      break;
    }
    case kSetJointVelocity: {
      if (GetArena() == nullptr) {
        delete payload_.set_joint_velocity_;
      }
      break;
    }
    case kGetJointState: {
      if (GetArena() == nullptr) {
        delete payload_.get_joint_state_;
      }
      break;
    }
    case kJointState: {
      if (GetArena() == nullptr) {
        delete payload_.joint_state_;
      }
      break;
    }
    case kSetLinkWorldPose: {
      if (GetArena() == nullptr) {
        delete payload_.set_link_world_pose_;
      }
      break;
    }
    case kSetLinkLinearVelocity: {
      if (GetArena() == nullptr) {
        delete payload_.set_link_linear_velocity_;
      }
      break;
    }
    case kSetLinkAngularVelocity: {
      if (GetArena() == nullptr) {
        delete payload_.set_link_angular_velocity_;
      }
      break;
    }
    case kGetLinkState: {
      if (GetArena() == nullptr) {
        delete payload_.get_link_state_;
      }
      break;
    }
    case kLinkState: {
      if (GetArena() == nullptr) {
        delete payload_.link_state_;
      }
      break;
    }
    case kGazeboModel: {
      if (GetArena() == nullptr) {
        delete payload_.gazebo_model_;
      }
      break;
    }
    case kGetGazeboModelParam: {
      if (GetArena() == nullptr) {
        delete payload_.get_gazebo_model_param_;
      }
      break;
    }
    case kGazeboModelSdf: {
      if (GetArena() == nullptr) {
        delete payload_.gazebo_model_sdf_;
      }
      break;
    }
    case kGetGazeboModelSdf: {
      if (GetArena() == nullptr) {
        delete payload_.get_gazebo_model_sdf_;
      }
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}


void Packet::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.Packet)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      error_message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(header_ != nullptr);
      header_->Clear();
    }
  }
  is_new_reading_ = false;
  clear_payload();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Packet::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .mw.internal.robotics.gazebotransport.PacketHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.Packet.CoSimError status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mw::internal::robotics::gazebotransport::Packet_CoSimError_IsValid(val))) {
            _internal_set_status(static_cast<::mw::internal::robotics::gazebotransport::Packet_CoSimError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.StepSimulation step_simulation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_step_simulation(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.ResetSimulation reset_simulation = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_reset_simulation(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.Image image = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_image(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.RequestImage request_image = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_image(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.RequestCoSim request_cosim = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_cosim(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.StopCoSim stop_cosim = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_stop_cosim(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose get_ground_truth_world_pose = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_ground_truth_world_pose(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.Pose pose = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_pose(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.StopSimulation stop_simulation = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_stop_simulation(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.LaserData laser_data = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_laser_data(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.RequestLaser request_laser = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_laser(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.ImuData imu_data = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_imu_data(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.RequestImu request_imu = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_imu(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.SubscribeImage subscribe_image = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_subscribe_image(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.SubscribeLaser subscribe_laser = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_subscribe_laser(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.SubscribeImu subscribe_imu = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_subscribe_imu(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.ApplyJointTorque apply_joint_torque = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_apply_joint_torque(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.GetPose get_pose = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_pose(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.GetTopicList get_topic_list = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_topic_list(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.TopicList topic_list = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_topic_list(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.GetModelInfo get_model_info = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_model_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.ModelInfo model_info = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_model_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.ApplyLinkWrench apply_link_wrench = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_apply_link_wrench(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.MaxStepSize max_step_size = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_max_step_size(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.CustomMessageSupport custom_message_support = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_custom_message_support(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.InitCustomPublisher init_custom_publisher = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_init_custom_publisher(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.InitCustomSubscriber init_custom_subscriber = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_init_custom_subscriber(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.RequestCustomMessageSupport request_custom_message_support = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_custom_message_support(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.SetJointPosition set_joint_position = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_set_joint_position(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.SetJointVelocity set_joint_velocity = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_set_joint_velocity(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.GetJointState get_joint_state = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_joint_state(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.JointState joint_state = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_joint_state(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.SetLinkWorldPose set_link_world_pose = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_set_link_world_pose(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.SetLinkLinearVelocity set_link_linear_velocity = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_set_link_linear_velocity(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.SetLinkAngularVelocity set_link_angular_velocity = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_set_link_angular_velocity(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.GetLinkState get_link_state = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_link_state(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.LinkState link_state = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_link_state(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.Gazebomodel gazebo_model = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_gazebo_model(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.GetGazeboModelParam get_gazebo_model_param = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_gazebo_model_param(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.GazeboModelSDF gazebo_model_sdf = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_gazebo_model_sdf(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .mw.internal.robotics.gazebotransport.GetGazeboModelSDF get_gazebo_model_sdf = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_gazebo_model_sdf(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string error_message = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          auto str = _internal_mutable_error_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.Packet.error_message");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_new_reading = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_is_new_reading(&has_bits);
          is_new_reading_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Packet::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.Packet)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .mw.internal.robotics.gazebotransport.PacketHeader header = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::header(this), target, stream);
  }

  switch (payload_case()) {
    case kStatus: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
        2, this->_internal_status(), target);
      break;
    }
    case kStepSimulation: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          3, _Internal::step_simulation(this), target, stream);
      break;
    }
    case kResetSimulation: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          4, _Internal::reset_simulation(this), target, stream);
      break;
    }
    case kImage: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          5, _Internal::image(this), target, stream);
      break;
    }
    case kRequestImage: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          6, _Internal::request_image(this), target, stream);
      break;
    }
    case kRequestCosim: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          7, _Internal::request_cosim(this), target, stream);
      break;
    }
    case kStopCosim: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          8, _Internal::stop_cosim(this), target, stream);
      break;
    }
    case kGetGroundTruthWorldPose: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          9, _Internal::get_ground_truth_world_pose(this), target, stream);
      break;
    }
    case kPose: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          10, _Internal::pose(this), target, stream);
      break;
    }
    case kStopSimulation: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          11, _Internal::stop_simulation(this), target, stream);
      break;
    }
    case kLaserData: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          12, _Internal::laser_data(this), target, stream);
      break;
    }
    case kRequestLaser: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          13, _Internal::request_laser(this), target, stream);
      break;
    }
    case kImuData: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          14, _Internal::imu_data(this), target, stream);
      break;
    }
    case kRequestImu: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          15, _Internal::request_imu(this), target, stream);
      break;
    }
    case kSubscribeImage: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          16, _Internal::subscribe_image(this), target, stream);
      break;
    }
    case kSubscribeLaser: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          17, _Internal::subscribe_laser(this), target, stream);
      break;
    }
    case kSubscribeImu: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          18, _Internal::subscribe_imu(this), target, stream);
      break;
    }
    case kApplyJointTorque: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          19, _Internal::apply_joint_torque(this), target, stream);
      break;
    }
    case kGetPose: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          20, _Internal::get_pose(this), target, stream);
      break;
    }
    case kGetTopicList: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          21, _Internal::get_topic_list(this), target, stream);
      break;
    }
    case kTopicList: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          22, _Internal::topic_list(this), target, stream);
      break;
    }
    case kGetModelInfo: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          23, _Internal::get_model_info(this), target, stream);
      break;
    }
    case kModelInfo: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          24, _Internal::model_info(this), target, stream);
      break;
    }
    case kApplyLinkWrench: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          25, _Internal::apply_link_wrench(this), target, stream);
      break;
    }
    case kMaxStepSize: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          26, _Internal::max_step_size(this), target, stream);
      break;
    }
    case kCustomMessageSupport: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          27, _Internal::custom_message_support(this), target, stream);
      break;
    }
    case kInitCustomPublisher: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          28, _Internal::init_custom_publisher(this), target, stream);
      break;
    }
    case kInitCustomSubscriber: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          29, _Internal::init_custom_subscriber(this), target, stream);
      break;
    }
    case kRequestCustomMessageSupport: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          30, _Internal::request_custom_message_support(this), target, stream);
      break;
    }
    case kSetJointPosition: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          31, _Internal::set_joint_position(this), target, stream);
      break;
    }
    case kSetJointVelocity: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          32, _Internal::set_joint_velocity(this), target, stream);
      break;
    }
    case kGetJointState: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          33, _Internal::get_joint_state(this), target, stream);
      break;
    }
    case kJointState: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          34, _Internal::joint_state(this), target, stream);
      break;
    }
    case kSetLinkWorldPose: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          35, _Internal::set_link_world_pose(this), target, stream);
      break;
    }
    case kSetLinkLinearVelocity: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          36, _Internal::set_link_linear_velocity(this), target, stream);
      break;
    }
    case kSetLinkAngularVelocity: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          37, _Internal::set_link_angular_velocity(this), target, stream);
      break;
    }
    case kGetLinkState: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          38, _Internal::get_link_state(this), target, stream);
      break;
    }
    case kLinkState: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          39, _Internal::link_state(this), target, stream);
      break;
    }
    case kGazeboModel: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          40, _Internal::gazebo_model(this), target, stream);
      break;
    }
    case kGetGazeboModelParam: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          41, _Internal::get_gazebo_model_param(this), target, stream);
      break;
    }
    case kGazeboModelSdf: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          42, _Internal::gazebo_model_sdf(this), target, stream);
      break;
    }
    case kGetGazeboModelSdf: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          43, _Internal::get_gazebo_model_sdf(this), target, stream);
      break;
    }
    default: ;
  }
  // optional string error_message = 44;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_error_message().data(), static_cast<int>(this->_internal_error_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.Packet.error_message");
    target = stream->WriteStringMaybeAliased(
        44, this->_internal_error_message(), target);
  }

  // optional bool is_new_reading = 45;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(45, this->_internal_is_new_reading(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.Packet)
  return target;
}

size_t Packet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.Packet)
  size_t total_size = 0;

  // required .mw.internal.robotics.gazebotransport.PacketHeader header = 1;
  if (_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *header_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string error_message = 44;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_error_message());
  }

  // optional bool is_new_reading = 45;
  if (cached_has_bits & 0x00000004u) {
    total_size += 2 + 1;
  }

  switch (payload_case()) {
    // .mw.internal.robotics.gazebotransport.Packet.CoSimError status = 2;
    case kStatus: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_status());
      break;
    }
    // .mw.internal.robotics.gazebotransport.StepSimulation step_simulation = 3;
    case kStepSimulation: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.step_simulation_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.ResetSimulation reset_simulation = 4;
    case kResetSimulation: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.reset_simulation_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.Image image = 5;
    case kImage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.image_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.RequestImage request_image = 6;
    case kRequestImage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.request_image_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.RequestCoSim request_cosim = 7;
    case kRequestCosim: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.request_cosim_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.StopCoSim stop_cosim = 8;
    case kStopCosim: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.stop_cosim_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose get_ground_truth_world_pose = 9;
    case kGetGroundTruthWorldPose: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.get_ground_truth_world_pose_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.Pose pose = 10;
    case kPose: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.pose_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.StopSimulation stop_simulation = 11;
    case kStopSimulation: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.stop_simulation_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.LaserData laser_data = 12;
    case kLaserData: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.laser_data_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.RequestLaser request_laser = 13;
    case kRequestLaser: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.request_laser_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.ImuData imu_data = 14;
    case kImuData: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.imu_data_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.RequestImu request_imu = 15;
    case kRequestImu: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.request_imu_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.SubscribeImage subscribe_image = 16;
    case kSubscribeImage: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.subscribe_image_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.SubscribeLaser subscribe_laser = 17;
    case kSubscribeLaser: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.subscribe_laser_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.SubscribeImu subscribe_imu = 18;
    case kSubscribeImu: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.subscribe_imu_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.ApplyJointTorque apply_joint_torque = 19;
    case kApplyJointTorque: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.apply_joint_torque_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.GetPose get_pose = 20;
    case kGetPose: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.get_pose_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.GetTopicList get_topic_list = 21;
    case kGetTopicList: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.get_topic_list_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.TopicList topic_list = 22;
    case kTopicList: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.topic_list_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.GetModelInfo get_model_info = 23;
    case kGetModelInfo: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.get_model_info_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.ModelInfo model_info = 24;
    case kModelInfo: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.model_info_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.ApplyLinkWrench apply_link_wrench = 25;
    case kApplyLinkWrench: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.apply_link_wrench_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.MaxStepSize max_step_size = 26;
    case kMaxStepSize: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.max_step_size_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.CustomMessageSupport custom_message_support = 27;
    case kCustomMessageSupport: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.custom_message_support_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.InitCustomPublisher init_custom_publisher = 28;
    case kInitCustomPublisher: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.init_custom_publisher_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.InitCustomSubscriber init_custom_subscriber = 29;
    case kInitCustomSubscriber: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.init_custom_subscriber_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.RequestCustomMessageSupport request_custom_message_support = 30;
    case kRequestCustomMessageSupport: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.request_custom_message_support_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.SetJointPosition set_joint_position = 31;
    case kSetJointPosition: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.set_joint_position_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.SetJointVelocity set_joint_velocity = 32;
    case kSetJointVelocity: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.set_joint_velocity_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.GetJointState get_joint_state = 33;
    case kGetJointState: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.get_joint_state_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.JointState joint_state = 34;
    case kJointState: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.joint_state_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.SetLinkWorldPose set_link_world_pose = 35;
    case kSetLinkWorldPose: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.set_link_world_pose_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.SetLinkLinearVelocity set_link_linear_velocity = 36;
    case kSetLinkLinearVelocity: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.set_link_linear_velocity_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.SetLinkAngularVelocity set_link_angular_velocity = 37;
    case kSetLinkAngularVelocity: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.set_link_angular_velocity_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.GetLinkState get_link_state = 38;
    case kGetLinkState: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.get_link_state_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.LinkState link_state = 39;
    case kLinkState: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.link_state_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.Gazebomodel gazebo_model = 40;
    case kGazeboModel: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.gazebo_model_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.GetGazeboModelParam get_gazebo_model_param = 41;
    case kGetGazeboModelParam: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.get_gazebo_model_param_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.GazeboModelSDF gazebo_model_sdf = 42;
    case kGazeboModelSdf: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.gazebo_model_sdf_);
      break;
    }
    // .mw.internal.robotics.gazebotransport.GetGazeboModelSDF get_gazebo_model_sdf = 43;
    case kGetGazeboModelSdf: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_.get_gazebo_model_sdf_);
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Packet::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.Packet)
  GOOGLE_DCHECK_NE(&from, this);
  const Packet* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Packet>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.Packet)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.Packet)
    MergeFrom(*source);
  }
}

void Packet::MergeFrom(const Packet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.Packet)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_error_message(from._internal_error_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_header()->::mw::internal::robotics::gazebotransport::PacketHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000004u) {
      is_new_reading_ = from.is_new_reading_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.payload_case()) {
    case kStatus: {
      _internal_set_status(from._internal_status());
      break;
    }
    case kStepSimulation: {
      _internal_mutable_step_simulation()->::mw::internal::robotics::gazebotransport::StepSimulation::MergeFrom(from._internal_step_simulation());
      break;
    }
    case kResetSimulation: {
      _internal_mutable_reset_simulation()->::mw::internal::robotics::gazebotransport::ResetSimulation::MergeFrom(from._internal_reset_simulation());
      break;
    }
    case kImage: {
      _internal_mutable_image()->::mw::internal::robotics::gazebotransport::Image::MergeFrom(from._internal_image());
      break;
    }
    case kRequestImage: {
      _internal_mutable_request_image()->::mw::internal::robotics::gazebotransport::RequestImage::MergeFrom(from._internal_request_image());
      break;
    }
    case kRequestCosim: {
      _internal_mutable_request_cosim()->::mw::internal::robotics::gazebotransport::RequestCoSim::MergeFrom(from._internal_request_cosim());
      break;
    }
    case kStopCosim: {
      _internal_mutable_stop_cosim()->::mw::internal::robotics::gazebotransport::StopCoSim::MergeFrom(from._internal_stop_cosim());
      break;
    }
    case kGetGroundTruthWorldPose: {
      _internal_mutable_get_ground_truth_world_pose()->::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose::MergeFrom(from._internal_get_ground_truth_world_pose());
      break;
    }
    case kPose: {
      _internal_mutable_pose()->::mw::internal::robotics::gazebotransport::Pose::MergeFrom(from._internal_pose());
      break;
    }
    case kStopSimulation: {
      _internal_mutable_stop_simulation()->::mw::internal::robotics::gazebotransport::StopSimulation::MergeFrom(from._internal_stop_simulation());
      break;
    }
    case kLaserData: {
      _internal_mutable_laser_data()->::mw::internal::robotics::gazebotransport::LaserData::MergeFrom(from._internal_laser_data());
      break;
    }
    case kRequestLaser: {
      _internal_mutable_request_laser()->::mw::internal::robotics::gazebotransport::RequestLaser::MergeFrom(from._internal_request_laser());
      break;
    }
    case kImuData: {
      _internal_mutable_imu_data()->::mw::internal::robotics::gazebotransport::ImuData::MergeFrom(from._internal_imu_data());
      break;
    }
    case kRequestImu: {
      _internal_mutable_request_imu()->::mw::internal::robotics::gazebotransport::RequestImu::MergeFrom(from._internal_request_imu());
      break;
    }
    case kSubscribeImage: {
      _internal_mutable_subscribe_image()->::mw::internal::robotics::gazebotransport::SubscribeImage::MergeFrom(from._internal_subscribe_image());
      break;
    }
    case kSubscribeLaser: {
      _internal_mutable_subscribe_laser()->::mw::internal::robotics::gazebotransport::SubscribeLaser::MergeFrom(from._internal_subscribe_laser());
      break;
    }
    case kSubscribeImu: {
      _internal_mutable_subscribe_imu()->::mw::internal::robotics::gazebotransport::SubscribeImu::MergeFrom(from._internal_subscribe_imu());
      break;
    }
    case kApplyJointTorque: {
      _internal_mutable_apply_joint_torque()->::mw::internal::robotics::gazebotransport::ApplyJointTorque::MergeFrom(from._internal_apply_joint_torque());
      break;
    }
    case kGetPose: {
      _internal_mutable_get_pose()->::mw::internal::robotics::gazebotransport::GetPose::MergeFrom(from._internal_get_pose());
      break;
    }
    case kGetTopicList: {
      _internal_mutable_get_topic_list()->::mw::internal::robotics::gazebotransport::GetTopicList::MergeFrom(from._internal_get_topic_list());
      break;
    }
    case kTopicList: {
      _internal_mutable_topic_list()->::mw::internal::robotics::gazebotransport::TopicList::MergeFrom(from._internal_topic_list());
      break;
    }
    case kGetModelInfo: {
      _internal_mutable_get_model_info()->::mw::internal::robotics::gazebotransport::GetModelInfo::MergeFrom(from._internal_get_model_info());
      break;
    }
    case kModelInfo: {
      _internal_mutable_model_info()->::mw::internal::robotics::gazebotransport::ModelInfo::MergeFrom(from._internal_model_info());
      break;
    }
    case kApplyLinkWrench: {
      _internal_mutable_apply_link_wrench()->::mw::internal::robotics::gazebotransport::ApplyLinkWrench::MergeFrom(from._internal_apply_link_wrench());
      break;
    }
    case kMaxStepSize: {
      _internal_mutable_max_step_size()->::mw::internal::robotics::gazebotransport::MaxStepSize::MergeFrom(from._internal_max_step_size());
      break;
    }
    case kCustomMessageSupport: {
      _internal_mutable_custom_message_support()->::mw::internal::robotics::gazebotransport::CustomMessageSupport::MergeFrom(from._internal_custom_message_support());
      break;
    }
    case kInitCustomPublisher: {
      _internal_mutable_init_custom_publisher()->::mw::internal::robotics::gazebotransport::InitCustomPublisher::MergeFrom(from._internal_init_custom_publisher());
      break;
    }
    case kInitCustomSubscriber: {
      _internal_mutable_init_custom_subscriber()->::mw::internal::robotics::gazebotransport::InitCustomSubscriber::MergeFrom(from._internal_init_custom_subscriber());
      break;
    }
    case kRequestCustomMessageSupport: {
      _internal_mutable_request_custom_message_support()->::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport::MergeFrom(from._internal_request_custom_message_support());
      break;
    }
    case kSetJointPosition: {
      _internal_mutable_set_joint_position()->::mw::internal::robotics::gazebotransport::SetJointPosition::MergeFrom(from._internal_set_joint_position());
      break;
    }
    case kSetJointVelocity: {
      _internal_mutable_set_joint_velocity()->::mw::internal::robotics::gazebotransport::SetJointVelocity::MergeFrom(from._internal_set_joint_velocity());
      break;
    }
    case kGetJointState: {
      _internal_mutable_get_joint_state()->::mw::internal::robotics::gazebotransport::GetJointState::MergeFrom(from._internal_get_joint_state());
      break;
    }
    case kJointState: {
      _internal_mutable_joint_state()->::mw::internal::robotics::gazebotransport::JointState::MergeFrom(from._internal_joint_state());
      break;
    }
    case kSetLinkWorldPose: {
      _internal_mutable_set_link_world_pose()->::mw::internal::robotics::gazebotransport::SetLinkWorldPose::MergeFrom(from._internal_set_link_world_pose());
      break;
    }
    case kSetLinkLinearVelocity: {
      _internal_mutable_set_link_linear_velocity()->::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity::MergeFrom(from._internal_set_link_linear_velocity());
      break;
    }
    case kSetLinkAngularVelocity: {
      _internal_mutable_set_link_angular_velocity()->::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity::MergeFrom(from._internal_set_link_angular_velocity());
      break;
    }
    case kGetLinkState: {
      _internal_mutable_get_link_state()->::mw::internal::robotics::gazebotransport::GetLinkState::MergeFrom(from._internal_get_link_state());
      break;
    }
    case kLinkState: {
      _internal_mutable_link_state()->::mw::internal::robotics::gazebotransport::LinkState::MergeFrom(from._internal_link_state());
      break;
    }
    case kGazeboModel: {
      _internal_mutable_gazebo_model()->::mw::internal::robotics::gazebotransport::Gazebomodel::MergeFrom(from._internal_gazebo_model());
      break;
    }
    case kGetGazeboModelParam: {
      _internal_mutable_get_gazebo_model_param()->::mw::internal::robotics::gazebotransport::GetGazeboModelParam::MergeFrom(from._internal_get_gazebo_model_param());
      break;
    }
    case kGazeboModelSdf: {
      _internal_mutable_gazebo_model_sdf()->::mw::internal::robotics::gazebotransport::GazeboModelSDF::MergeFrom(from._internal_gazebo_model_sdf());
      break;
    }
    case kGetGazeboModelSdf: {
      _internal_mutable_get_gazebo_model_sdf()->::mw::internal::robotics::gazebotransport::GetGazeboModelSDF::MergeFrom(from._internal_get_gazebo_model_sdf());
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
}

void Packet::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.Packet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Packet::CopyFrom(const Packet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.Packet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Packet::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_header()) {
    if (!header_->IsInitialized()) return false;
  }
  switch (payload_case()) {
    case kStatus: {
      break;
    }
    case kStepSimulation: {
      if (has_step_simulation()) {
        if (!this->step_simulation().IsInitialized()) return false;
      }
      break;
    }
    case kResetSimulation: {
      if (has_reset_simulation()) {
        if (!this->reset_simulation().IsInitialized()) return false;
      }
      break;
    }
    case kImage: {
      break;
    }
    case kRequestImage: {
      if (has_request_image()) {
        if (!this->request_image().IsInitialized()) return false;
      }
      break;
    }
    case kRequestCosim: {
      if (has_request_cosim()) {
        if (!this->request_cosim().IsInitialized()) return false;
      }
      break;
    }
    case kStopCosim: {
      if (has_stop_cosim()) {
        if (!this->stop_cosim().IsInitialized()) return false;
      }
      break;
    }
    case kGetGroundTruthWorldPose: {
      if (has_get_ground_truth_world_pose()) {
        if (!this->get_ground_truth_world_pose().IsInitialized()) return false;
      }
      break;
    }
    case kPose: {
      if (has_pose()) {
        if (!this->pose().IsInitialized()) return false;
      }
      break;
    }
    case kStopSimulation: {
      if (has_stop_simulation()) {
        if (!this->stop_simulation().IsInitialized()) return false;
      }
      break;
    }
    case kLaserData: {
      break;
    }
    case kRequestLaser: {
      if (has_request_laser()) {
        if (!this->request_laser().IsInitialized()) return false;
      }
      break;
    }
    case kImuData: {
      if (has_imu_data()) {
        if (!this->imu_data().IsInitialized()) return false;
      }
      break;
    }
    case kRequestImu: {
      if (has_request_imu()) {
        if (!this->request_imu().IsInitialized()) return false;
      }
      break;
    }
    case kSubscribeImage: {
      if (has_subscribe_image()) {
        if (!this->subscribe_image().IsInitialized()) return false;
      }
      break;
    }
    case kSubscribeLaser: {
      if (has_subscribe_laser()) {
        if (!this->subscribe_laser().IsInitialized()) return false;
      }
      break;
    }
    case kSubscribeImu: {
      if (has_subscribe_imu()) {
        if (!this->subscribe_imu().IsInitialized()) return false;
      }
      break;
    }
    case kApplyJointTorque: {
      if (has_apply_joint_torque()) {
        if (!this->apply_joint_torque().IsInitialized()) return false;
      }
      break;
    }
    case kGetPose: {
      if (has_get_pose()) {
        if (!this->get_pose().IsInitialized()) return false;
      }
      break;
    }
    case kGetTopicList: {
      if (has_get_topic_list()) {
        if (!this->get_topic_list().IsInitialized()) return false;
      }
      break;
    }
    case kTopicList: {
      if (has_topic_list()) {
        if (!this->topic_list().IsInitialized()) return false;
      }
      break;
    }
    case kGetModelInfo: {
      if (has_get_model_info()) {
        if (!this->get_model_info().IsInitialized()) return false;
      }
      break;
    }
    case kModelInfo: {
      if (has_model_info()) {
        if (!this->model_info().IsInitialized()) return false;
      }
      break;
    }
    case kApplyLinkWrench: {
      if (has_apply_link_wrench()) {
        if (!this->apply_link_wrench().IsInitialized()) return false;
      }
      break;
    }
    case kMaxStepSize: {
      if (has_max_step_size()) {
        if (!this->max_step_size().IsInitialized()) return false;
      }
      break;
    }
    case kCustomMessageSupport: {
      if (has_custom_message_support()) {
        if (!this->custom_message_support().IsInitialized()) return false;
      }
      break;
    }
    case kInitCustomPublisher: {
      if (has_init_custom_publisher()) {
        if (!this->init_custom_publisher().IsInitialized()) return false;
      }
      break;
    }
    case kInitCustomSubscriber: {
      if (has_init_custom_subscriber()) {
        if (!this->init_custom_subscriber().IsInitialized()) return false;
      }
      break;
    }
    case kRequestCustomMessageSupport: {
      if (has_request_custom_message_support()) {
        if (!this->request_custom_message_support().IsInitialized()) return false;
      }
      break;
    }
    case kSetJointPosition: {
      if (has_set_joint_position()) {
        if (!this->set_joint_position().IsInitialized()) return false;
      }
      break;
    }
    case kSetJointVelocity: {
      if (has_set_joint_velocity()) {
        if (!this->set_joint_velocity().IsInitialized()) return false;
      }
      break;
    }
    case kGetJointState: {
      if (has_get_joint_state()) {
        if (!this->get_joint_state().IsInitialized()) return false;
      }
      break;
    }
    case kJointState: {
      if (has_joint_state()) {
        if (!this->joint_state().IsInitialized()) return false;
      }
      break;
    }
    case kSetLinkWorldPose: {
      if (has_set_link_world_pose()) {
        if (!this->set_link_world_pose().IsInitialized()) return false;
      }
      break;
    }
    case kSetLinkLinearVelocity: {
      if (has_set_link_linear_velocity()) {
        if (!this->set_link_linear_velocity().IsInitialized()) return false;
      }
      break;
    }
    case kSetLinkAngularVelocity: {
      if (has_set_link_angular_velocity()) {
        if (!this->set_link_angular_velocity().IsInitialized()) return false;
      }
      break;
    }
    case kGetLinkState: {
      if (has_get_link_state()) {
        if (!this->get_link_state().IsInitialized()) return false;
      }
      break;
    }
    case kLinkState: {
      if (has_link_state()) {
        if (!this->link_state().IsInitialized()) return false;
      }
      break;
    }
    case kGazeboModel: {
      if (has_gazebo_model()) {
        if (!this->gazebo_model().IsInitialized()) return false;
      }
      break;
    }
    case kGetGazeboModelParam: {
      if (has_get_gazebo_model_param()) {
        if (!this->get_gazebo_model_param().IsInitialized()) return false;
      }
      break;
    }
    case kGazeboModelSdf: {
      if (has_gazebo_model_sdf()) {
        if (!this->gazebo_model_sdf().IsInitialized()) return false;
      }
      break;
    }
    case kGetGazeboModelSdf: {
      if (has_get_gazebo_model_sdf()) {
        if (!this->get_gazebo_model_sdf().IsInitialized()) return false;
      }
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  return true;
}

void Packet::InternalSwap(Packet* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  error_message_.Swap(&other->error_message_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Packet, is_new_reading_)
      + sizeof(Packet::is_new_reading_)
      - PROTOBUF_FIELD_OFFSET(Packet, header_)>(
          reinterpret_cast<char*>(&header_),
          reinterpret_cast<char*>(&other->header_));
  swap(payload_, other->payload_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Packet::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void StepSimulation::InitAsDefaultInstance() {
}
class StepSimulation::_Internal {
 public:
  using HasBits = decltype(std::declval<StepSimulation>()._has_bits_);
  static void set_has_num_steps(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

StepSimulation::StepSimulation(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.StepSimulation)
}
StepSimulation::StepSimulation(const StepSimulation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  num_steps_ = from.num_steps_;
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.StepSimulation)
}

void StepSimulation::SharedCtor() {
  num_steps_ = 0u;
}

StepSimulation::~StepSimulation() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.StepSimulation)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void StepSimulation::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void StepSimulation::ArenaDtor(void* object) {
  StepSimulation* _this = reinterpret_cast< StepSimulation* >(object);
  (void)_this;
}
void StepSimulation::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StepSimulation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StepSimulation& StepSimulation::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StepSimulation_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void StepSimulation::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.StepSimulation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  num_steps_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StepSimulation::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 num_steps = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_num_steps(&has_bits);
          num_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StepSimulation::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.StepSimulation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 num_steps = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_num_steps(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.StepSimulation)
  return target;
}

size_t StepSimulation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.StepSimulation)
  size_t total_size = 0;

  // required uint32 num_steps = 1;
  if (_internal_has_num_steps()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_num_steps());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StepSimulation::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.StepSimulation)
  GOOGLE_DCHECK_NE(&from, this);
  const StepSimulation* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<StepSimulation>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.StepSimulation)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.StepSimulation)
    MergeFrom(*source);
  }
}

void StepSimulation::MergeFrom(const StepSimulation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.StepSimulation)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_num_steps()) {
    _internal_set_num_steps(from._internal_num_steps());
  }
}

void StepSimulation::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.StepSimulation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StepSimulation::CopyFrom(const StepSimulation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.StepSimulation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StepSimulation::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void StepSimulation::InternalSwap(StepSimulation* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(num_steps_, other->num_steps_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StepSimulation::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ResetSimulation::InitAsDefaultInstance() {
}
class ResetSimulation::_Internal {
 public:
  using HasBits = decltype(std::declval<ResetSimulation>()._has_bits_);
  static void set_has_behavior(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

ResetSimulation::ResetSimulation(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.ResetSimulation)
}
ResetSimulation::ResetSimulation(const ResetSimulation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  behavior_ = from.behavior_;
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ResetSimulation)
}

void ResetSimulation::SharedCtor() {
  behavior_ = 0;
}

ResetSimulation::~ResetSimulation() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ResetSimulation)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ResetSimulation::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void ResetSimulation::ArenaDtor(void* object) {
  ResetSimulation* _this = reinterpret_cast< ResetSimulation* >(object);
  (void)_this;
}
void ResetSimulation::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ResetSimulation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ResetSimulation& ResetSimulation::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ResetSimulation_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void ResetSimulation::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ResetSimulation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  behavior_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResetSimulation::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .mw.internal.robotics.gazebotransport.ResetSimulation.ResetBehavior behavior = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior_IsValid(val))) {
            _internal_set_behavior(static_cast<::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ResetSimulation::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ResetSimulation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .mw.internal.robotics.gazebotransport.ResetSimulation.ResetBehavior behavior = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_behavior(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ResetSimulation)
  return target;
}

size_t ResetSimulation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ResetSimulation)
  size_t total_size = 0;

  // required .mw.internal.robotics.gazebotransport.ResetSimulation.ResetBehavior behavior = 1;
  if (_internal_has_behavior()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_behavior());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ResetSimulation::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ResetSimulation)
  GOOGLE_DCHECK_NE(&from, this);
  const ResetSimulation* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ResetSimulation>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ResetSimulation)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ResetSimulation)
    MergeFrom(*source);
  }
}

void ResetSimulation::MergeFrom(const ResetSimulation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ResetSimulation)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_behavior()) {
    _internal_set_behavior(from._internal_behavior());
  }
}

void ResetSimulation::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ResetSimulation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResetSimulation::CopyFrom(const ResetSimulation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ResetSimulation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResetSimulation::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ResetSimulation::InternalSwap(ResetSimulation* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(behavior_, other->behavior_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResetSimulation::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Image::InitAsDefaultInstance() {
}
class Image::_Internal {
 public:
  using HasBits = decltype(std::declval<Image>()._has_bits_);
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_data_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Image::Image(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.Image)
}
Image::Image(const Image& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_data()) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_data(),
      GetArena());
  }
  data_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_data_type()) {
    data_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_data_type(),
      GetArena());
  }
  ::memcpy(&width_, &from.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&width_)) + sizeof(height_));
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.Image)
}

void Image::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Image_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  data_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&width_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&height_) -
      reinterpret_cast<char*>(&width_)) + sizeof(height_));
}

Image::~Image() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.Image)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Image::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  data_type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Image::ArenaDtor(void* object) {
  Image* _this = reinterpret_cast< Image* >(object);
  (void)_this;
}
void Image::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Image::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Image& Image::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Image_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void Image::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.Image)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      data_type_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&height_) -
        reinterpret_cast<char*>(&width_)) + sizeof(height_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Image::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_width(&has_bits);
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 height = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_height(&has_bits);
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string data_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_data_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.Image.data_type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Image::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.Image)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 width = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_width(), target);
  }

  // optional uint32 height = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_height(), target);
  }

  // optional bytes data = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_data(), target);
  }

  // optional string data_type = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_data_type().data(), static_cast<int>(this->_internal_data_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.Image.data_type");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_data_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.Image)
  return target;
}

size_t Image::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.Image)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes data = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional string data_type = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_data_type());
    }

    // optional uint32 width = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_width());
    }

    // optional uint32 height = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_height());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Image::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.Image)
  GOOGLE_DCHECK_NE(&from, this);
  const Image* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Image>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.Image)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.Image)
    MergeFrom(*source);
  }
}

void Image::MergeFrom(const Image& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.Image)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_data_type(from._internal_data_type());
    }
    if (cached_has_bits & 0x00000004u) {
      width_ = from.width_;
    }
    if (cached_has_bits & 0x00000008u) {
      height_ = from.height_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Image::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.Image)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Image::CopyFrom(const Image& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.Image)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Image::IsInitialized() const {
  return true;
}

void Image::InternalSwap(Image* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  data_.Swap(&other->data_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  data_type_.Swap(&other->data_type_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Image, height_)
      + sizeof(Image::height_)
      - PROTOBUF_FIELD_OFFSET(Image, width_)>(
          reinterpret_cast<char*>(&width_),
          reinterpret_cast<char*>(&other->width_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Image::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void RequestImage::InitAsDefaultInstance() {
}
class RequestImage::_Internal {
 public:
  using HasBits = decltype(std::declval<RequestImage>()._has_bits_);
  static void set_has_topic_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

RequestImage::RequestImage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.RequestImage)
}
RequestImage::RequestImage(const RequestImage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  topic_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topic_name()) {
    topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_topic_name(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.RequestImage)
}

void RequestImage::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RequestImage_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  topic_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

RequestImage::~RequestImage() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.RequestImage)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void RequestImage::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  topic_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void RequestImage::ArenaDtor(void* object) {
  RequestImage* _this = reinterpret_cast< RequestImage* >(object);
  (void)_this;
}
void RequestImage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RequestImage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RequestImage& RequestImage::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RequestImage_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void RequestImage::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.RequestImage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    topic_name_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestImage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string topic_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_topic_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.RequestImage.topic_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RequestImage::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.RequestImage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string topic_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_topic_name().data(), static_cast<int>(this->_internal_topic_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.RequestImage.topic_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_topic_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.RequestImage)
  return target;
}

size_t RequestImage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.RequestImage)
  size_t total_size = 0;

  // required string topic_name = 1;
  if (_internal_has_topic_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic_name());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RequestImage::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.RequestImage)
  GOOGLE_DCHECK_NE(&from, this);
  const RequestImage* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<RequestImage>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.RequestImage)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.RequestImage)
    MergeFrom(*source);
  }
}

void RequestImage::MergeFrom(const RequestImage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.RequestImage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_topic_name()) {
    _internal_set_topic_name(from._internal_topic_name());
  }
}

void RequestImage::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.RequestImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RequestImage::CopyFrom(const RequestImage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.RequestImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestImage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void RequestImage::InternalSwap(RequestImage* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  topic_name_.Swap(&other->topic_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestImage::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void RequestCoSim::InitAsDefaultInstance() {
}
class RequestCoSim::_Internal {
 public:
  using HasBits = decltype(std::declval<RequestCoSim>()._has_bits_);
  static void set_has_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

RequestCoSim::RequestCoSim(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.RequestCoSim)
}
RequestCoSim::RequestCoSim(const RequestCoSim& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  client_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_client_id()) {
    client_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_client_id(),
      GetArena());
  }
  duration_ = from.duration_;
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.RequestCoSim)
}

void RequestCoSim::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RequestCoSim_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  client_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  duration_ = 0;
}

RequestCoSim::~RequestCoSim() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.RequestCoSim)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void RequestCoSim::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  client_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void RequestCoSim::ArenaDtor(void* object) {
  RequestCoSim* _this = reinterpret_cast< RequestCoSim* >(object);
  (void)_this;
}
void RequestCoSim::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RequestCoSim::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RequestCoSim& RequestCoSim::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RequestCoSim_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void RequestCoSim::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.RequestCoSim)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    client_id_.ClearNonDefaultToEmpty();
  }
  duration_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestCoSim::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string client_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_client_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.RequestCoSim.client_id");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required double duration = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_duration(&has_bits);
          duration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RequestCoSim::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.RequestCoSim)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string client_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_client_id().data(), static_cast<int>(this->_internal_client_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.RequestCoSim.client_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_client_id(), target);
  }

  // required double duration = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_duration(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.RequestCoSim)
  return target;
}

size_t RequestCoSim::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.RequestCoSim)
  size_t total_size = 0;

  if (_internal_has_client_id()) {
    // required string client_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_client_id());
  }

  if (_internal_has_duration()) {
    // required double duration = 2;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t RequestCoSim::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.RequestCoSim)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string client_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_client_id());

    // required double duration = 2;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RequestCoSim::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.RequestCoSim)
  GOOGLE_DCHECK_NE(&from, this);
  const RequestCoSim* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<RequestCoSim>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.RequestCoSim)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.RequestCoSim)
    MergeFrom(*source);
  }
}

void RequestCoSim::MergeFrom(const RequestCoSim& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.RequestCoSim)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_client_id(from._internal_client_id());
    }
    if (cached_has_bits & 0x00000002u) {
      duration_ = from.duration_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RequestCoSim::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.RequestCoSim)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RequestCoSim::CopyFrom(const RequestCoSim& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.RequestCoSim)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestCoSim::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void RequestCoSim::InternalSwap(RequestCoSim* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  client_id_.Swap(&other->client_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(duration_, other->duration_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestCoSim::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void StopCoSim::InitAsDefaultInstance() {
}
class StopCoSim::_Internal {
 public:
  using HasBits = decltype(std::declval<StopCoSim>()._has_bits_);
  static void set_has_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

StopCoSim::StopCoSim(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.StopCoSim)
}
StopCoSim::StopCoSim(const StopCoSim& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  client_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_client_id()) {
    client_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_client_id(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.StopCoSim)
}

void StopCoSim::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_StopCoSim_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  client_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

StopCoSim::~StopCoSim() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.StopCoSim)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void StopCoSim::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  client_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void StopCoSim::ArenaDtor(void* object) {
  StopCoSim* _this = reinterpret_cast< StopCoSim* >(object);
  (void)_this;
}
void StopCoSim::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StopCoSim::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StopCoSim& StopCoSim::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StopCoSim_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void StopCoSim::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.StopCoSim)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    client_id_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StopCoSim::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string client_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_client_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.StopCoSim.client_id");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StopCoSim::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.StopCoSim)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string client_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_client_id().data(), static_cast<int>(this->_internal_client_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.StopCoSim.client_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_client_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.StopCoSim)
  return target;
}

size_t StopCoSim::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.StopCoSim)
  size_t total_size = 0;

  // required string client_id = 1;
  if (_internal_has_client_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_client_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StopCoSim::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.StopCoSim)
  GOOGLE_DCHECK_NE(&from, this);
  const StopCoSim* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<StopCoSim>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.StopCoSim)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.StopCoSim)
    MergeFrom(*source);
  }
}

void StopCoSim::MergeFrom(const StopCoSim& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.StopCoSim)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_client_id()) {
    _internal_set_client_id(from._internal_client_id());
  }
}

void StopCoSim::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.StopCoSim)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StopCoSim::CopyFrom(const StopCoSim& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.StopCoSim)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StopCoSim::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void StopCoSim::InternalSwap(StopCoSim* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  client_id_.Swap(&other->client_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata StopCoSim::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void GetGroundTruthWorldPose::InitAsDefaultInstance() {
}
class GetGroundTruthWorldPose::_Internal {
 public:
  using HasBits = decltype(std::declval<GetGroundTruthWorldPose>()._has_bits_);
  static void set_has_model_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_link_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

GetGroundTruthWorldPose::GetGroundTruthWorldPose(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
}
GetGroundTruthWorldPose::GetGroundTruthWorldPose(const GetGroundTruthWorldPose& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_model_name()) {
    model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_model_name(),
      GetArena());
  }
  link_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_link_name()) {
    link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_link_name(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
}

void GetGroundTruthWorldPose::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_GetGroundTruthWorldPose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  link_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

GetGroundTruthWorldPose::~GetGroundTruthWorldPose() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void GetGroundTruthWorldPose::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  model_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  link_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GetGroundTruthWorldPose::ArenaDtor(void* object) {
  GetGroundTruthWorldPose* _this = reinterpret_cast< GetGroundTruthWorldPose* >(object);
  (void)_this;
}
void GetGroundTruthWorldPose::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetGroundTruthWorldPose::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GetGroundTruthWorldPose& GetGroundTruthWorldPose::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_GetGroundTruthWorldPose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void GetGroundTruthWorldPose::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      model_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      link_name_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetGroundTruthWorldPose::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string model_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_model_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string link_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_link_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GetGroundTruthWorldPose::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string model_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_model_name().data(), static_cast<int>(this->_internal_model_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_model_name(), target);
  }

  // required string link_name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_link_name().data(), static_cast<int>(this->_internal_link_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_link_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
  return target;
}

size_t GetGroundTruthWorldPose::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
  size_t total_size = 0;

  if (_internal_has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());
  }

  if (_internal_has_link_name()) {
    // required string link_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_link_name());
  }

  return total_size;
}
size_t GetGroundTruthWorldPose::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());

    // required string link_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_link_name());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetGroundTruthWorldPose::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
  GOOGLE_DCHECK_NE(&from, this);
  const GetGroundTruthWorldPose* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<GetGroundTruthWorldPose>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
    MergeFrom(*source);
  }
}

void GetGroundTruthWorldPose::MergeFrom(const GetGroundTruthWorldPose& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_model_name(from._internal_model_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_link_name(from._internal_link_name());
    }
  }
}

void GetGroundTruthWorldPose::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetGroundTruthWorldPose::CopyFrom(const GetGroundTruthWorldPose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetGroundTruthWorldPose::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GetGroundTruthWorldPose::InternalSwap(GetGroundTruthWorldPose* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  model_name_.Swap(&other->model_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  link_name_.Swap(&other->link_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata GetGroundTruthWorldPose::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Point::InitAsDefaultInstance() {
}
class Point::_Internal {
 public:
  using HasBits = decltype(std::declval<Point>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

Point::Point(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.Point)
}
Point::Point(const Point& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.Point)
}

void Point::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

Point::~Point() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.Point)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Point::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Point::ArenaDtor(void* object) {
  Point* _this = reinterpret_cast< Point* >(object);
  (void)_this;
}
void Point::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Point::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Point& Point::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Point_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void Point::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.Point)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&z_) -
        reinterpret_cast<char*>(&x_)) + sizeof(z_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Point::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required double x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_z(&has_bits);
          z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Point::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.Point)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required double x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // required double y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  // required double z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.Point)
  return target;
}

size_t Point::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.Point)
  size_t total_size = 0;

  if (_internal_has_x()) {
    // required double x = 1;
    total_size += 1 + 8;
  }

  if (_internal_has_y()) {
    // required double y = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_z()) {
    // required double z = 3;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t Point::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.Point)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required double x = 1;
    total_size += 1 + 8;

    // required double y = 2;
    total_size += 1 + 8;

    // required double z = 3;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Point::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.Point)
  GOOGLE_DCHECK_NE(&from, this);
  const Point* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Point>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.Point)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.Point)
    MergeFrom(*source);
  }
}

void Point::MergeFrom(const Point& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.Point)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      z_ = from.z_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Point::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.Point)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Point::CopyFrom(const Point& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.Point)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Point::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void Point::InternalSwap(Point* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Point, z_)
      + sizeof(Point::z_)
      - PROTOBUF_FIELD_OFFSET(Point, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Point::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Quaternion::InitAsDefaultInstance() {
}
class Quaternion::_Internal {
 public:
  using HasBits = decltype(std::declval<Quaternion>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_w(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

Quaternion::Quaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.Quaternion)
}
Quaternion::Quaternion(const Quaternion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&w_) -
    reinterpret_cast<char*>(&x_)) + sizeof(w_));
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.Quaternion)
}

void Quaternion::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&w_) -
      reinterpret_cast<char*>(&x_)) + sizeof(w_));
}

Quaternion::~Quaternion() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.Quaternion)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Quaternion::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Quaternion::ArenaDtor(void* object) {
  Quaternion* _this = reinterpret_cast< Quaternion* >(object);
  (void)_this;
}
void Quaternion::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Quaternion::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Quaternion& Quaternion::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Quaternion_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void Quaternion::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.Quaternion)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&w_) -
        reinterpret_cast<char*>(&x_)) + sizeof(w_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Quaternion::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required double x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_z(&has_bits);
          z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double w = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_w(&has_bits);
          w_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Quaternion::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.Quaternion)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required double x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // required double y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  // required double z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_z(), target);
  }

  // required double w = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_w(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.Quaternion)
  return target;
}

size_t Quaternion::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.Quaternion)
  size_t total_size = 0;

  if (_internal_has_x()) {
    // required double x = 1;
    total_size += 1 + 8;
  }

  if (_internal_has_y()) {
    // required double y = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_z()) {
    // required double z = 3;
    total_size += 1 + 8;
  }

  if (_internal_has_w()) {
    // required double w = 4;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t Quaternion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.Quaternion)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required double x = 1;
    total_size += 1 + 8;

    // required double y = 2;
    total_size += 1 + 8;

    // required double z = 3;
    total_size += 1 + 8;

    // required double w = 4;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Quaternion::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.Quaternion)
  GOOGLE_DCHECK_NE(&from, this);
  const Quaternion* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Quaternion>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.Quaternion)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.Quaternion)
    MergeFrom(*source);
  }
}

void Quaternion::MergeFrom(const Quaternion& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.Quaternion)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      z_ = from.z_;
    }
    if (cached_has_bits & 0x00000008u) {
      w_ = from.w_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Quaternion::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.Quaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Quaternion::CopyFrom(const Quaternion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.Quaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Quaternion::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void Quaternion::InternalSwap(Quaternion* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Quaternion, w_)
      + sizeof(Quaternion::w_)
      - PROTOBUF_FIELD_OFFSET(Quaternion, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Quaternion::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Pose::InitAsDefaultInstance() {
  ::mw::internal::robotics::gazebotransport::_Pose_default_instance_._instance.get_mutable()->position_ = const_cast< ::mw::internal::robotics::gazebotransport::Point*>(
      ::mw::internal::robotics::gazebotransport::Point::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_Pose_default_instance_._instance.get_mutable()->orientation_ = const_cast< ::mw::internal::robotics::gazebotransport::Quaternion*>(
      ::mw::internal::robotics::gazebotransport::Quaternion::internal_default_instance());
}
class Pose::_Internal {
 public:
  using HasBits = decltype(std::declval<Pose>()._has_bits_);
  static const ::mw::internal::robotics::gazebotransport::Point& position(const Pose* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mw::internal::robotics::gazebotransport::Quaternion& orientation(const Pose* msg);
  static void set_has_orientation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::mw::internal::robotics::gazebotransport::Point&
Pose::_Internal::position(const Pose* msg) {
  return *msg->position_;
}
const ::mw::internal::robotics::gazebotransport::Quaternion&
Pose::_Internal::orientation(const Pose* msg) {
  return *msg->orientation_;
}
Pose::Pose(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.Pose)
}
Pose::Pose(const Pose& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_position()) {
    position_ = new ::mw::internal::robotics::gazebotransport::Point(*from.position_);
  } else {
    position_ = nullptr;
  }
  if (from._internal_has_orientation()) {
    orientation_ = new ::mw::internal::robotics::gazebotransport::Quaternion(*from.orientation_);
  } else {
    orientation_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.Pose)
}

void Pose::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Pose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  ::memset(&position_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&orientation_) -
      reinterpret_cast<char*>(&position_)) + sizeof(orientation_));
}

Pose::~Pose() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.Pose)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Pose::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete position_;
  if (this != internal_default_instance()) delete orientation_;
}

void Pose::ArenaDtor(void* object) {
  Pose* _this = reinterpret_cast< Pose* >(object);
  (void)_this;
}
void Pose::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Pose::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Pose& Pose::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Pose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void Pose::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.Pose)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(position_ != nullptr);
      position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(orientation_ != nullptr);
      orientation_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Pose::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .mw.internal.robotics.gazebotransport.Point position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .mw.internal.robotics.gazebotransport.Quaternion orientation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_orientation(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Pose::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.Pose)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .mw.internal.robotics.gazebotransport.Point position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::position(this), target, stream);
  }

  // required .mw.internal.robotics.gazebotransport.Quaternion orientation = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::orientation(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.Pose)
  return target;
}

size_t Pose::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.Pose)
  size_t total_size = 0;

  if (_internal_has_position()) {
    // required .mw.internal.robotics.gazebotransport.Point position = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *position_);
  }

  if (_internal_has_orientation()) {
    // required .mw.internal.robotics.gazebotransport.Quaternion orientation = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *orientation_);
  }

  return total_size;
}
size_t Pose::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.Pose)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .mw.internal.robotics.gazebotransport.Point position = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *position_);

    // required .mw.internal.robotics.gazebotransport.Quaternion orientation = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *orientation_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Pose::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.Pose)
  GOOGLE_DCHECK_NE(&from, this);
  const Pose* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Pose>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.Pose)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.Pose)
    MergeFrom(*source);
  }
}

void Pose::MergeFrom(const Pose& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.Pose)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_position()->::mw::internal::robotics::gazebotransport::Point::MergeFrom(from._internal_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_orientation()->::mw::internal::robotics::gazebotransport::Quaternion::MergeFrom(from._internal_orientation());
    }
  }
}

void Pose::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.Pose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Pose::CopyFrom(const Pose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.Pose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pose::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_position()) {
    if (!position_->IsInitialized()) return false;
  }
  if (_internal_has_orientation()) {
    if (!orientation_->IsInitialized()) return false;
  }
  return true;
}

void Pose::InternalSwap(Pose* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Pose, orientation_)
      + sizeof(Pose::orientation_)
      - PROTOBUF_FIELD_OFFSET(Pose, position_)>(
          reinterpret_cast<char*>(&position_),
          reinterpret_cast<char*>(&other->position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Pose::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void StopSimulation::InitAsDefaultInstance() {
}
class StopSimulation::_Internal {
 public:
  using HasBits = decltype(std::declval<StopSimulation>()._has_bits_);
  static void set_has_stop_scene(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

StopSimulation::StopSimulation(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.StopSimulation)
}
StopSimulation::StopSimulation(const StopSimulation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  stop_scene_ = from.stop_scene_;
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.StopSimulation)
}

void StopSimulation::SharedCtor() {
  stop_scene_ = false;
}

StopSimulation::~StopSimulation() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.StopSimulation)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void StopSimulation::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void StopSimulation::ArenaDtor(void* object) {
  StopSimulation* _this = reinterpret_cast< StopSimulation* >(object);
  (void)_this;
}
void StopSimulation::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StopSimulation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StopSimulation& StopSimulation::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StopSimulation_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void StopSimulation::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.StopSimulation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  stop_scene_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StopSimulation::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bool stop_scene = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_stop_scene(&has_bits);
          stop_scene_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StopSimulation::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.StopSimulation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool stop_scene = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_stop_scene(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.StopSimulation)
  return target;
}

size_t StopSimulation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.StopSimulation)
  size_t total_size = 0;

  // required bool stop_scene = 1;
  if (_internal_has_stop_scene()) {
    total_size += 1 + 1;
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StopSimulation::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.StopSimulation)
  GOOGLE_DCHECK_NE(&from, this);
  const StopSimulation* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<StopSimulation>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.StopSimulation)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.StopSimulation)
    MergeFrom(*source);
  }
}

void StopSimulation::MergeFrom(const StopSimulation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.StopSimulation)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_stop_scene()) {
    _internal_set_stop_scene(from._internal_stop_scene());
  }
}

void StopSimulation::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.StopSimulation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StopSimulation::CopyFrom(const StopSimulation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.StopSimulation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StopSimulation::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void StopSimulation::InternalSwap(StopSimulation* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(stop_scene_, other->stop_scene_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StopSimulation::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void LaserData::InitAsDefaultInstance() {
}
class LaserData::_Internal {
 public:
  using HasBits = decltype(std::declval<LaserData>()._has_bits_);
  static void set_has_angle_min(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_angle_max(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_angle_step(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_range_min(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_range_max(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_vertical_angle_min(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_vertical_angle_max(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_vertical_angle_step(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

LaserData::LaserData(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  range_(arena),
  intensities_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.LaserData)
}
LaserData::LaserData(const LaserData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      range_(from.range_),
      intensities_(from.intensities_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&angle_min_, &from.angle_min_,
    static_cast<size_t>(reinterpret_cast<char*>(&vertical_angle_step_) -
    reinterpret_cast<char*>(&angle_min_)) + sizeof(vertical_angle_step_));
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.LaserData)
}

void LaserData::SharedCtor() {
  ::memset(&angle_min_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&vertical_angle_step_) -
      reinterpret_cast<char*>(&angle_min_)) + sizeof(vertical_angle_step_));
}

LaserData::~LaserData() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.LaserData)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void LaserData::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void LaserData::ArenaDtor(void* object) {
  LaserData* _this = reinterpret_cast< LaserData* >(object);
  (void)_this;
}
void LaserData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LaserData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LaserData& LaserData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_LaserData_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void LaserData::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.LaserData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  range_.Clear();
  intensities_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&angle_min_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&vertical_angle_max_) -
        reinterpret_cast<char*>(&angle_min_)) + sizeof(vertical_angle_max_));
  }
  vertical_angle_step_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LaserData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional double angle_min = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_angle_min(&has_bits);
          angle_min_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double angle_max = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_angle_max(&has_bits);
          angle_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double angle_step = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_angle_step(&has_bits);
          angle_step_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double range_min = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_range_min(&has_bits);
          range_min_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double range_max = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _Internal::set_has_range_max(&has_bits);
          range_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double count = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 49)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double vertical_angle_min = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 57)) {
          _Internal::set_has_vertical_angle_min(&has_bits);
          vertical_angle_min_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double vertical_angle_max = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 65)) {
          _Internal::set_has_vertical_angle_max(&has_bits);
          vertical_angle_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double vertical_angle_step = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 73)) {
          _Internal::set_has_vertical_angle_step(&has_bits);
          vertical_angle_step_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // repeated double range = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 81)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_range(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<81>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_range(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated double intensities = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 89)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_intensities(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<89>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_intensities(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LaserData::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.LaserData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double angle_min = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_angle_min(), target);
  }

  // optional double angle_max = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_angle_max(), target);
  }

  // optional double angle_step = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_angle_step(), target);
  }

  // optional double range_min = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_range_min(), target);
  }

  // optional double range_max = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_range_max(), target);
  }

  // optional double count = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(6, this->_internal_count(), target);
  }

  // optional double vertical_angle_min = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(7, this->_internal_vertical_angle_min(), target);
  }

  // optional double vertical_angle_max = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(8, this->_internal_vertical_angle_max(), target);
  }

  // optional double vertical_angle_step = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(9, this->_internal_vertical_angle_step(), target);
  }

  // repeated double range = 10;
  for (int i = 0, n = this->_internal_range_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(10, this->_internal_range(i), target);
  }

  // repeated double intensities = 11;
  for (int i = 0, n = this->_internal_intensities_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(11, this->_internal_intensities(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.LaserData)
  return target;
}

size_t LaserData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.LaserData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double range = 10;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_range_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_range_size());
    total_size += data_size;
  }

  // repeated double intensities = 11;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_intensities_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_intensities_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional double angle_min = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double angle_max = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double angle_step = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double range_min = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double range_max = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double count = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double vertical_angle_min = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional double vertical_angle_max = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  // optional double vertical_angle_step = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 8;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LaserData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.LaserData)
  GOOGLE_DCHECK_NE(&from, this);
  const LaserData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LaserData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.LaserData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.LaserData)
    MergeFrom(*source);
  }
}

void LaserData::MergeFrom(const LaserData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.LaserData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  range_.MergeFrom(from.range_);
  intensities_.MergeFrom(from.intensities_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      angle_min_ = from.angle_min_;
    }
    if (cached_has_bits & 0x00000002u) {
      angle_max_ = from.angle_max_;
    }
    if (cached_has_bits & 0x00000004u) {
      angle_step_ = from.angle_step_;
    }
    if (cached_has_bits & 0x00000008u) {
      range_min_ = from.range_min_;
    }
    if (cached_has_bits & 0x00000010u) {
      range_max_ = from.range_max_;
    }
    if (cached_has_bits & 0x00000020u) {
      count_ = from.count_;
    }
    if (cached_has_bits & 0x00000040u) {
      vertical_angle_min_ = from.vertical_angle_min_;
    }
    if (cached_has_bits & 0x00000080u) {
      vertical_angle_max_ = from.vertical_angle_max_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_vertical_angle_step(from._internal_vertical_angle_step());
  }
}

void LaserData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.LaserData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LaserData::CopyFrom(const LaserData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.LaserData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaserData::IsInitialized() const {
  return true;
}

void LaserData::InternalSwap(LaserData* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  range_.InternalSwap(&other->range_);
  intensities_.InternalSwap(&other->intensities_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LaserData, vertical_angle_step_)
      + sizeof(LaserData::vertical_angle_step_)
      - PROTOBUF_FIELD_OFFSET(LaserData, angle_min_)>(
          reinterpret_cast<char*>(&angle_min_),
          reinterpret_cast<char*>(&other->angle_min_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LaserData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void RequestLaser::InitAsDefaultInstance() {
}
class RequestLaser::_Internal {
 public:
  using HasBits = decltype(std::declval<RequestLaser>()._has_bits_);
  static void set_has_topic_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

RequestLaser::RequestLaser(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.RequestLaser)
}
RequestLaser::RequestLaser(const RequestLaser& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  topic_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topic_name()) {
    topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_topic_name(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.RequestLaser)
}

void RequestLaser::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RequestLaser_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  topic_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

RequestLaser::~RequestLaser() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.RequestLaser)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void RequestLaser::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  topic_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void RequestLaser::ArenaDtor(void* object) {
  RequestLaser* _this = reinterpret_cast< RequestLaser* >(object);
  (void)_this;
}
void RequestLaser::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RequestLaser::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RequestLaser& RequestLaser::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RequestLaser_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void RequestLaser::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.RequestLaser)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    topic_name_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestLaser::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string topic_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_topic_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.RequestLaser.topic_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RequestLaser::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.RequestLaser)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string topic_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_topic_name().data(), static_cast<int>(this->_internal_topic_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.RequestLaser.topic_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_topic_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.RequestLaser)
  return target;
}

size_t RequestLaser::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.RequestLaser)
  size_t total_size = 0;

  // required string topic_name = 1;
  if (_internal_has_topic_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic_name());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RequestLaser::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.RequestLaser)
  GOOGLE_DCHECK_NE(&from, this);
  const RequestLaser* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<RequestLaser>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.RequestLaser)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.RequestLaser)
    MergeFrom(*source);
  }
}

void RequestLaser::MergeFrom(const RequestLaser& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.RequestLaser)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_topic_name()) {
    _internal_set_topic_name(from._internal_topic_name());
  }
}

void RequestLaser::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.RequestLaser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RequestLaser::CopyFrom(const RequestLaser& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.RequestLaser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestLaser::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void RequestLaser::InternalSwap(RequestLaser* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  topic_name_.Swap(&other->topic_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestLaser::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ImuData::InitAsDefaultInstance() {
  ::mw::internal::robotics::gazebotransport::_ImuData_default_instance_._instance.get_mutable()->linear_acceleration_ = const_cast< ::mw::internal::robotics::gazebotransport::Point*>(
      ::mw::internal::robotics::gazebotransport::Point::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_ImuData_default_instance_._instance.get_mutable()->angular_velocity_ = const_cast< ::mw::internal::robotics::gazebotransport::Point*>(
      ::mw::internal::robotics::gazebotransport::Point::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_ImuData_default_instance_._instance.get_mutable()->orientation_ = const_cast< ::mw::internal::robotics::gazebotransport::Quaternion*>(
      ::mw::internal::robotics::gazebotransport::Quaternion::internal_default_instance());
}
class ImuData::_Internal {
 public:
  using HasBits = decltype(std::declval<ImuData>()._has_bits_);
  static const ::mw::internal::robotics::gazebotransport::Point& linear_acceleration(const ImuData* msg);
  static void set_has_linear_acceleration(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mw::internal::robotics::gazebotransport::Point& angular_velocity(const ImuData* msg);
  static void set_has_angular_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::mw::internal::robotics::gazebotransport::Quaternion& orientation(const ImuData* msg);
  static void set_has_orientation(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::mw::internal::robotics::gazebotransport::Point&
ImuData::_Internal::linear_acceleration(const ImuData* msg) {
  return *msg->linear_acceleration_;
}
const ::mw::internal::robotics::gazebotransport::Point&
ImuData::_Internal::angular_velocity(const ImuData* msg) {
  return *msg->angular_velocity_;
}
const ::mw::internal::robotics::gazebotransport::Quaternion&
ImuData::_Internal::orientation(const ImuData* msg) {
  return *msg->orientation_;
}
ImuData::ImuData(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.ImuData)
}
ImuData::ImuData(const ImuData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_linear_acceleration()) {
    linear_acceleration_ = new ::mw::internal::robotics::gazebotransport::Point(*from.linear_acceleration_);
  } else {
    linear_acceleration_ = nullptr;
  }
  if (from._internal_has_angular_velocity()) {
    angular_velocity_ = new ::mw::internal::robotics::gazebotransport::Point(*from.angular_velocity_);
  } else {
    angular_velocity_ = nullptr;
  }
  if (from._internal_has_orientation()) {
    orientation_ = new ::mw::internal::robotics::gazebotransport::Quaternion(*from.orientation_);
  } else {
    orientation_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ImuData)
}

void ImuData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ImuData_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  ::memset(&linear_acceleration_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&orientation_) -
      reinterpret_cast<char*>(&linear_acceleration_)) + sizeof(orientation_));
}

ImuData::~ImuData() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ImuData)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ImuData::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete linear_acceleration_;
  if (this != internal_default_instance()) delete angular_velocity_;
  if (this != internal_default_instance()) delete orientation_;
}

void ImuData::ArenaDtor(void* object) {
  ImuData* _this = reinterpret_cast< ImuData* >(object);
  (void)_this;
}
void ImuData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ImuData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ImuData& ImuData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ImuData_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void ImuData::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ImuData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(linear_acceleration_ != nullptr);
      linear_acceleration_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(angular_velocity_ != nullptr);
      angular_velocity_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(orientation_ != nullptr);
      orientation_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ImuData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .mw.internal.robotics.gazebotransport.Point linear_acceleration = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_linear_acceleration(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mw.internal.robotics.gazebotransport.Point angular_velocity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_angular_velocity(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mw.internal.robotics.gazebotransport.Quaternion orientation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_orientation(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ImuData::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ImuData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .mw.internal.robotics.gazebotransport.Point linear_acceleration = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::linear_acceleration(this), target, stream);
  }

  // optional .mw.internal.robotics.gazebotransport.Point angular_velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::angular_velocity(this), target, stream);
  }

  // optional .mw.internal.robotics.gazebotransport.Quaternion orientation = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::orientation(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ImuData)
  return target;
}

size_t ImuData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ImuData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .mw.internal.robotics.gazebotransport.Point linear_acceleration = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *linear_acceleration_);
    }

    // optional .mw.internal.robotics.gazebotransport.Point angular_velocity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *angular_velocity_);
    }

    // optional .mw.internal.robotics.gazebotransport.Quaternion orientation = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *orientation_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ImuData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ImuData)
  GOOGLE_DCHECK_NE(&from, this);
  const ImuData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ImuData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ImuData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ImuData)
    MergeFrom(*source);
  }
}

void ImuData::MergeFrom(const ImuData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ImuData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_linear_acceleration()->::mw::internal::robotics::gazebotransport::Point::MergeFrom(from._internal_linear_acceleration());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_angular_velocity()->::mw::internal::robotics::gazebotransport::Point::MergeFrom(from._internal_angular_velocity());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_orientation()->::mw::internal::robotics::gazebotransport::Quaternion::MergeFrom(from._internal_orientation());
    }
  }
}

void ImuData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ImuData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ImuData::CopyFrom(const ImuData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ImuData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImuData::IsInitialized() const {
  if (_internal_has_linear_acceleration()) {
    if (!linear_acceleration_->IsInitialized()) return false;
  }
  if (_internal_has_angular_velocity()) {
    if (!angular_velocity_->IsInitialized()) return false;
  }
  if (_internal_has_orientation()) {
    if (!orientation_->IsInitialized()) return false;
  }
  return true;
}

void ImuData::InternalSwap(ImuData* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ImuData, orientation_)
      + sizeof(ImuData::orientation_)
      - PROTOBUF_FIELD_OFFSET(ImuData, linear_acceleration_)>(
          reinterpret_cast<char*>(&linear_acceleration_),
          reinterpret_cast<char*>(&other->linear_acceleration_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ImuData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void RequestImu::InitAsDefaultInstance() {
}
class RequestImu::_Internal {
 public:
  using HasBits = decltype(std::declval<RequestImu>()._has_bits_);
  static void set_has_topic_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

RequestImu::RequestImu(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.RequestImu)
}
RequestImu::RequestImu(const RequestImu& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  topic_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topic_name()) {
    topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_topic_name(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.RequestImu)
}

void RequestImu::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RequestImu_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  topic_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

RequestImu::~RequestImu() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.RequestImu)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void RequestImu::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  topic_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void RequestImu::ArenaDtor(void* object) {
  RequestImu* _this = reinterpret_cast< RequestImu* >(object);
  (void)_this;
}
void RequestImu::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RequestImu::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RequestImu& RequestImu::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RequestImu_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void RequestImu::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.RequestImu)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    topic_name_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestImu::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string topic_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_topic_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.RequestImu.topic_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RequestImu::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.RequestImu)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string topic_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_topic_name().data(), static_cast<int>(this->_internal_topic_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.RequestImu.topic_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_topic_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.RequestImu)
  return target;
}

size_t RequestImu::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.RequestImu)
  size_t total_size = 0;

  // required string topic_name = 1;
  if (_internal_has_topic_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic_name());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RequestImu::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.RequestImu)
  GOOGLE_DCHECK_NE(&from, this);
  const RequestImu* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<RequestImu>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.RequestImu)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.RequestImu)
    MergeFrom(*source);
  }
}

void RequestImu::MergeFrom(const RequestImu& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.RequestImu)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_topic_name()) {
    _internal_set_topic_name(from._internal_topic_name());
  }
}

void RequestImu::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.RequestImu)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RequestImu::CopyFrom(const RequestImu& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.RequestImu)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestImu::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void RequestImu::InternalSwap(RequestImu* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  topic_name_.Swap(&other->topic_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestImu::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void SubscribeImage::InitAsDefaultInstance() {
}
class SubscribeImage::_Internal {
 public:
  using HasBits = decltype(std::declval<SubscribeImage>()._has_bits_);
  static void set_has_topic_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SubscribeImage::SubscribeImage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.SubscribeImage)
}
SubscribeImage::SubscribeImage(const SubscribeImage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  topic_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topic_name()) {
    topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_topic_name(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.SubscribeImage)
}

void SubscribeImage::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SubscribeImage_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  topic_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

SubscribeImage::~SubscribeImage() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.SubscribeImage)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SubscribeImage::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  topic_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SubscribeImage::ArenaDtor(void* object) {
  SubscribeImage* _this = reinterpret_cast< SubscribeImage* >(object);
  (void)_this;
}
void SubscribeImage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SubscribeImage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SubscribeImage& SubscribeImage::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SubscribeImage_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void SubscribeImage::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.SubscribeImage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    topic_name_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubscribeImage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string topic_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_topic_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.SubscribeImage.topic_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SubscribeImage::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.SubscribeImage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string topic_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_topic_name().data(), static_cast<int>(this->_internal_topic_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SubscribeImage.topic_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_topic_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.SubscribeImage)
  return target;
}

size_t SubscribeImage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.SubscribeImage)
  size_t total_size = 0;

  // required string topic_name = 1;
  if (_internal_has_topic_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic_name());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SubscribeImage::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.SubscribeImage)
  GOOGLE_DCHECK_NE(&from, this);
  const SubscribeImage* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SubscribeImage>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.SubscribeImage)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.SubscribeImage)
    MergeFrom(*source);
  }
}

void SubscribeImage::MergeFrom(const SubscribeImage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.SubscribeImage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_topic_name()) {
    _internal_set_topic_name(from._internal_topic_name());
  }
}

void SubscribeImage::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.SubscribeImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SubscribeImage::CopyFrom(const SubscribeImage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.SubscribeImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubscribeImage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void SubscribeImage::InternalSwap(SubscribeImage* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  topic_name_.Swap(&other->topic_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata SubscribeImage::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void SubscribeLaser::InitAsDefaultInstance() {
}
class SubscribeLaser::_Internal {
 public:
  using HasBits = decltype(std::declval<SubscribeLaser>()._has_bits_);
  static void set_has_topic_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SubscribeLaser::SubscribeLaser(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.SubscribeLaser)
}
SubscribeLaser::SubscribeLaser(const SubscribeLaser& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  topic_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topic_name()) {
    topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_topic_name(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.SubscribeLaser)
}

void SubscribeLaser::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SubscribeLaser_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  topic_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

SubscribeLaser::~SubscribeLaser() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.SubscribeLaser)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SubscribeLaser::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  topic_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SubscribeLaser::ArenaDtor(void* object) {
  SubscribeLaser* _this = reinterpret_cast< SubscribeLaser* >(object);
  (void)_this;
}
void SubscribeLaser::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SubscribeLaser::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SubscribeLaser& SubscribeLaser::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SubscribeLaser_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void SubscribeLaser::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.SubscribeLaser)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    topic_name_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubscribeLaser::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string topic_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_topic_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SubscribeLaser::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.SubscribeLaser)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string topic_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_topic_name().data(), static_cast<int>(this->_internal_topic_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_topic_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.SubscribeLaser)
  return target;
}

size_t SubscribeLaser::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.SubscribeLaser)
  size_t total_size = 0;

  // required string topic_name = 1;
  if (_internal_has_topic_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic_name());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SubscribeLaser::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.SubscribeLaser)
  GOOGLE_DCHECK_NE(&from, this);
  const SubscribeLaser* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SubscribeLaser>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.SubscribeLaser)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.SubscribeLaser)
    MergeFrom(*source);
  }
}

void SubscribeLaser::MergeFrom(const SubscribeLaser& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.SubscribeLaser)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_topic_name()) {
    _internal_set_topic_name(from._internal_topic_name());
  }
}

void SubscribeLaser::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.SubscribeLaser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SubscribeLaser::CopyFrom(const SubscribeLaser& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.SubscribeLaser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubscribeLaser::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void SubscribeLaser::InternalSwap(SubscribeLaser* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  topic_name_.Swap(&other->topic_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata SubscribeLaser::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void SubscribeImu::InitAsDefaultInstance() {
}
class SubscribeImu::_Internal {
 public:
  using HasBits = decltype(std::declval<SubscribeImu>()._has_bits_);
  static void set_has_topic_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SubscribeImu::SubscribeImu(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.SubscribeImu)
}
SubscribeImu::SubscribeImu(const SubscribeImu& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  topic_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topic_name()) {
    topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_topic_name(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.SubscribeImu)
}

void SubscribeImu::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SubscribeImu_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  topic_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

SubscribeImu::~SubscribeImu() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.SubscribeImu)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SubscribeImu::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  topic_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SubscribeImu::ArenaDtor(void* object) {
  SubscribeImu* _this = reinterpret_cast< SubscribeImu* >(object);
  (void)_this;
}
void SubscribeImu::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SubscribeImu::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SubscribeImu& SubscribeImu::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SubscribeImu_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void SubscribeImu::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.SubscribeImu)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    topic_name_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubscribeImu::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string topic_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_topic_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.SubscribeImu.topic_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SubscribeImu::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.SubscribeImu)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string topic_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_topic_name().data(), static_cast<int>(this->_internal_topic_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SubscribeImu.topic_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_topic_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.SubscribeImu)
  return target;
}

size_t SubscribeImu::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.SubscribeImu)
  size_t total_size = 0;

  // required string topic_name = 1;
  if (_internal_has_topic_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic_name());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SubscribeImu::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.SubscribeImu)
  GOOGLE_DCHECK_NE(&from, this);
  const SubscribeImu* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SubscribeImu>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.SubscribeImu)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.SubscribeImu)
    MergeFrom(*source);
  }
}

void SubscribeImu::MergeFrom(const SubscribeImu& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.SubscribeImu)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_topic_name()) {
    _internal_set_topic_name(from._internal_topic_name());
  }
}

void SubscribeImu::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.SubscribeImu)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SubscribeImu::CopyFrom(const SubscribeImu& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.SubscribeImu)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubscribeImu::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void SubscribeImu::InternalSwap(SubscribeImu* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  topic_name_.Swap(&other->topic_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata SubscribeImu::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ApplyLinkWrench::InitAsDefaultInstance() {
  ::mw::internal::robotics::gazebotransport::_ApplyLinkWrench_default_instance_._instance.get_mutable()->duration_ = const_cast< ::mw::internal::robotics::gazebotransport::Time*>(
      ::mw::internal::robotics::gazebotransport::Time::internal_default_instance());
}
class ApplyLinkWrench::_Internal {
 public:
  using HasBits = decltype(std::declval<ApplyLinkWrench>()._has_bits_);
  static void set_has_model_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_link_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_force_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_fx(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_fy(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_fz(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_torque_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_tx(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_ty(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_tz(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::mw::internal::robotics::gazebotransport::Time& duration(const ApplyLinkWrench* msg);
  static void set_has_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x000007ff) ^ 0x000007ff) != 0;
  }
};

const ::mw::internal::robotics::gazebotransport::Time&
ApplyLinkWrench::_Internal::duration(const ApplyLinkWrench* msg) {
  return *msg->duration_;
}
ApplyLinkWrench::ApplyLinkWrench(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
}
ApplyLinkWrench::ApplyLinkWrench(const ApplyLinkWrench& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_model_name()) {
    model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_model_name(),
      GetArena());
  }
  link_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_link_name()) {
    link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_link_name(),
      GetArena());
  }
  force_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_force_type()) {
    force_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_force_type(),
      GetArena());
  }
  torque_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_torque_type()) {
    torque_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_torque_type(),
      GetArena());
  }
  if (from._internal_has_duration()) {
    duration_ = new ::mw::internal::robotics::gazebotransport::Time(*from.duration_);
  } else {
    duration_ = nullptr;
  }
  ::memcpy(&fx_, &from.fx_,
    static_cast<size_t>(reinterpret_cast<char*>(&tz_) -
    reinterpret_cast<char*>(&fx_)) + sizeof(tz_));
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
}

void ApplyLinkWrench::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ApplyLinkWrench_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  link_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  force_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  torque_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&duration_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&tz_) -
      reinterpret_cast<char*>(&duration_)) + sizeof(tz_));
}

ApplyLinkWrench::~ApplyLinkWrench() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ApplyLinkWrench::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  model_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  link_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  force_type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  torque_type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete duration_;
}

void ApplyLinkWrench::ArenaDtor(void* object) {
  ApplyLinkWrench* _this = reinterpret_cast< ApplyLinkWrench* >(object);
  (void)_this;
}
void ApplyLinkWrench::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ApplyLinkWrench::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ApplyLinkWrench& ApplyLinkWrench::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ApplyLinkWrench_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void ApplyLinkWrench::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      model_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      link_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      force_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      torque_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(duration_ != nullptr);
      duration_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&fx_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&fz_) -
        reinterpret_cast<char*>(&fx_)) + sizeof(fz_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&tx_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&tz_) -
        reinterpret_cast<char*>(&tx_)) + sizeof(tz_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ApplyLinkWrench::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string model_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_model_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string link_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_link_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string force_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_force_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required double fx = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_fx(&has_bits);
          fx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double fy = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _Internal::set_has_fy(&has_bits);
          fy_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double fz = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 49)) {
          _Internal::set_has_fz(&has_bits);
          fz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required string torque_type = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          auto str = _internal_mutable_torque_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required double tx = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 65)) {
          _Internal::set_has_tx(&has_bits);
          tx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double ty = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 73)) {
          _Internal::set_has_ty(&has_bits);
          ty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double tz = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 81)) {
          _Internal::set_has_tz(&has_bits);
          tz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required .mw.internal.robotics.gazebotransport.Time duration = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_duration(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ApplyLinkWrench::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string model_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_model_name().data(), static_cast<int>(this->_internal_model_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_model_name(), target);
  }

  // required string link_name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_link_name().data(), static_cast<int>(this->_internal_link_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_link_name(), target);
  }

  // required string force_type = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_force_type().data(), static_cast<int>(this->_internal_force_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_force_type(), target);
  }

  // required double fx = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_fx(), target);
  }

  // required double fy = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_fy(), target);
  }

  // required double fz = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(6, this->_internal_fz(), target);
  }

  // required string torque_type = 7;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_torque_type().data(), static_cast<int>(this->_internal_torque_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_torque_type(), target);
  }

  // required double tx = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(8, this->_internal_tx(), target);
  }

  // required double ty = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(9, this->_internal_ty(), target);
  }

  // required double tz = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(10, this->_internal_tz(), target);
  }

  // required .mw.internal.robotics.gazebotransport.Time duration = 11;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::duration(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
  return target;
}

size_t ApplyLinkWrench::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
  size_t total_size = 0;

  if (_internal_has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());
  }

  if (_internal_has_link_name()) {
    // required string link_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_link_name());
  }

  if (_internal_has_force_type()) {
    // required string force_type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_force_type());
  }

  if (_internal_has_torque_type()) {
    // required string torque_type = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_torque_type());
  }

  if (_internal_has_duration()) {
    // required .mw.internal.robotics.gazebotransport.Time duration = 11;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *duration_);
  }

  if (_internal_has_fx()) {
    // required double fx = 4;
    total_size += 1 + 8;
  }

  if (_internal_has_fy()) {
    // required double fy = 5;
    total_size += 1 + 8;
  }

  if (_internal_has_fz()) {
    // required double fz = 6;
    total_size += 1 + 8;
  }

  if (_internal_has_tx()) {
    // required double tx = 8;
    total_size += 1 + 8;
  }

  if (_internal_has_ty()) {
    // required double ty = 9;
    total_size += 1 + 8;
  }

  if (_internal_has_tz()) {
    // required double tz = 10;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t ApplyLinkWrench::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x000007ff) ^ 0x000007ff) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());

    // required string link_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_link_name());

    // required string force_type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_force_type());

    // required string torque_type = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_torque_type());

    // required .mw.internal.robotics.gazebotransport.Time duration = 11;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *duration_);

    // required double fx = 4;
    total_size += 1 + 8;

    // required double fy = 5;
    total_size += 1 + 8;

    // required double fz = 6;
    total_size += 1 + 8;

    // required double tx = 8;
    total_size += 1 + 8;

    // required double ty = 9;
    total_size += 1 + 8;

    // required double tz = 10;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ApplyLinkWrench::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
  GOOGLE_DCHECK_NE(&from, this);
  const ApplyLinkWrench* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ApplyLinkWrench>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
    MergeFrom(*source);
  }
}

void ApplyLinkWrench::MergeFrom(const ApplyLinkWrench& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_model_name(from._internal_model_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_link_name(from._internal_link_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_force_type(from._internal_force_type());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_torque_type(from._internal_torque_type());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_duration()->::mw::internal::robotics::gazebotransport::Time::MergeFrom(from._internal_duration());
    }
    if (cached_has_bits & 0x00000020u) {
      fx_ = from.fx_;
    }
    if (cached_has_bits & 0x00000040u) {
      fy_ = from.fy_;
    }
    if (cached_has_bits & 0x00000080u) {
      fz_ = from.fz_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      tx_ = from.tx_;
    }
    if (cached_has_bits & 0x00000200u) {
      ty_ = from.ty_;
    }
    if (cached_has_bits & 0x00000400u) {
      tz_ = from.tz_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ApplyLinkWrench::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ApplyLinkWrench::CopyFrom(const ApplyLinkWrench& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplyLinkWrench::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_duration()) {
    if (!duration_->IsInitialized()) return false;
  }
  return true;
}

void ApplyLinkWrench::InternalSwap(ApplyLinkWrench* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  model_name_.Swap(&other->model_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  link_name_.Swap(&other->link_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  force_type_.Swap(&other->force_type_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  torque_type_.Swap(&other->torque_type_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ApplyLinkWrench, tz_)
      + sizeof(ApplyLinkWrench::tz_)
      - PROTOBUF_FIELD_OFFSET(ApplyLinkWrench, duration_)>(
          reinterpret_cast<char*>(&duration_),
          reinterpret_cast<char*>(&other->duration_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ApplyLinkWrench::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ApplyJointTorque::InitAsDefaultInstance() {
  ::mw::internal::robotics::gazebotransport::_ApplyJointTorque_default_instance_._instance.get_mutable()->duration_ = const_cast< ::mw::internal::robotics::gazebotransport::Time*>(
      ::mw::internal::robotics::gazebotransport::Time::internal_default_instance());
}
class ApplyJointTorque::_Internal {
 public:
  using HasBits = decltype(std::declval<ApplyJointTorque>()._has_bits_);
  static void set_has_model_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_joint_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_effort(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::mw::internal::robotics::gazebotransport::Time& duration(const ApplyJointTorque* msg);
  static void set_has_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::mw::internal::robotics::gazebotransport::Time&
ApplyJointTorque::_Internal::duration(const ApplyJointTorque* msg) {
  return *msg->duration_;
}
ApplyJointTorque::ApplyJointTorque(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.ApplyJointTorque)
}
ApplyJointTorque::ApplyJointTorque(const ApplyJointTorque& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_model_name()) {
    model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_model_name(),
      GetArena());
  }
  joint_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_joint_name()) {
    joint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_joint_name(),
      GetArena());
  }
  if (from._internal_has_duration()) {
    duration_ = new ::mw::internal::robotics::gazebotransport::Time(*from.duration_);
  } else {
    duration_ = nullptr;
  }
  ::memcpy(&effort_, &from.effort_,
    static_cast<size_t>(reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&effort_)) + sizeof(index_));
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ApplyJointTorque)
}

void ApplyJointTorque::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ApplyJointTorque_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  joint_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&duration_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&index_) -
      reinterpret_cast<char*>(&duration_)) + sizeof(index_));
}

ApplyJointTorque::~ApplyJointTorque() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ApplyJointTorque)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ApplyJointTorque::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  model_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  joint_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete duration_;
}

void ApplyJointTorque::ArenaDtor(void* object) {
  ApplyJointTorque* _this = reinterpret_cast< ApplyJointTorque* >(object);
  (void)_this;
}
void ApplyJointTorque::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ApplyJointTorque::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ApplyJointTorque& ApplyJointTorque::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ApplyJointTorque_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void ApplyJointTorque::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ApplyJointTorque)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      model_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      joint_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(duration_ != nullptr);
      duration_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&effort_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&index_) -
        reinterpret_cast<char*>(&effort_)) + sizeof(index_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ApplyJointTorque::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string model_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_model_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string joint_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_joint_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required double effort = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_effort(&has_bits);
          effort_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required .mw.internal.robotics.gazebotransport.Time duration = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_duration(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ApplyJointTorque::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ApplyJointTorque)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string model_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_model_name().data(), static_cast<int>(this->_internal_model_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_model_name(), target);
  }

  // required string joint_name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_joint_name().data(), static_cast<int>(this->_internal_joint_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_joint_name(), target);
  }

  // required uint32 index = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_index(), target);
  }

  // required double effort = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_effort(), target);
  }

  // required .mw.internal.robotics.gazebotransport.Time duration = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::duration(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ApplyJointTorque)
  return target;
}

size_t ApplyJointTorque::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.ApplyJointTorque)
  size_t total_size = 0;

  if (_internal_has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());
  }

  if (_internal_has_joint_name()) {
    // required string joint_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_joint_name());
  }

  if (_internal_has_duration()) {
    // required .mw.internal.robotics.gazebotransport.Time duration = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *duration_);
  }

  if (_internal_has_effort()) {
    // required double effort = 4;
    total_size += 1 + 8;
  }

  if (_internal_has_index()) {
    // required uint32 index = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_index());
  }

  return total_size;
}
size_t ApplyJointTorque::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ApplyJointTorque)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());

    // required string joint_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_joint_name());

    // required .mw.internal.robotics.gazebotransport.Time duration = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *duration_);

    // required double effort = 4;
    total_size += 1 + 8;

    // required uint32 index = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_index());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ApplyJointTorque::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ApplyJointTorque)
  GOOGLE_DCHECK_NE(&from, this);
  const ApplyJointTorque* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ApplyJointTorque>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ApplyJointTorque)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ApplyJointTorque)
    MergeFrom(*source);
  }
}

void ApplyJointTorque::MergeFrom(const ApplyJointTorque& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ApplyJointTorque)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_model_name(from._internal_model_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_joint_name(from._internal_joint_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_duration()->::mw::internal::robotics::gazebotransport::Time::MergeFrom(from._internal_duration());
    }
    if (cached_has_bits & 0x00000008u) {
      effort_ = from.effort_;
    }
    if (cached_has_bits & 0x00000010u) {
      index_ = from.index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ApplyJointTorque::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ApplyJointTorque)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ApplyJointTorque::CopyFrom(const ApplyJointTorque& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ApplyJointTorque)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplyJointTorque::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_duration()) {
    if (!duration_->IsInitialized()) return false;
  }
  return true;
}

void ApplyJointTorque::InternalSwap(ApplyJointTorque* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  model_name_.Swap(&other->model_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  joint_name_.Swap(&other->joint_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ApplyJointTorque, index_)
      + sizeof(ApplyJointTorque::index_)
      - PROTOBUF_FIELD_OFFSET(ApplyJointTorque, duration_)>(
          reinterpret_cast<char*>(&duration_),
          reinterpret_cast<char*>(&other->duration_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ApplyJointTorque::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void GetPose::InitAsDefaultInstance() {
}
class GetPose::_Internal {
 public:
  using HasBits = decltype(std::declval<GetPose>()._has_bits_);
  static void set_has_model_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

GetPose::GetPose(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.GetPose)
}
GetPose::GetPose(const GetPose& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_model_name()) {
    model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_model_name(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.GetPose)
}

void GetPose::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_GetPose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

GetPose::~GetPose() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.GetPose)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void GetPose::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  model_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GetPose::ArenaDtor(void* object) {
  GetPose* _this = reinterpret_cast< GetPose* >(object);
  (void)_this;
}
void GetPose::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetPose::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GetPose& GetPose::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_GetPose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void GetPose::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.GetPose)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    model_name_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetPose::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string model_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_model_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.GetPose.model_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GetPose::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.GetPose)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string model_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_model_name().data(), static_cast<int>(this->_internal_model_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetPose.model_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_model_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.GetPose)
  return target;
}

size_t GetPose::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.GetPose)
  size_t total_size = 0;

  // required string model_name = 1;
  if (_internal_has_model_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetPose::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.GetPose)
  GOOGLE_DCHECK_NE(&from, this);
  const GetPose* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<GetPose>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.GetPose)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.GetPose)
    MergeFrom(*source);
  }
}

void GetPose::MergeFrom(const GetPose& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.GetPose)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_model_name()) {
    _internal_set_model_name(from._internal_model_name());
  }
}

void GetPose::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.GetPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetPose::CopyFrom(const GetPose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.GetPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetPose::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GetPose::InternalSwap(GetPose* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  model_name_.Swap(&other->model_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata GetPose::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void GetTopicList::InitAsDefaultInstance() {
}
class GetTopicList::_Internal {
 public:
  using HasBits = decltype(std::declval<GetTopicList>()._has_bits_);
  static void set_has_topic_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

GetTopicList::GetTopicList(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.GetTopicList)
}
GetTopicList::GetTopicList(const GetTopicList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  topic_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topic_name()) {
    topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_topic_name(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.GetTopicList)
}

void GetTopicList::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_GetTopicList_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  topic_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

GetTopicList::~GetTopicList() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.GetTopicList)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void GetTopicList::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  topic_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GetTopicList::ArenaDtor(void* object) {
  GetTopicList* _this = reinterpret_cast< GetTopicList* >(object);
  (void)_this;
}
void GetTopicList::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetTopicList::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GetTopicList& GetTopicList::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_GetTopicList_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void GetTopicList::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.GetTopicList)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    topic_name_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetTopicList::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string topic_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_topic_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.GetTopicList.topic_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GetTopicList::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.GetTopicList)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string topic_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_topic_name().data(), static_cast<int>(this->_internal_topic_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetTopicList.topic_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_topic_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.GetTopicList)
  return target;
}

size_t GetTopicList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.GetTopicList)
  size_t total_size = 0;

  // required string topic_name = 1;
  if (_internal_has_topic_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic_name());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetTopicList::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.GetTopicList)
  GOOGLE_DCHECK_NE(&from, this);
  const GetTopicList* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<GetTopicList>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.GetTopicList)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.GetTopicList)
    MergeFrom(*source);
  }
}

void GetTopicList::MergeFrom(const GetTopicList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.GetTopicList)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_topic_name()) {
    _internal_set_topic_name(from._internal_topic_name());
  }
}

void GetTopicList::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.GetTopicList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetTopicList::CopyFrom(const GetTopicList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.GetTopicList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetTopicList::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GetTopicList::InternalSwap(GetTopicList* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  topic_name_.Swap(&other->topic_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata GetTopicList::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TopicList_TopicInfo::InitAsDefaultInstance() {
}
class TopicList_TopicInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TopicList_TopicInfo>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TopicList_TopicInfo::TopicList_TopicInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
}
TopicList_TopicInfo::TopicList_TopicInfo(const TopicList_TopicInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_type()) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_type(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
}

void TopicList_TopicInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TopicList_TopicInfo_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

TopicList_TopicInfo::~TopicList_TopicInfo() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TopicList_TopicInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TopicList_TopicInfo::ArenaDtor(void* object) {
  TopicList_TopicInfo* _this = reinterpret_cast< TopicList_TopicInfo* >(object);
  (void)_this;
}
void TopicList_TopicInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TopicList_TopicInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TopicList_TopicInfo& TopicList_TopicInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TopicList_TopicInfo_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void TopicList_TopicInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      type_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TopicList_TopicInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TopicList_TopicInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // required string type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
  return target;
}

size_t TopicList_TopicInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
  size_t total_size = 0;

  if (_internal_has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (_internal_has_type()) {
    // required string type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());
  }

  return total_size;
}
size_t TopicList_TopicInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());

    // required string type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TopicList_TopicInfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const TopicList_TopicInfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TopicList_TopicInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
    MergeFrom(*source);
  }
}

void TopicList_TopicInfo::MergeFrom(const TopicList_TopicInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_type(from._internal_type());
    }
  }
}

void TopicList_TopicInfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TopicList_TopicInfo::CopyFrom(const TopicList_TopicInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TopicList_TopicInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TopicList_TopicInfo::InternalSwap(TopicList_TopicInfo* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  type_.Swap(&other->type_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata TopicList_TopicInfo::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TopicList::InitAsDefaultInstance() {
}
class TopicList::_Internal {
 public:
};

TopicList::TopicList(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  data_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.TopicList)
}
TopicList::TopicList(const TopicList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      data_(from.data_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.TopicList)
}

void TopicList::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TopicList_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
}

TopicList::~TopicList() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.TopicList)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TopicList::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TopicList::ArenaDtor(void* object) {
  TopicList* _this = reinterpret_cast< TopicList* >(object);
  (void)_this;
}
void TopicList::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TopicList::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TopicList& TopicList::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TopicList_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void TopicList::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.TopicList)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TopicList::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .mw.internal.robotics.gazebotransport.TopicList.TopicInfo data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_data(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TopicList::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.TopicList)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .mw.internal.robotics.gazebotransport.TopicList.TopicInfo data = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_data_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_data(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.TopicList)
  return target;
}

size_t TopicList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.TopicList)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mw.internal.robotics.gazebotransport.TopicList.TopicInfo data = 1;
  total_size += 1UL * this->_internal_data_size();
  for (const auto& msg : this->data_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TopicList::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.TopicList)
  GOOGLE_DCHECK_NE(&from, this);
  const TopicList* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TopicList>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.TopicList)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.TopicList)
    MergeFrom(*source);
  }
}

void TopicList::MergeFrom(const TopicList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.TopicList)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  data_.MergeFrom(from.data_);
}

void TopicList::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.TopicList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TopicList::CopyFrom(const TopicList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.TopicList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TopicList::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(data_)) return false;
  return true;
}

void TopicList::InternalSwap(TopicList* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  data_.InternalSwap(&other->data_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TopicList::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void GetModelInfo::InitAsDefaultInstance() {
}
class GetModelInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<GetModelInfo>()._has_bits_);
  static void set_has_topic_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

GetModelInfo::GetModelInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.GetModelInfo)
}
GetModelInfo::GetModelInfo(const GetModelInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  topic_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topic_name()) {
    topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_topic_name(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.GetModelInfo)
}

void GetModelInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_GetModelInfo_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  topic_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

GetModelInfo::~GetModelInfo() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.GetModelInfo)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void GetModelInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  topic_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GetModelInfo::ArenaDtor(void* object) {
  GetModelInfo* _this = reinterpret_cast< GetModelInfo* >(object);
  (void)_this;
}
void GetModelInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetModelInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GetModelInfo& GetModelInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_GetModelInfo_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void GetModelInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.GetModelInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    topic_name_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetModelInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string topic_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_topic_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.GetModelInfo.topic_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GetModelInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.GetModelInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string topic_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_topic_name().data(), static_cast<int>(this->_internal_topic_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetModelInfo.topic_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_topic_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.GetModelInfo)
  return target;
}

size_t GetModelInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.GetModelInfo)
  size_t total_size = 0;

  // required string topic_name = 1;
  if (_internal_has_topic_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic_name());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetModelInfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.GetModelInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const GetModelInfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<GetModelInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.GetModelInfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.GetModelInfo)
    MergeFrom(*source);
  }
}

void GetModelInfo::MergeFrom(const GetModelInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.GetModelInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_topic_name()) {
    _internal_set_topic_name(from._internal_topic_name());
  }
}

void GetModelInfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.GetModelInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetModelInfo::CopyFrom(const GetModelInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.GetModelInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetModelInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GetModelInfo::InternalSwap(GetModelInfo* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  topic_name_.Swap(&other->topic_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata GetModelInfo::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ModelInfo_LINKS::InitAsDefaultInstance() {
}
class ModelInfo_LINKS::_Internal {
 public:
};

ModelInfo_LINKS::ModelInfo_LINKS(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  link_name_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
}
ModelInfo_LINKS::ModelInfo_LINKS(const ModelInfo_LINKS& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      link_name_(from.link_name_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
}

void ModelInfo_LINKS::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ModelInfo_LINKS_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
}

ModelInfo_LINKS::~ModelInfo_LINKS() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ModelInfo_LINKS::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void ModelInfo_LINKS::ArenaDtor(void* object) {
  ModelInfo_LINKS* _this = reinterpret_cast< ModelInfo_LINKS* >(object);
  (void)_this;
}
void ModelInfo_LINKS::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelInfo_LINKS::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ModelInfo_LINKS& ModelInfo_LINKS::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ModelInfo_LINKS_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void ModelInfo_LINKS::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  link_name_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelInfo_LINKS::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated string link_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_link_name();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ModelInfo_LINKS::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string link_name = 1;
  for (int i = 0, n = this->_internal_link_name_size(); i < n; i++) {
    const auto& s = this->_internal_link_name(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
  return target;
}

size_t ModelInfo_LINKS::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string link_name = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(link_name_.size());
  for (int i = 0, n = link_name_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      link_name_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ModelInfo_LINKS::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
  GOOGLE_DCHECK_NE(&from, this);
  const ModelInfo_LINKS* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ModelInfo_LINKS>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
    MergeFrom(*source);
  }
}

void ModelInfo_LINKS::MergeFrom(const ModelInfo_LINKS& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  link_name_.MergeFrom(from.link_name_);
}

void ModelInfo_LINKS::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ModelInfo_LINKS::CopyFrom(const ModelInfo_LINKS& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelInfo_LINKS::IsInitialized() const {
  return true;
}

void ModelInfo_LINKS::InternalSwap(ModelInfo_LINKS* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  link_name_.InternalSwap(&other->link_name_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelInfo_LINKS::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ModelInfo_JOINTS::InitAsDefaultInstance() {
}
class ModelInfo_JOINTS::_Internal {
 public:
};

ModelInfo_JOINTS::ModelInfo_JOINTS(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  joint_name_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
}
ModelInfo_JOINTS::ModelInfo_JOINTS(const ModelInfo_JOINTS& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      joint_name_(from.joint_name_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
}

void ModelInfo_JOINTS::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ModelInfo_JOINTS_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
}

ModelInfo_JOINTS::~ModelInfo_JOINTS() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ModelInfo_JOINTS::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void ModelInfo_JOINTS::ArenaDtor(void* object) {
  ModelInfo_JOINTS* _this = reinterpret_cast< ModelInfo_JOINTS* >(object);
  (void)_this;
}
void ModelInfo_JOINTS::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelInfo_JOINTS::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ModelInfo_JOINTS& ModelInfo_JOINTS::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ModelInfo_JOINTS_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void ModelInfo_JOINTS::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  joint_name_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelInfo_JOINTS::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated string joint_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_joint_name();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ModelInfo_JOINTS::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string joint_name = 1;
  for (int i = 0, n = this->_internal_joint_name_size(); i < n; i++) {
    const auto& s = this->_internal_joint_name(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
  return target;
}

size_t ModelInfo_JOINTS::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string joint_name = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(joint_name_.size());
  for (int i = 0, n = joint_name_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      joint_name_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ModelInfo_JOINTS::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
  GOOGLE_DCHECK_NE(&from, this);
  const ModelInfo_JOINTS* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ModelInfo_JOINTS>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
    MergeFrom(*source);
  }
}

void ModelInfo_JOINTS::MergeFrom(const ModelInfo_JOINTS& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  joint_name_.MergeFrom(from.joint_name_);
}

void ModelInfo_JOINTS::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ModelInfo_JOINTS::CopyFrom(const ModelInfo_JOINTS& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelInfo_JOINTS::IsInitialized() const {
  return true;
}

void ModelInfo_JOINTS::InternalSwap(ModelInfo_JOINTS* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  joint_name_.InternalSwap(&other->joint_name_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelInfo_JOINTS::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ModelInfo_Model::InitAsDefaultInstance() {
  ::mw::internal::robotics::gazebotransport::_ModelInfo_Model_default_instance_._instance.get_mutable()->links_ = const_cast< ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS*>(
      ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_ModelInfo_Model_default_instance_._instance.get_mutable()->joints_ = const_cast< ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS*>(
      ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS::internal_default_instance());
}
class ModelInfo_Model::_Internal {
 public:
  using HasBits = decltype(std::declval<ModelInfo_Model>()._has_bits_);
  static void set_has_model_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS& links(const ModelInfo_Model* msg);
  static void set_has_links(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS& joints(const ModelInfo_Model* msg);
  static void set_has_joints(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS&
ModelInfo_Model::_Internal::links(const ModelInfo_Model* msg) {
  return *msg->links_;
}
const ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS&
ModelInfo_Model::_Internal::joints(const ModelInfo_Model* msg) {
  return *msg->joints_;
}
ModelInfo_Model::ModelInfo_Model(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.ModelInfo.Model)
}
ModelInfo_Model::ModelInfo_Model(const ModelInfo_Model& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_model_name()) {
    model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_model_name(),
      GetArena());
  }
  if (from._internal_has_links()) {
    links_ = new ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS(*from.links_);
  } else {
    links_ = nullptr;
  }
  if (from._internal_has_joints()) {
    joints_ = new ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS(*from.joints_);
  } else {
    joints_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ModelInfo.Model)
}

void ModelInfo_Model::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ModelInfo_Model_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&links_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&joints_) -
      reinterpret_cast<char*>(&links_)) + sizeof(joints_));
}

ModelInfo_Model::~ModelInfo_Model() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ModelInfo.Model)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ModelInfo_Model::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  model_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete links_;
  if (this != internal_default_instance()) delete joints_;
}

void ModelInfo_Model::ArenaDtor(void* object) {
  ModelInfo_Model* _this = reinterpret_cast< ModelInfo_Model* >(object);
  (void)_this;
}
void ModelInfo_Model::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelInfo_Model::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ModelInfo_Model& ModelInfo_Model::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ModelInfo_Model_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void ModelInfo_Model::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ModelInfo.Model)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      model_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(links_ != nullptr);
      links_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(joints_ != nullptr);
      joints_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelInfo_Model::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string model_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_model_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mw.internal.robotics.gazebotransport.ModelInfo.LINKS links = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_links(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mw.internal.robotics.gazebotransport.ModelInfo.JOINTS joints = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_joints(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ModelInfo_Model::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ModelInfo.Model)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string model_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_model_name().data(), static_cast<int>(this->_internal_model_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_model_name(), target);
  }

  // optional .mw.internal.robotics.gazebotransport.ModelInfo.LINKS links = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::links(this), target, stream);
  }

  // optional .mw.internal.robotics.gazebotransport.ModelInfo.JOINTS joints = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::joints(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ModelInfo.Model)
  return target;
}

size_t ModelInfo_Model::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ModelInfo.Model)
  size_t total_size = 0;

  // required string model_name = 1;
  if (_internal_has_model_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .mw.internal.robotics.gazebotransport.ModelInfo.LINKS links = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *links_);
    }

    // optional .mw.internal.robotics.gazebotransport.ModelInfo.JOINTS joints = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *joints_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ModelInfo_Model::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ModelInfo.Model)
  GOOGLE_DCHECK_NE(&from, this);
  const ModelInfo_Model* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ModelInfo_Model>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ModelInfo.Model)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ModelInfo.Model)
    MergeFrom(*source);
  }
}

void ModelInfo_Model::MergeFrom(const ModelInfo_Model& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ModelInfo.Model)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_model_name(from._internal_model_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_links()->::mw::internal::robotics::gazebotransport::ModelInfo_LINKS::MergeFrom(from._internal_links());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_joints()->::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS::MergeFrom(from._internal_joints());
    }
  }
}

void ModelInfo_Model::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ModelInfo.Model)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ModelInfo_Model::CopyFrom(const ModelInfo_Model& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ModelInfo.Model)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelInfo_Model::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ModelInfo_Model::InternalSwap(ModelInfo_Model* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  model_name_.Swap(&other->model_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelInfo_Model, joints_)
      + sizeof(ModelInfo_Model::joints_)
      - PROTOBUF_FIELD_OFFSET(ModelInfo_Model, links_)>(
          reinterpret_cast<char*>(&links_),
          reinterpret_cast<char*>(&other->links_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelInfo_Model::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ModelInfo::InitAsDefaultInstance() {
}
class ModelInfo::_Internal {
 public:
};

ModelInfo::ModelInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  model_data_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.ModelInfo)
}
ModelInfo::ModelInfo(const ModelInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      model_data_(from.model_data_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ModelInfo)
}

void ModelInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ModelInfo_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
}

ModelInfo::~ModelInfo() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ModelInfo)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ModelInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void ModelInfo::ArenaDtor(void* object) {
  ModelInfo* _this = reinterpret_cast< ModelInfo* >(object);
  (void)_this;
}
void ModelInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ModelInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ModelInfo& ModelInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ModelInfo_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void ModelInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ModelInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  model_data_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .mw.internal.robotics.gazebotransport.ModelInfo.Model model_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_model_data(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ModelInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ModelInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .mw.internal.robotics.gazebotransport.ModelInfo.Model model_data = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_model_data_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_model_data(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ModelInfo)
  return target;
}

size_t ModelInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ModelInfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mw.internal.robotics.gazebotransport.ModelInfo.Model model_data = 1;
  total_size += 1UL * this->_internal_model_data_size();
  for (const auto& msg : this->model_data_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ModelInfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ModelInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const ModelInfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ModelInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ModelInfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ModelInfo)
    MergeFrom(*source);
  }
}

void ModelInfo::MergeFrom(const ModelInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ModelInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  model_data_.MergeFrom(from.model_data_);
}

void ModelInfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ModelInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ModelInfo::CopyFrom(const ModelInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ModelInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelInfo::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(model_data_)) return false;
  return true;
}

void ModelInfo::InternalSwap(ModelInfo* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  model_data_.InternalSwap(&other->model_data_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelInfo::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void MaxStepSize::InitAsDefaultInstance() {
}
class MaxStepSize::_Internal {
 public:
  using HasBits = decltype(std::declval<MaxStepSize>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

MaxStepSize::MaxStepSize(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.MaxStepSize)
}
MaxStepSize::MaxStepSize(const MaxStepSize& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&size_, &from.size_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&size_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.MaxStepSize)
}

void MaxStepSize::SharedCtor() {
  ::memset(&size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&size_)) + sizeof(type_));
}

MaxStepSize::~MaxStepSize() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.MaxStepSize)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void MaxStepSize::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void MaxStepSize::ArenaDtor(void* object) {
  MaxStepSize* _this = reinterpret_cast< MaxStepSize* >(object);
  (void)_this;
}
void MaxStepSize::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MaxStepSize::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MaxStepSize& MaxStepSize::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MaxStepSize_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void MaxStepSize::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.MaxStepSize)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&type_) -
        reinterpret_cast<char*>(&size_)) + sizeof(type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MaxStepSize::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .mw.internal.robotics.gazebotransport.MaxStepSize.TYPE type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE_IsValid(val))) {
            _internal_set_type(static_cast<::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // required double size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_size(&has_bits);
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MaxStepSize::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.MaxStepSize)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .mw.internal.robotics.gazebotransport.MaxStepSize.TYPE type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // required double size = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.MaxStepSize)
  return target;
}

size_t MaxStepSize::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.MaxStepSize)
  size_t total_size = 0;

  if (_internal_has_size()) {
    // required double size = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_type()) {
    // required .mw.internal.robotics.gazebotransport.MaxStepSize.TYPE type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t MaxStepSize::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.MaxStepSize)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required double size = 2;
    total_size += 1 + 8;

    // required .mw.internal.robotics.gazebotransport.MaxStepSize.TYPE type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MaxStepSize::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.MaxStepSize)
  GOOGLE_DCHECK_NE(&from, this);
  const MaxStepSize* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MaxStepSize>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.MaxStepSize)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.MaxStepSize)
    MergeFrom(*source);
  }
}

void MaxStepSize::MergeFrom(const MaxStepSize& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.MaxStepSize)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      size_ = from.size_;
    }
    if (cached_has_bits & 0x00000002u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MaxStepSize::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.MaxStepSize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MaxStepSize::CopyFrom(const MaxStepSize& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.MaxStepSize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MaxStepSize::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void MaxStepSize::InternalSwap(MaxStepSize* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MaxStepSize, type_)
      + sizeof(MaxStepSize::type_)
      - PROTOBUF_FIELD_OFFSET(MaxStepSize, size_)>(
          reinterpret_cast<char*>(&size_),
          reinterpret_cast<char*>(&other->size_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MaxStepSize::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void InitCustomPublisher::InitAsDefaultInstance() {
}
class InitCustomPublisher::_Internal {
 public:
  using HasBits = decltype(std::declval<InitCustomPublisher>()._has_bits_);
  static void set_has_topic_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_message_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

InitCustomPublisher::InitCustomPublisher(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.InitCustomPublisher)
}
InitCustomPublisher::InitCustomPublisher(const InitCustomPublisher& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  topic_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topic_name()) {
    topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_topic_name(),
      GetArena());
  }
  message_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_message_type()) {
    message_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_message_type(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.InitCustomPublisher)
}

void InitCustomPublisher::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_InitCustomPublisher_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  topic_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  message_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

InitCustomPublisher::~InitCustomPublisher() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.InitCustomPublisher)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void InitCustomPublisher::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  topic_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  message_type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void InitCustomPublisher::ArenaDtor(void* object) {
  InitCustomPublisher* _this = reinterpret_cast< InitCustomPublisher* >(object);
  (void)_this;
}
void InitCustomPublisher::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void InitCustomPublisher::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const InitCustomPublisher& InitCustomPublisher::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_InitCustomPublisher_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void InitCustomPublisher::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.InitCustomPublisher)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      topic_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      message_type_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InitCustomPublisher::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string topic_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_topic_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string message_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_message_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* InitCustomPublisher::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.InitCustomPublisher)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string topic_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_topic_name().data(), static_cast<int>(this->_internal_topic_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_topic_name(), target);
  }

  // required string message_type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_message_type().data(), static_cast<int>(this->_internal_message_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_message_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.InitCustomPublisher)
  return target;
}

size_t InitCustomPublisher::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.InitCustomPublisher)
  size_t total_size = 0;

  if (_internal_has_topic_name()) {
    // required string topic_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic_name());
  }

  if (_internal_has_message_type()) {
    // required string message_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message_type());
  }

  return total_size;
}
size_t InitCustomPublisher::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.InitCustomPublisher)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string topic_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic_name());

    // required string message_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InitCustomPublisher::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.InitCustomPublisher)
  GOOGLE_DCHECK_NE(&from, this);
  const InitCustomPublisher* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<InitCustomPublisher>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.InitCustomPublisher)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.InitCustomPublisher)
    MergeFrom(*source);
  }
}

void InitCustomPublisher::MergeFrom(const InitCustomPublisher& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.InitCustomPublisher)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_topic_name(from._internal_topic_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_message_type(from._internal_message_type());
    }
  }
}

void InitCustomPublisher::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.InitCustomPublisher)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InitCustomPublisher::CopyFrom(const InitCustomPublisher& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.InitCustomPublisher)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitCustomPublisher::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void InitCustomPublisher::InternalSwap(InitCustomPublisher* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  topic_name_.Swap(&other->topic_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  message_type_.Swap(&other->message_type_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata InitCustomPublisher::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void InitCustomSubscriber::InitAsDefaultInstance() {
}
class InitCustomSubscriber::_Internal {
 public:
  using HasBits = decltype(std::declval<InitCustomSubscriber>()._has_bits_);
  static void set_has_topic_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_message_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

InitCustomSubscriber::InitCustomSubscriber(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
}
InitCustomSubscriber::InitCustomSubscriber(const InitCustomSubscriber& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  topic_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topic_name()) {
    topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_topic_name(),
      GetArena());
  }
  message_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_message_type()) {
    message_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_message_type(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
}

void InitCustomSubscriber::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_InitCustomSubscriber_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  topic_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  message_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

InitCustomSubscriber::~InitCustomSubscriber() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void InitCustomSubscriber::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  topic_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  message_type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void InitCustomSubscriber::ArenaDtor(void* object) {
  InitCustomSubscriber* _this = reinterpret_cast< InitCustomSubscriber* >(object);
  (void)_this;
}
void InitCustomSubscriber::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void InitCustomSubscriber::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const InitCustomSubscriber& InitCustomSubscriber::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_InitCustomSubscriber_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void InitCustomSubscriber::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      topic_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      message_type_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InitCustomSubscriber::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string topic_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_topic_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string message_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_message_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* InitCustomSubscriber::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string topic_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_topic_name().data(), static_cast<int>(this->_internal_topic_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_topic_name(), target);
  }

  // required string message_type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_message_type().data(), static_cast<int>(this->_internal_message_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_message_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
  return target;
}

size_t InitCustomSubscriber::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
  size_t total_size = 0;

  if (_internal_has_topic_name()) {
    // required string topic_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic_name());
  }

  if (_internal_has_message_type()) {
    // required string message_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message_type());
  }

  return total_size;
}
size_t InitCustomSubscriber::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string topic_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic_name());

    // required string message_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InitCustomSubscriber::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
  GOOGLE_DCHECK_NE(&from, this);
  const InitCustomSubscriber* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<InitCustomSubscriber>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
    MergeFrom(*source);
  }
}

void InitCustomSubscriber::MergeFrom(const InitCustomSubscriber& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_topic_name(from._internal_topic_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_message_type(from._internal_message_type());
    }
  }
}

void InitCustomSubscriber::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InitCustomSubscriber::CopyFrom(const InitCustomSubscriber& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitCustomSubscriber::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void InitCustomSubscriber::InternalSwap(InitCustomSubscriber* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  topic_name_.Swap(&other->topic_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  message_type_.Swap(&other->message_type_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata InitCustomSubscriber::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void CustomMessageSupport::InitAsDefaultInstance() {
}
class CustomMessageSupport::_Internal {
 public:
  using HasBits = decltype(std::declval<CustomMessageSupport>()._has_bits_);
  static void set_has_topic_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_message_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_new(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

CustomMessageSupport::CustomMessageSupport(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.CustomMessageSupport)
}
CustomMessageSupport::CustomMessageSupport(const CustomMessageSupport& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  topic_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topic_name()) {
    topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_topic_name(),
      GetArena());
  }
  message_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_message_type()) {
    message_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_message_type(),
      GetArena());
  }
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_data()) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_data(),
      GetArena());
  }
  is_new_ = from.is_new_;
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.CustomMessageSupport)
}

void CustomMessageSupport::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_CustomMessageSupport_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  topic_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  message_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  is_new_ = false;
}

CustomMessageSupport::~CustomMessageSupport() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.CustomMessageSupport)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CustomMessageSupport::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  topic_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  message_type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CustomMessageSupport::ArenaDtor(void* object) {
  CustomMessageSupport* _this = reinterpret_cast< CustomMessageSupport* >(object);
  (void)_this;
}
void CustomMessageSupport::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CustomMessageSupport::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CustomMessageSupport& CustomMessageSupport::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CustomMessageSupport_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void CustomMessageSupport::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.CustomMessageSupport)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      topic_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      message_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      data_.ClearNonDefaultToEmpty();
    }
  }
  is_new_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CustomMessageSupport::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string topic_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_topic_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string message_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_message_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_new = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_is_new(&has_bits);
          is_new_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CustomMessageSupport::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.CustomMessageSupport)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string topic_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_topic_name().data(), static_cast<int>(this->_internal_topic_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_topic_name(), target);
  }

  // required string message_type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_message_type().data(), static_cast<int>(this->_internal_message_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_message_type(), target);
  }

  // required bytes data = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_data(), target);
  }

  // optional bool is_new = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_is_new(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.CustomMessageSupport)
  return target;
}

size_t CustomMessageSupport::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.CustomMessageSupport)
  size_t total_size = 0;

  if (_internal_has_topic_name()) {
    // required string topic_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic_name());
  }

  if (_internal_has_message_type()) {
    // required string message_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message_type());
  }

  if (_internal_has_data()) {
    // required bytes data = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  return total_size;
}
size_t CustomMessageSupport::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.CustomMessageSupport)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string topic_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic_name());

    // required string message_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message_type());

    // required bytes data = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool is_new = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000008u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CustomMessageSupport::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.CustomMessageSupport)
  GOOGLE_DCHECK_NE(&from, this);
  const CustomMessageSupport* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CustomMessageSupport>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.CustomMessageSupport)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.CustomMessageSupport)
    MergeFrom(*source);
  }
}

void CustomMessageSupport::MergeFrom(const CustomMessageSupport& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.CustomMessageSupport)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_topic_name(from._internal_topic_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_message_type(from._internal_message_type());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000008u) {
      is_new_ = from.is_new_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CustomMessageSupport::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.CustomMessageSupport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CustomMessageSupport::CopyFrom(const CustomMessageSupport& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.CustomMessageSupport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CustomMessageSupport::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CustomMessageSupport::InternalSwap(CustomMessageSupport* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  topic_name_.Swap(&other->topic_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  message_type_.Swap(&other->message_type_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  data_.Swap(&other->data_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(is_new_, other->is_new_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CustomMessageSupport::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void RequestCustomMessageSupport::InitAsDefaultInstance() {
}
class RequestCustomMessageSupport::_Internal {
 public:
  using HasBits = decltype(std::declval<RequestCustomMessageSupport>()._has_bits_);
  static void set_has_topic_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_message_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

RequestCustomMessageSupport::RequestCustomMessageSupport(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
}
RequestCustomMessageSupport::RequestCustomMessageSupport(const RequestCustomMessageSupport& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  topic_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topic_name()) {
    topic_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_topic_name(),
      GetArena());
  }
  message_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_message_type()) {
    message_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_message_type(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
}

void RequestCustomMessageSupport::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RequestCustomMessageSupport_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  topic_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  message_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

RequestCustomMessageSupport::~RequestCustomMessageSupport() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void RequestCustomMessageSupport::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  topic_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  message_type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void RequestCustomMessageSupport::ArenaDtor(void* object) {
  RequestCustomMessageSupport* _this = reinterpret_cast< RequestCustomMessageSupport* >(object);
  (void)_this;
}
void RequestCustomMessageSupport::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RequestCustomMessageSupport::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RequestCustomMessageSupport& RequestCustomMessageSupport::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RequestCustomMessageSupport_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void RequestCustomMessageSupport::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      topic_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      message_type_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestCustomMessageSupport::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string topic_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_topic_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string message_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_message_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RequestCustomMessageSupport::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string topic_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_topic_name().data(), static_cast<int>(this->_internal_topic_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_topic_name(), target);
  }

  // required string message_type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_message_type().data(), static_cast<int>(this->_internal_message_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_message_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
  return target;
}

size_t RequestCustomMessageSupport::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
  size_t total_size = 0;

  if (_internal_has_topic_name()) {
    // required string topic_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic_name());
  }

  if (_internal_has_message_type()) {
    // required string message_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message_type());
  }

  return total_size;
}
size_t RequestCustomMessageSupport::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string topic_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic_name());

    // required string message_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RequestCustomMessageSupport::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
  GOOGLE_DCHECK_NE(&from, this);
  const RequestCustomMessageSupport* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<RequestCustomMessageSupport>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
    MergeFrom(*source);
  }
}

void RequestCustomMessageSupport::MergeFrom(const RequestCustomMessageSupport& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_topic_name(from._internal_topic_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_message_type(from._internal_message_type());
    }
  }
}

void RequestCustomMessageSupport::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RequestCustomMessageSupport::CopyFrom(const RequestCustomMessageSupport& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestCustomMessageSupport::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void RequestCustomMessageSupport::InternalSwap(RequestCustomMessageSupport* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  topic_name_.Swap(&other->topic_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  message_type_.Swap(&other->message_type_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestCustomMessageSupport::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void SetJointPosition::InitAsDefaultInstance() {
  ::mw::internal::robotics::gazebotransport::_SetJointPosition_default_instance_._instance.get_mutable()->duration_ = const_cast< ::mw::internal::robotics::gazebotransport::Time*>(
      ::mw::internal::robotics::gazebotransport::Time::internal_default_instance());
}
class SetJointPosition::_Internal {
 public:
  using HasBits = decltype(std::declval<SetJointPosition>()._has_bits_);
  static void set_has_model_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_joint_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::mw::internal::robotics::gazebotransport::Time& duration(const SetJointPosition* msg);
  static void set_has_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::mw::internal::robotics::gazebotransport::Time&
SetJointPosition::_Internal::duration(const SetJointPosition* msg) {
  return *msg->duration_;
}
SetJointPosition::SetJointPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.SetJointPosition)
}
SetJointPosition::SetJointPosition(const SetJointPosition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_model_name()) {
    model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_model_name(),
      GetArena());
  }
  joint_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_joint_name()) {
    joint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_joint_name(),
      GetArena());
  }
  if (from._internal_has_duration()) {
    duration_ = new ::mw::internal::robotics::gazebotransport::Time(*from.duration_);
  } else {
    duration_ = nullptr;
  }
  ::memcpy(&position_, &from.position_,
    static_cast<size_t>(reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&position_)) + sizeof(index_));
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.SetJointPosition)
}

void SetJointPosition::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SetJointPosition_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  joint_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&duration_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&index_) -
      reinterpret_cast<char*>(&duration_)) + sizeof(index_));
}

SetJointPosition::~SetJointPosition() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.SetJointPosition)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SetJointPosition::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  model_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  joint_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete duration_;
}

void SetJointPosition::ArenaDtor(void* object) {
  SetJointPosition* _this = reinterpret_cast< SetJointPosition* >(object);
  (void)_this;
}
void SetJointPosition::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SetJointPosition::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SetJointPosition& SetJointPosition::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SetJointPosition_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void SetJointPosition::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.SetJointPosition)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      model_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      joint_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(duration_ != nullptr);
      duration_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&position_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&index_) -
        reinterpret_cast<char*>(&position_)) + sizeof(index_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetJointPosition::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string model_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_model_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.SetJointPosition.model_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string joint_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_joint_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.SetJointPosition.joint_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required double position = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_position(&has_bits);
          position_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required .mw.internal.robotics.gazebotransport.Time duration = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_duration(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SetJointPosition::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.SetJointPosition)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string model_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_model_name().data(), static_cast<int>(this->_internal_model_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetJointPosition.model_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_model_name(), target);
  }

  // required string joint_name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_joint_name().data(), static_cast<int>(this->_internal_joint_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetJointPosition.joint_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_joint_name(), target);
  }

  // required uint32 index = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_index(), target);
  }

  // required double position = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_position(), target);
  }

  // required .mw.internal.robotics.gazebotransport.Time duration = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::duration(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.SetJointPosition)
  return target;
}

size_t SetJointPosition::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.SetJointPosition)
  size_t total_size = 0;

  if (_internal_has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());
  }

  if (_internal_has_joint_name()) {
    // required string joint_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_joint_name());
  }

  if (_internal_has_duration()) {
    // required .mw.internal.robotics.gazebotransport.Time duration = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *duration_);
  }

  if (_internal_has_position()) {
    // required double position = 4;
    total_size += 1 + 8;
  }

  if (_internal_has_index()) {
    // required uint32 index = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_index());
  }

  return total_size;
}
size_t SetJointPosition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.SetJointPosition)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());

    // required string joint_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_joint_name());

    // required .mw.internal.robotics.gazebotransport.Time duration = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *duration_);

    // required double position = 4;
    total_size += 1 + 8;

    // required uint32 index = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_index());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SetJointPosition::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.SetJointPosition)
  GOOGLE_DCHECK_NE(&from, this);
  const SetJointPosition* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SetJointPosition>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.SetJointPosition)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.SetJointPosition)
    MergeFrom(*source);
  }
}

void SetJointPosition::MergeFrom(const SetJointPosition& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.SetJointPosition)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_model_name(from._internal_model_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_joint_name(from._internal_joint_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_duration()->::mw::internal::robotics::gazebotransport::Time::MergeFrom(from._internal_duration());
    }
    if (cached_has_bits & 0x00000008u) {
      position_ = from.position_;
    }
    if (cached_has_bits & 0x00000010u) {
      index_ = from.index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SetJointPosition::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.SetJointPosition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SetJointPosition::CopyFrom(const SetJointPosition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.SetJointPosition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetJointPosition::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_duration()) {
    if (!duration_->IsInitialized()) return false;
  }
  return true;
}

void SetJointPosition::InternalSwap(SetJointPosition* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  model_name_.Swap(&other->model_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  joint_name_.Swap(&other->joint_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SetJointPosition, index_)
      + sizeof(SetJointPosition::index_)
      - PROTOBUF_FIELD_OFFSET(SetJointPosition, duration_)>(
          reinterpret_cast<char*>(&duration_),
          reinterpret_cast<char*>(&other->duration_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SetJointPosition::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void SetJointVelocity::InitAsDefaultInstance() {
  ::mw::internal::robotics::gazebotransport::_SetJointVelocity_default_instance_._instance.get_mutable()->duration_ = const_cast< ::mw::internal::robotics::gazebotransport::Time*>(
      ::mw::internal::robotics::gazebotransport::Time::internal_default_instance());
}
class SetJointVelocity::_Internal {
 public:
  using HasBits = decltype(std::declval<SetJointVelocity>()._has_bits_);
  static void set_has_model_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_joint_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::mw::internal::robotics::gazebotransport::Time& duration(const SetJointVelocity* msg);
  static void set_has_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::mw::internal::robotics::gazebotransport::Time&
SetJointVelocity::_Internal::duration(const SetJointVelocity* msg) {
  return *msg->duration_;
}
SetJointVelocity::SetJointVelocity(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.SetJointVelocity)
}
SetJointVelocity::SetJointVelocity(const SetJointVelocity& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_model_name()) {
    model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_model_name(),
      GetArena());
  }
  joint_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_joint_name()) {
    joint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_joint_name(),
      GetArena());
  }
  if (from._internal_has_duration()) {
    duration_ = new ::mw::internal::robotics::gazebotransport::Time(*from.duration_);
  } else {
    duration_ = nullptr;
  }
  ::memcpy(&velocity_, &from.velocity_,
    static_cast<size_t>(reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&velocity_)) + sizeof(index_));
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.SetJointVelocity)
}

void SetJointVelocity::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SetJointVelocity_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  joint_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&duration_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&index_) -
      reinterpret_cast<char*>(&duration_)) + sizeof(index_));
}

SetJointVelocity::~SetJointVelocity() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.SetJointVelocity)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SetJointVelocity::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  model_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  joint_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete duration_;
}

void SetJointVelocity::ArenaDtor(void* object) {
  SetJointVelocity* _this = reinterpret_cast< SetJointVelocity* >(object);
  (void)_this;
}
void SetJointVelocity::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SetJointVelocity::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SetJointVelocity& SetJointVelocity::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SetJointVelocity_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void SetJointVelocity::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.SetJointVelocity)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      model_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      joint_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(duration_ != nullptr);
      duration_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&velocity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&index_) -
        reinterpret_cast<char*>(&velocity_)) + sizeof(index_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetJointVelocity::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string model_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_model_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.SetJointVelocity.model_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string joint_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_joint_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required double velocity = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_velocity(&has_bits);
          velocity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required .mw.internal.robotics.gazebotransport.Time duration = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_duration(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SetJointVelocity::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.SetJointVelocity)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string model_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_model_name().data(), static_cast<int>(this->_internal_model_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetJointVelocity.model_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_model_name(), target);
  }

  // required string joint_name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_joint_name().data(), static_cast<int>(this->_internal_joint_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_joint_name(), target);
  }

  // required uint32 index = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_index(), target);
  }

  // required double velocity = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_velocity(), target);
  }

  // required .mw.internal.robotics.gazebotransport.Time duration = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::duration(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.SetJointVelocity)
  return target;
}

size_t SetJointVelocity::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.SetJointVelocity)
  size_t total_size = 0;

  if (_internal_has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());
  }

  if (_internal_has_joint_name()) {
    // required string joint_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_joint_name());
  }

  if (_internal_has_duration()) {
    // required .mw.internal.robotics.gazebotransport.Time duration = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *duration_);
  }

  if (_internal_has_velocity()) {
    // required double velocity = 4;
    total_size += 1 + 8;
  }

  if (_internal_has_index()) {
    // required uint32 index = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_index());
  }

  return total_size;
}
size_t SetJointVelocity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.SetJointVelocity)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());

    // required string joint_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_joint_name());

    // required .mw.internal.robotics.gazebotransport.Time duration = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *duration_);

    // required double velocity = 4;
    total_size += 1 + 8;

    // required uint32 index = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_index());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SetJointVelocity::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.SetJointVelocity)
  GOOGLE_DCHECK_NE(&from, this);
  const SetJointVelocity* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SetJointVelocity>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.SetJointVelocity)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.SetJointVelocity)
    MergeFrom(*source);
  }
}

void SetJointVelocity::MergeFrom(const SetJointVelocity& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.SetJointVelocity)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_model_name(from._internal_model_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_joint_name(from._internal_joint_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_duration()->::mw::internal::robotics::gazebotransport::Time::MergeFrom(from._internal_duration());
    }
    if (cached_has_bits & 0x00000008u) {
      velocity_ = from.velocity_;
    }
    if (cached_has_bits & 0x00000010u) {
      index_ = from.index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SetJointVelocity::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.SetJointVelocity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SetJointVelocity::CopyFrom(const SetJointVelocity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.SetJointVelocity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetJointVelocity::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_duration()) {
    if (!duration_->IsInitialized()) return false;
  }
  return true;
}

void SetJointVelocity::InternalSwap(SetJointVelocity* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  model_name_.Swap(&other->model_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  joint_name_.Swap(&other->joint_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SetJointVelocity, index_)
      + sizeof(SetJointVelocity::index_)
      - PROTOBUF_FIELD_OFFSET(SetJointVelocity, duration_)>(
          reinterpret_cast<char*>(&duration_),
          reinterpret_cast<char*>(&other->duration_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SetJointVelocity::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void GetJointState::InitAsDefaultInstance() {
}
class GetJointState::_Internal {
 public:
  using HasBits = decltype(std::declval<GetJointState>()._has_bits_);
  static void set_has_model_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_joint_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

GetJointState::GetJointState(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.GetJointState)
}
GetJointState::GetJointState(const GetJointState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_model_name()) {
    model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_model_name(),
      GetArena());
  }
  joint_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_joint_name()) {
    joint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_joint_name(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.GetJointState)
}

void GetJointState::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_GetJointState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  joint_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

GetJointState::~GetJointState() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.GetJointState)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void GetJointState::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  model_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  joint_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GetJointState::ArenaDtor(void* object) {
  GetJointState* _this = reinterpret_cast< GetJointState* >(object);
  (void)_this;
}
void GetJointState::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetJointState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GetJointState& GetJointState::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_GetJointState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void GetJointState::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.GetJointState)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      model_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      joint_name_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetJointState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string model_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_model_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.GetJointState.model_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string joint_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_joint_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.GetJointState.joint_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GetJointState::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.GetJointState)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string model_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_model_name().data(), static_cast<int>(this->_internal_model_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetJointState.model_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_model_name(), target);
  }

  // required string joint_name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_joint_name().data(), static_cast<int>(this->_internal_joint_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetJointState.joint_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_joint_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.GetJointState)
  return target;
}

size_t GetJointState::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.GetJointState)
  size_t total_size = 0;

  if (_internal_has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());
  }

  if (_internal_has_joint_name()) {
    // required string joint_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_joint_name());
  }

  return total_size;
}
size_t GetJointState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.GetJointState)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());

    // required string joint_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_joint_name());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetJointState::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.GetJointState)
  GOOGLE_DCHECK_NE(&from, this);
  const GetJointState* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<GetJointState>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.GetJointState)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.GetJointState)
    MergeFrom(*source);
  }
}

void GetJointState::MergeFrom(const GetJointState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.GetJointState)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_model_name(from._internal_model_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_joint_name(from._internal_joint_name());
    }
  }
}

void GetJointState::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.GetJointState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetJointState::CopyFrom(const GetJointState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.GetJointState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetJointState::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GetJointState::InternalSwap(GetJointState* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  model_name_.Swap(&other->model_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  joint_name_.Swap(&other->joint_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata GetJointState::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Axis::InitAsDefaultInstance() {
  ::mw::internal::robotics::gazebotransport::_Axis_default_instance_._instance.get_mutable()->xyz_ = const_cast< ::mw::internal::robotics::gazebotransport::Point*>(
      ::mw::internal::robotics::gazebotransport::Point::internal_default_instance());
}
class Axis::_Internal {
 public:
  using HasBits = decltype(std::declval<Axis>()._has_bits_);
  static const ::mw::internal::robotics::gazebotransport::Point& xyz(const Axis* msg);
  static void set_has_xyz(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_limit_lower(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_limit_upper(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_limit_effort(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_limit_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_damping(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_friction(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_use_parent_model_frame(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x000000ff) ^ 0x000000ff) != 0;
  }
};

const ::mw::internal::robotics::gazebotransport::Point&
Axis::_Internal::xyz(const Axis* msg) {
  return *msg->xyz_;
}
Axis::Axis(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.Axis)
}
Axis::Axis(const Axis& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_xyz()) {
    xyz_ = new ::mw::internal::robotics::gazebotransport::Point(*from.xyz_);
  } else {
    xyz_ = nullptr;
  }
  ::memcpy(&limit_lower_, &from.limit_lower_,
    static_cast<size_t>(reinterpret_cast<char*>(&use_parent_model_frame_) -
    reinterpret_cast<char*>(&limit_lower_)) + sizeof(use_parent_model_frame_));
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.Axis)
}

void Axis::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Axis_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  ::memset(&xyz_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&use_parent_model_frame_) -
      reinterpret_cast<char*>(&xyz_)) + sizeof(use_parent_model_frame_));
}

Axis::~Axis() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.Axis)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Axis::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete xyz_;
}

void Axis::ArenaDtor(void* object) {
  Axis* _this = reinterpret_cast< Axis* >(object);
  (void)_this;
}
void Axis::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Axis::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Axis& Axis::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Axis_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void Axis::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.Axis)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(xyz_ != nullptr);
    xyz_->Clear();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&limit_lower_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&use_parent_model_frame_) -
        reinterpret_cast<char*>(&limit_lower_)) + sizeof(use_parent_model_frame_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Axis::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .mw.internal.robotics.gazebotransport.Point xyz = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_xyz(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required double limit_lower = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_limit_lower(&has_bits);
          limit_lower_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double limit_upper = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_limit_upper(&has_bits);
          limit_upper_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double limit_effort = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_limit_effort(&has_bits);
          limit_effort_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double limit_velocity = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _Internal::set_has_limit_velocity(&has_bits);
          limit_velocity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double damping = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 49)) {
          _Internal::set_has_damping(&has_bits);
          damping_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double friction = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 57)) {
          _Internal::set_has_friction(&has_bits);
          friction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required bool use_parent_model_frame = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_use_parent_model_frame(&has_bits);
          use_parent_model_frame_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Axis::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.Axis)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .mw.internal.robotics.gazebotransport.Point xyz = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::xyz(this), target, stream);
  }

  // required double limit_lower = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_limit_lower(), target);
  }

  // required double limit_upper = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_limit_upper(), target);
  }

  // required double limit_effort = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_limit_effort(), target);
  }

  // required double limit_velocity = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_limit_velocity(), target);
  }

  // required double damping = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(6, this->_internal_damping(), target);
  }

  // required double friction = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(7, this->_internal_friction(), target);
  }

  // required bool use_parent_model_frame = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_use_parent_model_frame(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.Axis)
  return target;
}

size_t Axis::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.Axis)
  size_t total_size = 0;

  if (_internal_has_xyz()) {
    // required .mw.internal.robotics.gazebotransport.Point xyz = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *xyz_);
  }

  if (_internal_has_limit_lower()) {
    // required double limit_lower = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_limit_upper()) {
    // required double limit_upper = 3;
    total_size += 1 + 8;
  }

  if (_internal_has_limit_effort()) {
    // required double limit_effort = 4;
    total_size += 1 + 8;
  }

  if (_internal_has_limit_velocity()) {
    // required double limit_velocity = 5;
    total_size += 1 + 8;
  }

  if (_internal_has_damping()) {
    // required double damping = 6;
    total_size += 1 + 8;
  }

  if (_internal_has_friction()) {
    // required double friction = 7;
    total_size += 1 + 8;
  }

  if (_internal_has_use_parent_model_frame()) {
    // required bool use_parent_model_frame = 8;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t Axis::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.Axis)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x000000ff) ^ 0x000000ff) == 0) {  // All required fields are present.
    // required .mw.internal.robotics.gazebotransport.Point xyz = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *xyz_);

    // required double limit_lower = 2;
    total_size += 1 + 8;

    // required double limit_upper = 3;
    total_size += 1 + 8;

    // required double limit_effort = 4;
    total_size += 1 + 8;

    // required double limit_velocity = 5;
    total_size += 1 + 8;

    // required double damping = 6;
    total_size += 1 + 8;

    // required double friction = 7;
    total_size += 1 + 8;

    // required bool use_parent_model_frame = 8;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Axis::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.Axis)
  GOOGLE_DCHECK_NE(&from, this);
  const Axis* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Axis>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.Axis)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.Axis)
    MergeFrom(*source);
  }
}

void Axis::MergeFrom(const Axis& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.Axis)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_xyz()->::mw::internal::robotics::gazebotransport::Point::MergeFrom(from._internal_xyz());
    }
    if (cached_has_bits & 0x00000002u) {
      limit_lower_ = from.limit_lower_;
    }
    if (cached_has_bits & 0x00000004u) {
      limit_upper_ = from.limit_upper_;
    }
    if (cached_has_bits & 0x00000008u) {
      limit_effort_ = from.limit_effort_;
    }
    if (cached_has_bits & 0x00000010u) {
      limit_velocity_ = from.limit_velocity_;
    }
    if (cached_has_bits & 0x00000020u) {
      damping_ = from.damping_;
    }
    if (cached_has_bits & 0x00000040u) {
      friction_ = from.friction_;
    }
    if (cached_has_bits & 0x00000080u) {
      use_parent_model_frame_ = from.use_parent_model_frame_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Axis::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.Axis)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Axis::CopyFrom(const Axis& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.Axis)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Axis::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_xyz()) {
    if (!xyz_->IsInitialized()) return false;
  }
  return true;
}

void Axis::InternalSwap(Axis* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Axis, use_parent_model_frame_)
      + sizeof(Axis::use_parent_model_frame_)
      - PROTOBUF_FIELD_OFFSET(Axis, xyz_)>(
          reinterpret_cast<char*>(&xyz_),
          reinterpret_cast<char*>(&other->xyz_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Axis::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void JointState::InitAsDefaultInstance() {
  ::mw::internal::robotics::gazebotransport::_JointState_default_instance_._instance.get_mutable()->initial_anchor_pose_ = const_cast< ::mw::internal::robotics::gazebotransport::Pose*>(
      ::mw::internal::robotics::gazebotransport::Pose::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_JointState_default_instance_._instance.get_mutable()->world_pose_ = const_cast< ::mw::internal::robotics::gazebotransport::Pose*>(
      ::mw::internal::robotics::gazebotransport::Pose::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_JointState_default_instance_._instance.get_mutable()->parent_world_pose_ = const_cast< ::mw::internal::robotics::gazebotransport::Pose*>(
      ::mw::internal::robotics::gazebotransport::Pose::internal_default_instance());
}
class JointState::_Internal {
 public:
  using HasBits = decltype(std::declval<JointState>()._has_bits_);
  static void set_has_model_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_joint_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_joint_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_joint_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_parent_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_parent_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_child_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_child_id(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::mw::internal::robotics::gazebotransport::Pose& initial_anchor_pose(const JointState* msg);
  static void set_has_initial_anchor_pose(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::mw::internal::robotics::gazebotransport::Pose& world_pose(const JointState* msg);
  static void set_has_world_pose(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::mw::internal::robotics::gazebotransport::Pose& parent_world_pose(const JointState* msg);
  static void set_has_parent_world_pose(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000083) ^ 0x00000083) != 0;
  }
};

const ::mw::internal::robotics::gazebotransport::Pose&
JointState::_Internal::initial_anchor_pose(const JointState* msg) {
  return *msg->initial_anchor_pose_;
}
const ::mw::internal::robotics::gazebotransport::Pose&
JointState::_Internal::world_pose(const JointState* msg) {
  return *msg->world_pose_;
}
const ::mw::internal::robotics::gazebotransport::Pose&
JointState::_Internal::parent_world_pose(const JointState* msg) {
  return *msg->parent_world_pose_;
}
JointState::JointState(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  joint_position_(arena),
  joint_velocity_(arena),
  axis_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.JointState)
}
JointState::JointState(const JointState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      joint_position_(from.joint_position_),
      joint_velocity_(from.joint_velocity_),
      axis_(from.axis_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_model_name()) {
    model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_model_name(),
      GetArena());
  }
  joint_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_joint_name()) {
    joint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_joint_name(),
      GetArena());
  }
  parent_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_parent_name()) {
    parent_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_parent_name(),
      GetArena());
  }
  child_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_child_name()) {
    child_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_child_name(),
      GetArena());
  }
  if (from._internal_has_initial_anchor_pose()) {
    initial_anchor_pose_ = new ::mw::internal::robotics::gazebotransport::Pose(*from.initial_anchor_pose_);
  } else {
    initial_anchor_pose_ = nullptr;
  }
  if (from._internal_has_world_pose()) {
    world_pose_ = new ::mw::internal::robotics::gazebotransport::Pose(*from.world_pose_);
  } else {
    world_pose_ = nullptr;
  }
  if (from._internal_has_parent_world_pose()) {
    parent_world_pose_ = new ::mw::internal::robotics::gazebotransport::Pose(*from.parent_world_pose_);
  } else {
    parent_world_pose_ = nullptr;
  }
  ::memcpy(&joint_id_, &from.joint_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&joint_type_) -
    reinterpret_cast<char*>(&joint_id_)) + sizeof(joint_type_));
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.JointState)
}

void JointState::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_JointState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  joint_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  parent_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  child_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&initial_anchor_pose_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&child_id_) -
      reinterpret_cast<char*>(&initial_anchor_pose_)) + sizeof(child_id_));
  joint_type_ = 1;
}

JointState::~JointState() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.JointState)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void JointState::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  model_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  joint_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  parent_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  child_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete initial_anchor_pose_;
  if (this != internal_default_instance()) delete world_pose_;
  if (this != internal_default_instance()) delete parent_world_pose_;
}

void JointState::ArenaDtor(void* object) {
  JointState* _this = reinterpret_cast< JointState* >(object);
  (void)_this;
}
void JointState::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void JointState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const JointState& JointState::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_JointState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void JointState::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.JointState)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  joint_position_.Clear();
  joint_velocity_.Clear();
  axis_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      model_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      joint_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      parent_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      child_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(initial_anchor_pose_ != nullptr);
      initial_anchor_pose_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(world_pose_ != nullptr);
      world_pose_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(parent_world_pose_ != nullptr);
      parent_world_pose_->Clear();
    }
  }
  joint_id_ = 0u;
  if (cached_has_bits & 0x00000700u) {
    ::memset(&parent_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&child_id_) -
        reinterpret_cast<char*>(&parent_id_)) + sizeof(child_id_));
    joint_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* JointState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string model_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_model_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.JointState.model_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string joint_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_joint_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.JointState.joint_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 joint_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_joint_id(&has_bits);
          joint_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated double joint_position = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_joint_position(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<33>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_joint_position(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated double joint_velocity = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_joint_velocity(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<41>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_joint_velocity(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mw.internal.robotics.gazebotransport.JointState.Joint_Type joint_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mw::internal::robotics::gazebotransport::JointState_Joint_Type_IsValid(val))) {
            _internal_set_joint_type(static_cast<::mw::internal::robotics::gazebotransport::JointState_Joint_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string parent_name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          auto str = _internal_mutable_parent_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.JointState.parent_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 parent_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_parent_id(&has_bits);
          parent_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string child_name = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          auto str = _internal_mutable_child_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.JointState.child_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 child_id = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_child_id(&has_bits);
          child_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mw.internal.robotics.gazebotransport.Pose initial_anchor_pose = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_initial_anchor_pose(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mw.internal.robotics.gazebotransport.Pose world_pose = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_world_pose(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mw.internal.robotics.gazebotransport.Pose parent_world_pose = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_parent_world_pose(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .mw.internal.robotics.gazebotransport.Axis axis = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_axis(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<114>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* JointState::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.JointState)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string model_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_model_name().data(), static_cast<int>(this->_internal_model_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.JointState.model_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_model_name(), target);
  }

  // required string joint_name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_joint_name().data(), static_cast<int>(this->_internal_joint_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.JointState.joint_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_joint_name(), target);
  }

  // required uint32 joint_id = 3;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_joint_id(), target);
  }

  // repeated double joint_position = 4;
  for (int i = 0, n = this->_internal_joint_position_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_joint_position(i), target);
  }

  // repeated double joint_velocity = 5;
  for (int i = 0, n = this->_internal_joint_velocity_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_joint_velocity(i), target);
  }

  // optional .mw.internal.robotics.gazebotransport.JointState.Joint_Type joint_type = 6;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_joint_type(), target);
  }

  // optional string parent_name = 7;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_parent_name().data(), static_cast<int>(this->_internal_parent_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.JointState.parent_name");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_parent_name(), target);
  }

  // optional uint32 parent_id = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_parent_id(), target);
  }

  // optional string child_name = 9;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_child_name().data(), static_cast<int>(this->_internal_child_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.JointState.child_name");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_child_name(), target);
  }

  // optional uint32 child_id = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(10, this->_internal_child_id(), target);
  }

  // optional .mw.internal.robotics.gazebotransport.Pose initial_anchor_pose = 11;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::initial_anchor_pose(this), target, stream);
  }

  // optional .mw.internal.robotics.gazebotransport.Pose world_pose = 12;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        12, _Internal::world_pose(this), target, stream);
  }

  // optional .mw.internal.robotics.gazebotransport.Pose parent_world_pose = 13;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        13, _Internal::parent_world_pose(this), target, stream);
  }

  // repeated .mw.internal.robotics.gazebotransport.Axis axis = 14;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_axis_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, this->_internal_axis(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.JointState)
  return target;
}

size_t JointState::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.JointState)
  size_t total_size = 0;

  if (_internal_has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());
  }

  if (_internal_has_joint_name()) {
    // required string joint_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_joint_name());
  }

  if (_internal_has_joint_id()) {
    // required uint32 joint_id = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_joint_id());
  }

  return total_size;
}
size_t JointState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.JointState)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000083) ^ 0x00000083) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());

    // required string joint_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_joint_name());

    // required uint32 joint_id = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_joint_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double joint_position = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_joint_position_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_joint_position_size());
    total_size += data_size;
  }

  // repeated double joint_velocity = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_joint_velocity_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_joint_velocity_size());
    total_size += data_size;
  }

  // repeated .mw.internal.robotics.gazebotransport.Axis axis = 14;
  total_size += 1UL * this->_internal_axis_size();
  for (const auto& msg : this->axis_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007cu) {
    // optional string parent_name = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_parent_name());
    }

    // optional string child_name = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_child_name());
    }

    // optional .mw.internal.robotics.gazebotransport.Pose initial_anchor_pose = 11;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *initial_anchor_pose_);
    }

    // optional .mw.internal.robotics.gazebotransport.Pose world_pose = 12;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *world_pose_);
    }

    // optional .mw.internal.robotics.gazebotransport.Pose parent_world_pose = 13;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *parent_world_pose_);
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional uint32 parent_id = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_parent_id());
    }

    // optional uint32 child_id = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_child_id());
    }

    // optional .mw.internal.robotics.gazebotransport.JointState.Joint_Type joint_type = 6;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_joint_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void JointState::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.JointState)
  GOOGLE_DCHECK_NE(&from, this);
  const JointState* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<JointState>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.JointState)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.JointState)
    MergeFrom(*source);
  }
}

void JointState::MergeFrom(const JointState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.JointState)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  joint_position_.MergeFrom(from.joint_position_);
  joint_velocity_.MergeFrom(from.joint_velocity_);
  axis_.MergeFrom(from.axis_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_model_name(from._internal_model_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_joint_name(from._internal_joint_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_parent_name(from._internal_parent_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_child_name(from._internal_child_name());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_initial_anchor_pose()->::mw::internal::robotics::gazebotransport::Pose::MergeFrom(from._internal_initial_anchor_pose());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_world_pose()->::mw::internal::robotics::gazebotransport::Pose::MergeFrom(from._internal_world_pose());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_parent_world_pose()->::mw::internal::robotics::gazebotransport::Pose::MergeFrom(from._internal_parent_world_pose());
    }
    if (cached_has_bits & 0x00000080u) {
      joint_id_ = from.joint_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      parent_id_ = from.parent_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      child_id_ = from.child_id_;
    }
    if (cached_has_bits & 0x00000400u) {
      joint_type_ = from.joint_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void JointState::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.JointState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void JointState::CopyFrom(const JointState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.JointState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JointState::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(axis_)) return false;
  if (_internal_has_initial_anchor_pose()) {
    if (!initial_anchor_pose_->IsInitialized()) return false;
  }
  if (_internal_has_world_pose()) {
    if (!world_pose_->IsInitialized()) return false;
  }
  if (_internal_has_parent_world_pose()) {
    if (!parent_world_pose_->IsInitialized()) return false;
  }
  return true;
}

void JointState::InternalSwap(JointState* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  joint_position_.InternalSwap(&other->joint_position_);
  joint_velocity_.InternalSwap(&other->joint_velocity_);
  axis_.InternalSwap(&other->axis_);
  model_name_.Swap(&other->model_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  joint_name_.Swap(&other->joint_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  parent_name_.Swap(&other->parent_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  child_name_.Swap(&other->child_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(JointState, child_id_)
      + sizeof(JointState::child_id_)
      - PROTOBUF_FIELD_OFFSET(JointState, initial_anchor_pose_)>(
          reinterpret_cast<char*>(&initial_anchor_pose_),
          reinterpret_cast<char*>(&other->initial_anchor_pose_));
  swap(joint_type_, other->joint_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata JointState::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void SetLinkWorldPose::InitAsDefaultInstance() {
  ::mw::internal::robotics::gazebotransport::_SetLinkWorldPose_default_instance_._instance.get_mutable()->pose_ = const_cast< ::mw::internal::robotics::gazebotransport::Pose*>(
      ::mw::internal::robotics::gazebotransport::Pose::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_SetLinkWorldPose_default_instance_._instance.get_mutable()->duration_ = const_cast< ::mw::internal::robotics::gazebotransport::Time*>(
      ::mw::internal::robotics::gazebotransport::Time::internal_default_instance());
}
class SetLinkWorldPose::_Internal {
 public:
  using HasBits = decltype(std::declval<SetLinkWorldPose>()._has_bits_);
  static void set_has_model_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_link_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::mw::internal::robotics::gazebotransport::Pose& pose(const SetLinkWorldPose* msg);
  static void set_has_pose(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::mw::internal::robotics::gazebotransport::Time& duration(const SetLinkWorldPose* msg);
  static void set_has_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::mw::internal::robotics::gazebotransport::Pose&
SetLinkWorldPose::_Internal::pose(const SetLinkWorldPose* msg) {
  return *msg->pose_;
}
const ::mw::internal::robotics::gazebotransport::Time&
SetLinkWorldPose::_Internal::duration(const SetLinkWorldPose* msg) {
  return *msg->duration_;
}
SetLinkWorldPose::SetLinkWorldPose(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
}
SetLinkWorldPose::SetLinkWorldPose(const SetLinkWorldPose& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_model_name()) {
    model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_model_name(),
      GetArena());
  }
  link_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_link_name()) {
    link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_link_name(),
      GetArena());
  }
  if (from._internal_has_pose()) {
    pose_ = new ::mw::internal::robotics::gazebotransport::Pose(*from.pose_);
  } else {
    pose_ = nullptr;
  }
  if (from._internal_has_duration()) {
    duration_ = new ::mw::internal::robotics::gazebotransport::Time(*from.duration_);
  } else {
    duration_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
}

void SetLinkWorldPose::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SetLinkWorldPose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  link_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&pose_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&duration_) -
      reinterpret_cast<char*>(&pose_)) + sizeof(duration_));
}

SetLinkWorldPose::~SetLinkWorldPose() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SetLinkWorldPose::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  model_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  link_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete pose_;
  if (this != internal_default_instance()) delete duration_;
}

void SetLinkWorldPose::ArenaDtor(void* object) {
  SetLinkWorldPose* _this = reinterpret_cast< SetLinkWorldPose* >(object);
  (void)_this;
}
void SetLinkWorldPose::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SetLinkWorldPose::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SetLinkWorldPose& SetLinkWorldPose::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SetLinkWorldPose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void SetLinkWorldPose::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      model_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      link_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(pose_ != nullptr);
      pose_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(duration_ != nullptr);
      duration_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetLinkWorldPose::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string model_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_model_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string link_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_link_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .mw.internal.robotics.gazebotransport.Pose pose = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_pose(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .mw.internal.robotics.gazebotransport.Time duration = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_duration(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SetLinkWorldPose::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string model_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_model_name().data(), static_cast<int>(this->_internal_model_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_model_name(), target);
  }

  // required string link_name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_link_name().data(), static_cast<int>(this->_internal_link_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_link_name(), target);
  }

  // required .mw.internal.robotics.gazebotransport.Pose pose = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::pose(this), target, stream);
  }

  // required .mw.internal.robotics.gazebotransport.Time duration = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::duration(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
  return target;
}

size_t SetLinkWorldPose::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
  size_t total_size = 0;

  if (_internal_has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());
  }

  if (_internal_has_link_name()) {
    // required string link_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_link_name());
  }

  if (_internal_has_pose()) {
    // required .mw.internal.robotics.gazebotransport.Pose pose = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *pose_);
  }

  if (_internal_has_duration()) {
    // required .mw.internal.robotics.gazebotransport.Time duration = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *duration_);
  }

  return total_size;
}
size_t SetLinkWorldPose::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());

    // required string link_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_link_name());

    // required .mw.internal.robotics.gazebotransport.Pose pose = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *pose_);

    // required .mw.internal.robotics.gazebotransport.Time duration = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *duration_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SetLinkWorldPose::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
  GOOGLE_DCHECK_NE(&from, this);
  const SetLinkWorldPose* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SetLinkWorldPose>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
    MergeFrom(*source);
  }
}

void SetLinkWorldPose::MergeFrom(const SetLinkWorldPose& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_model_name(from._internal_model_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_link_name(from._internal_link_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_pose()->::mw::internal::robotics::gazebotransport::Pose::MergeFrom(from._internal_pose());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_duration()->::mw::internal::robotics::gazebotransport::Time::MergeFrom(from._internal_duration());
    }
  }
}

void SetLinkWorldPose::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SetLinkWorldPose::CopyFrom(const SetLinkWorldPose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetLinkWorldPose::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_pose()) {
    if (!pose_->IsInitialized()) return false;
  }
  if (_internal_has_duration()) {
    if (!duration_->IsInitialized()) return false;
  }
  return true;
}

void SetLinkWorldPose::InternalSwap(SetLinkWorldPose* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  model_name_.Swap(&other->model_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  link_name_.Swap(&other->link_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SetLinkWorldPose, duration_)
      + sizeof(SetLinkWorldPose::duration_)
      - PROTOBUF_FIELD_OFFSET(SetLinkWorldPose, pose_)>(
          reinterpret_cast<char*>(&pose_),
          reinterpret_cast<char*>(&other->pose_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SetLinkWorldPose::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void SetLinkLinearVelocity::InitAsDefaultInstance() {
  ::mw::internal::robotics::gazebotransport::_SetLinkLinearVelocity_default_instance_._instance.get_mutable()->velocity_ = const_cast< ::mw::internal::robotics::gazebotransport::Point*>(
      ::mw::internal::robotics::gazebotransport::Point::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_SetLinkLinearVelocity_default_instance_._instance.get_mutable()->duration_ = const_cast< ::mw::internal::robotics::gazebotransport::Time*>(
      ::mw::internal::robotics::gazebotransport::Time::internal_default_instance());
}
class SetLinkLinearVelocity::_Internal {
 public:
  using HasBits = decltype(std::declval<SetLinkLinearVelocity>()._has_bits_);
  static void set_has_model_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_link_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::mw::internal::robotics::gazebotransport::Point& velocity(const SetLinkLinearVelocity* msg);
  static void set_has_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::mw::internal::robotics::gazebotransport::Time& duration(const SetLinkLinearVelocity* msg);
  static void set_has_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::mw::internal::robotics::gazebotransport::Point&
SetLinkLinearVelocity::_Internal::velocity(const SetLinkLinearVelocity* msg) {
  return *msg->velocity_;
}
const ::mw::internal::robotics::gazebotransport::Time&
SetLinkLinearVelocity::_Internal::duration(const SetLinkLinearVelocity* msg) {
  return *msg->duration_;
}
SetLinkLinearVelocity::SetLinkLinearVelocity(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
}
SetLinkLinearVelocity::SetLinkLinearVelocity(const SetLinkLinearVelocity& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_model_name()) {
    model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_model_name(),
      GetArena());
  }
  link_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_link_name()) {
    link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_link_name(),
      GetArena());
  }
  if (from._internal_has_velocity()) {
    velocity_ = new ::mw::internal::robotics::gazebotransport::Point(*from.velocity_);
  } else {
    velocity_ = nullptr;
  }
  if (from._internal_has_duration()) {
    duration_ = new ::mw::internal::robotics::gazebotransport::Time(*from.duration_);
  } else {
    duration_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
}

void SetLinkLinearVelocity::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SetLinkLinearVelocity_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  link_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&velocity_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&duration_) -
      reinterpret_cast<char*>(&velocity_)) + sizeof(duration_));
}

SetLinkLinearVelocity::~SetLinkLinearVelocity() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SetLinkLinearVelocity::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  model_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  link_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete velocity_;
  if (this != internal_default_instance()) delete duration_;
}

void SetLinkLinearVelocity::ArenaDtor(void* object) {
  SetLinkLinearVelocity* _this = reinterpret_cast< SetLinkLinearVelocity* >(object);
  (void)_this;
}
void SetLinkLinearVelocity::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SetLinkLinearVelocity::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SetLinkLinearVelocity& SetLinkLinearVelocity::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SetLinkLinearVelocity_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void SetLinkLinearVelocity::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      model_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      link_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(velocity_ != nullptr);
      velocity_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(duration_ != nullptr);
      duration_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetLinkLinearVelocity::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string model_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_model_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string link_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_link_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .mw.internal.robotics.gazebotransport.Point velocity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_velocity(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .mw.internal.robotics.gazebotransport.Time duration = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_duration(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SetLinkLinearVelocity::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string model_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_model_name().data(), static_cast<int>(this->_internal_model_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_model_name(), target);
  }

  // required string link_name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_link_name().data(), static_cast<int>(this->_internal_link_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_link_name(), target);
  }

  // required .mw.internal.robotics.gazebotransport.Point velocity = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::velocity(this), target, stream);
  }

  // required .mw.internal.robotics.gazebotransport.Time duration = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::duration(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
  return target;
}

size_t SetLinkLinearVelocity::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
  size_t total_size = 0;

  if (_internal_has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());
  }

  if (_internal_has_link_name()) {
    // required string link_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_link_name());
  }

  if (_internal_has_velocity()) {
    // required .mw.internal.robotics.gazebotransport.Point velocity = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *velocity_);
  }

  if (_internal_has_duration()) {
    // required .mw.internal.robotics.gazebotransport.Time duration = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *duration_);
  }

  return total_size;
}
size_t SetLinkLinearVelocity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());

    // required string link_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_link_name());

    // required .mw.internal.robotics.gazebotransport.Point velocity = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *velocity_);

    // required .mw.internal.robotics.gazebotransport.Time duration = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *duration_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SetLinkLinearVelocity::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
  GOOGLE_DCHECK_NE(&from, this);
  const SetLinkLinearVelocity* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SetLinkLinearVelocity>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
    MergeFrom(*source);
  }
}

void SetLinkLinearVelocity::MergeFrom(const SetLinkLinearVelocity& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_model_name(from._internal_model_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_link_name(from._internal_link_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_velocity()->::mw::internal::robotics::gazebotransport::Point::MergeFrom(from._internal_velocity());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_duration()->::mw::internal::robotics::gazebotransport::Time::MergeFrom(from._internal_duration());
    }
  }
}

void SetLinkLinearVelocity::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SetLinkLinearVelocity::CopyFrom(const SetLinkLinearVelocity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetLinkLinearVelocity::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_velocity()) {
    if (!velocity_->IsInitialized()) return false;
  }
  if (_internal_has_duration()) {
    if (!duration_->IsInitialized()) return false;
  }
  return true;
}

void SetLinkLinearVelocity::InternalSwap(SetLinkLinearVelocity* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  model_name_.Swap(&other->model_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  link_name_.Swap(&other->link_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SetLinkLinearVelocity, duration_)
      + sizeof(SetLinkLinearVelocity::duration_)
      - PROTOBUF_FIELD_OFFSET(SetLinkLinearVelocity, velocity_)>(
          reinterpret_cast<char*>(&velocity_),
          reinterpret_cast<char*>(&other->velocity_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SetLinkLinearVelocity::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void SetLinkAngularVelocity::InitAsDefaultInstance() {
  ::mw::internal::robotics::gazebotransport::_SetLinkAngularVelocity_default_instance_._instance.get_mutable()->velocity_ = const_cast< ::mw::internal::robotics::gazebotransport::Point*>(
      ::mw::internal::robotics::gazebotransport::Point::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_SetLinkAngularVelocity_default_instance_._instance.get_mutable()->duration_ = const_cast< ::mw::internal::robotics::gazebotransport::Time*>(
      ::mw::internal::robotics::gazebotransport::Time::internal_default_instance());
}
class SetLinkAngularVelocity::_Internal {
 public:
  using HasBits = decltype(std::declval<SetLinkAngularVelocity>()._has_bits_);
  static void set_has_model_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_link_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::mw::internal::robotics::gazebotransport::Point& velocity(const SetLinkAngularVelocity* msg);
  static void set_has_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::mw::internal::robotics::gazebotransport::Time& duration(const SetLinkAngularVelocity* msg);
  static void set_has_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::mw::internal::robotics::gazebotransport::Point&
SetLinkAngularVelocity::_Internal::velocity(const SetLinkAngularVelocity* msg) {
  return *msg->velocity_;
}
const ::mw::internal::robotics::gazebotransport::Time&
SetLinkAngularVelocity::_Internal::duration(const SetLinkAngularVelocity* msg) {
  return *msg->duration_;
}
SetLinkAngularVelocity::SetLinkAngularVelocity(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
}
SetLinkAngularVelocity::SetLinkAngularVelocity(const SetLinkAngularVelocity& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_model_name()) {
    model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_model_name(),
      GetArena());
  }
  link_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_link_name()) {
    link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_link_name(),
      GetArena());
  }
  if (from._internal_has_velocity()) {
    velocity_ = new ::mw::internal::robotics::gazebotransport::Point(*from.velocity_);
  } else {
    velocity_ = nullptr;
  }
  if (from._internal_has_duration()) {
    duration_ = new ::mw::internal::robotics::gazebotransport::Time(*from.duration_);
  } else {
    duration_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
}

void SetLinkAngularVelocity::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SetLinkAngularVelocity_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  link_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&velocity_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&duration_) -
      reinterpret_cast<char*>(&velocity_)) + sizeof(duration_));
}

SetLinkAngularVelocity::~SetLinkAngularVelocity() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SetLinkAngularVelocity::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  model_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  link_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete velocity_;
  if (this != internal_default_instance()) delete duration_;
}

void SetLinkAngularVelocity::ArenaDtor(void* object) {
  SetLinkAngularVelocity* _this = reinterpret_cast< SetLinkAngularVelocity* >(object);
  (void)_this;
}
void SetLinkAngularVelocity::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SetLinkAngularVelocity::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SetLinkAngularVelocity& SetLinkAngularVelocity::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SetLinkAngularVelocity_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void SetLinkAngularVelocity::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      model_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      link_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(velocity_ != nullptr);
      velocity_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(duration_ != nullptr);
      duration_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetLinkAngularVelocity::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string model_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_model_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string link_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_link_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .mw.internal.robotics.gazebotransport.Point velocity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_velocity(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .mw.internal.robotics.gazebotransport.Time duration = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_duration(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SetLinkAngularVelocity::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string model_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_model_name().data(), static_cast<int>(this->_internal_model_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_model_name(), target);
  }

  // required string link_name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_link_name().data(), static_cast<int>(this->_internal_link_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_link_name(), target);
  }

  // required .mw.internal.robotics.gazebotransport.Point velocity = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::velocity(this), target, stream);
  }

  // required .mw.internal.robotics.gazebotransport.Time duration = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::duration(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
  return target;
}

size_t SetLinkAngularVelocity::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
  size_t total_size = 0;

  if (_internal_has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());
  }

  if (_internal_has_link_name()) {
    // required string link_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_link_name());
  }

  if (_internal_has_velocity()) {
    // required .mw.internal.robotics.gazebotransport.Point velocity = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *velocity_);
  }

  if (_internal_has_duration()) {
    // required .mw.internal.robotics.gazebotransport.Time duration = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *duration_);
  }

  return total_size;
}
size_t SetLinkAngularVelocity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());

    // required string link_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_link_name());

    // required .mw.internal.robotics.gazebotransport.Point velocity = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *velocity_);

    // required .mw.internal.robotics.gazebotransport.Time duration = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *duration_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SetLinkAngularVelocity::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
  GOOGLE_DCHECK_NE(&from, this);
  const SetLinkAngularVelocity* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SetLinkAngularVelocity>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
    MergeFrom(*source);
  }
}

void SetLinkAngularVelocity::MergeFrom(const SetLinkAngularVelocity& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_model_name(from._internal_model_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_link_name(from._internal_link_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_velocity()->::mw::internal::robotics::gazebotransport::Point::MergeFrom(from._internal_velocity());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_duration()->::mw::internal::robotics::gazebotransport::Time::MergeFrom(from._internal_duration());
    }
  }
}

void SetLinkAngularVelocity::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SetLinkAngularVelocity::CopyFrom(const SetLinkAngularVelocity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetLinkAngularVelocity::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_velocity()) {
    if (!velocity_->IsInitialized()) return false;
  }
  if (_internal_has_duration()) {
    if (!duration_->IsInitialized()) return false;
  }
  return true;
}

void SetLinkAngularVelocity::InternalSwap(SetLinkAngularVelocity* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  model_name_.Swap(&other->model_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  link_name_.Swap(&other->link_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SetLinkAngularVelocity, duration_)
      + sizeof(SetLinkAngularVelocity::duration_)
      - PROTOBUF_FIELD_OFFSET(SetLinkAngularVelocity, velocity_)>(
          reinterpret_cast<char*>(&velocity_),
          reinterpret_cast<char*>(&other->velocity_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SetLinkAngularVelocity::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void GetLinkState::InitAsDefaultInstance() {
}
class GetLinkState::_Internal {
 public:
  using HasBits = decltype(std::declval<GetLinkState>()._has_bits_);
  static void set_has_model_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_link_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

GetLinkState::GetLinkState(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.GetLinkState)
}
GetLinkState::GetLinkState(const GetLinkState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_model_name()) {
    model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_model_name(),
      GetArena());
  }
  link_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_link_name()) {
    link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_link_name(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.GetLinkState)
}

void GetLinkState::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_GetLinkState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  link_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

GetLinkState::~GetLinkState() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.GetLinkState)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void GetLinkState::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  model_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  link_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GetLinkState::ArenaDtor(void* object) {
  GetLinkState* _this = reinterpret_cast< GetLinkState* >(object);
  (void)_this;
}
void GetLinkState::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetLinkState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GetLinkState& GetLinkState::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_GetLinkState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void GetLinkState::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.GetLinkState)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      model_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      link_name_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetLinkState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string model_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_model_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.GetLinkState.model_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string link_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_link_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.GetLinkState.link_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GetLinkState::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.GetLinkState)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string model_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_model_name().data(), static_cast<int>(this->_internal_model_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetLinkState.model_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_model_name(), target);
  }

  // required string link_name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_link_name().data(), static_cast<int>(this->_internal_link_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetLinkState.link_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_link_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.GetLinkState)
  return target;
}

size_t GetLinkState::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.GetLinkState)
  size_t total_size = 0;

  if (_internal_has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());
  }

  if (_internal_has_link_name()) {
    // required string link_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_link_name());
  }

  return total_size;
}
size_t GetLinkState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.GetLinkState)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());

    // required string link_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_link_name());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetLinkState::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.GetLinkState)
  GOOGLE_DCHECK_NE(&from, this);
  const GetLinkState* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<GetLinkState>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.GetLinkState)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.GetLinkState)
    MergeFrom(*source);
  }
}

void GetLinkState::MergeFrom(const GetLinkState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.GetLinkState)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_model_name(from._internal_model_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_link_name(from._internal_link_name());
    }
  }
}

void GetLinkState::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.GetLinkState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetLinkState::CopyFrom(const GetLinkState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.GetLinkState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetLinkState::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GetLinkState::InternalSwap(GetLinkState* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  model_name_.Swap(&other->model_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  link_name_.Swap(&other->link_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata GetLinkState::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void LinkState::InitAsDefaultInstance() {
  ::mw::internal::robotics::gazebotransport::_LinkState_default_instance_._instance.get_mutable()->world_linear_velocity_ = const_cast< ::mw::internal::robotics::gazebotransport::Point*>(
      ::mw::internal::robotics::gazebotransport::Point::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_LinkState_default_instance_._instance.get_mutable()->world_angular_velocity_ = const_cast< ::mw::internal::robotics::gazebotransport::Point*>(
      ::mw::internal::robotics::gazebotransport::Point::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_LinkState_default_instance_._instance.get_mutable()->relative_linear_velocity_ = const_cast< ::mw::internal::robotics::gazebotransport::Point*>(
      ::mw::internal::robotics::gazebotransport::Point::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_LinkState_default_instance_._instance.get_mutable()->relative_angular_velocity_ = const_cast< ::mw::internal::robotics::gazebotransport::Point*>(
      ::mw::internal::robotics::gazebotransport::Point::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_LinkState_default_instance_._instance.get_mutable()->world_pose_ = const_cast< ::mw::internal::robotics::gazebotransport::Pose*>(
      ::mw::internal::robotics::gazebotransport::Pose::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_LinkState_default_instance_._instance.get_mutable()->relative_pose_ = const_cast< ::mw::internal::robotics::gazebotransport::Pose*>(
      ::mw::internal::robotics::gazebotransport::Pose::internal_default_instance());
}
class LinkState::_Internal {
 public:
  using HasBits = decltype(std::declval<LinkState>()._has_bits_);
  static void set_has_model_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_link_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_link_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::mw::internal::robotics::gazebotransport::Point& world_linear_velocity(const LinkState* msg);
  static void set_has_world_linear_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::mw::internal::robotics::gazebotransport::Point& world_angular_velocity(const LinkState* msg);
  static void set_has_world_angular_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::mw::internal::robotics::gazebotransport::Point& relative_linear_velocity(const LinkState* msg);
  static void set_has_relative_linear_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::mw::internal::robotics::gazebotransport::Point& relative_angular_velocity(const LinkState* msg);
  static void set_has_relative_angular_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::mw::internal::robotics::gazebotransport::Pose& world_pose(const LinkState* msg);
  static void set_has_world_pose(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::mw::internal::robotics::gazebotransport::Pose& relative_pose(const LinkState* msg);
  static void set_has_relative_pose(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_self_collide(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_gravity(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_kinematic(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_enable_wind(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_canonical(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000013f) ^ 0x0000013f) != 0;
  }
};

const ::mw::internal::robotics::gazebotransport::Point&
LinkState::_Internal::world_linear_velocity(const LinkState* msg) {
  return *msg->world_linear_velocity_;
}
const ::mw::internal::robotics::gazebotransport::Point&
LinkState::_Internal::world_angular_velocity(const LinkState* msg) {
  return *msg->world_angular_velocity_;
}
const ::mw::internal::robotics::gazebotransport::Point&
LinkState::_Internal::relative_linear_velocity(const LinkState* msg) {
  return *msg->relative_linear_velocity_;
}
const ::mw::internal::robotics::gazebotransport::Point&
LinkState::_Internal::relative_angular_velocity(const LinkState* msg) {
  return *msg->relative_angular_velocity_;
}
const ::mw::internal::robotics::gazebotransport::Pose&
LinkState::_Internal::world_pose(const LinkState* msg) {
  return *msg->world_pose_;
}
const ::mw::internal::robotics::gazebotransport::Pose&
LinkState::_Internal::relative_pose(const LinkState* msg) {
  return *msg->relative_pose_;
}
LinkState::LinkState(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.LinkState)
}
LinkState::LinkState(const LinkState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_model_name()) {
    model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_model_name(),
      GetArena());
  }
  link_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_link_name()) {
    link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_link_name(),
      GetArena());
  }
  if (from._internal_has_world_linear_velocity()) {
    world_linear_velocity_ = new ::mw::internal::robotics::gazebotransport::Point(*from.world_linear_velocity_);
  } else {
    world_linear_velocity_ = nullptr;
  }
  if (from._internal_has_world_angular_velocity()) {
    world_angular_velocity_ = new ::mw::internal::robotics::gazebotransport::Point(*from.world_angular_velocity_);
  } else {
    world_angular_velocity_ = nullptr;
  }
  if (from._internal_has_relative_linear_velocity()) {
    relative_linear_velocity_ = new ::mw::internal::robotics::gazebotransport::Point(*from.relative_linear_velocity_);
  } else {
    relative_linear_velocity_ = nullptr;
  }
  if (from._internal_has_relative_angular_velocity()) {
    relative_angular_velocity_ = new ::mw::internal::robotics::gazebotransport::Point(*from.relative_angular_velocity_);
  } else {
    relative_angular_velocity_ = nullptr;
  }
  if (from._internal_has_world_pose()) {
    world_pose_ = new ::mw::internal::robotics::gazebotransport::Pose(*from.world_pose_);
  } else {
    world_pose_ = nullptr;
  }
  if (from._internal_has_relative_pose()) {
    relative_pose_ = new ::mw::internal::robotics::gazebotransport::Pose(*from.relative_pose_);
  } else {
    relative_pose_ = nullptr;
  }
  ::memcpy(&link_id_, &from.link_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&canonical_) -
    reinterpret_cast<char*>(&link_id_)) + sizeof(canonical_));
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.LinkState)
}

void LinkState::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_LinkState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  link_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&world_linear_velocity_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&canonical_) -
      reinterpret_cast<char*>(&world_linear_velocity_)) + sizeof(canonical_));
}

LinkState::~LinkState() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.LinkState)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void LinkState::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  model_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  link_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete world_linear_velocity_;
  if (this != internal_default_instance()) delete world_angular_velocity_;
  if (this != internal_default_instance()) delete relative_linear_velocity_;
  if (this != internal_default_instance()) delete relative_angular_velocity_;
  if (this != internal_default_instance()) delete world_pose_;
  if (this != internal_default_instance()) delete relative_pose_;
}

void LinkState::ArenaDtor(void* object) {
  LinkState* _this = reinterpret_cast< LinkState* >(object);
  (void)_this;
}
void LinkState::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LinkState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LinkState& LinkState::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_LinkState_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void LinkState::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.LinkState)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      model_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      link_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(world_linear_velocity_ != nullptr);
      world_linear_velocity_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(world_angular_velocity_ != nullptr);
      world_angular_velocity_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(relative_linear_velocity_ != nullptr);
      relative_linear_velocity_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(relative_angular_velocity_ != nullptr);
      relative_angular_velocity_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(world_pose_ != nullptr);
      world_pose_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(relative_pose_ != nullptr);
      relative_pose_->Clear();
    }
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&link_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&canonical_) -
        reinterpret_cast<char*>(&link_id_)) + sizeof(canonical_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LinkState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string model_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_model_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.LinkState.model_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string link_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_link_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.LinkState.link_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 link_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_link_id(&has_bits);
          link_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .mw.internal.robotics.gazebotransport.Point world_linear_velocity = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_world_linear_velocity(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .mw.internal.robotics.gazebotransport.Point world_angular_velocity = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_world_angular_velocity(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .mw.internal.robotics.gazebotransport.Point relative_linear_velocity = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_relative_linear_velocity(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .mw.internal.robotics.gazebotransport.Point relative_angular_velocity = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_relative_angular_velocity(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mw.internal.robotics.gazebotransport.Pose world_pose = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_world_pose(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mw.internal.robotics.gazebotransport.Pose relative_pose = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_relative_pose(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool self_collide = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_self_collide(&has_bits);
          self_collide_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool gravity = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_gravity(&has_bits);
          gravity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool kinematic = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_kinematic(&has_bits);
          kinematic_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool enable_wind = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_enable_wind(&has_bits);
          enable_wind_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool canonical = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_canonical(&has_bits);
          canonical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LinkState::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.LinkState)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string model_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_model_name().data(), static_cast<int>(this->_internal_model_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.LinkState.model_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_model_name(), target);
  }

  // required string link_name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_link_name().data(), static_cast<int>(this->_internal_link_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.LinkState.link_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_link_name(), target);
  }

  // required uint32 link_id = 3;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_link_id(), target);
  }

  // required .mw.internal.robotics.gazebotransport.Point world_linear_velocity = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::world_linear_velocity(this), target, stream);
  }

  // required .mw.internal.robotics.gazebotransport.Point world_angular_velocity = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::world_angular_velocity(this), target, stream);
  }

  // required .mw.internal.robotics.gazebotransport.Point relative_linear_velocity = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::relative_linear_velocity(this), target, stream);
  }

  // required .mw.internal.robotics.gazebotransport.Point relative_angular_velocity = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::relative_angular_velocity(this), target, stream);
  }

  // optional .mw.internal.robotics.gazebotransport.Pose world_pose = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::world_pose(this), target, stream);
  }

  // optional .mw.internal.robotics.gazebotransport.Pose relative_pose = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::relative_pose(this), target, stream);
  }

  // optional bool self_collide = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_self_collide(), target);
  }

  // optional bool gravity = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_gravity(), target);
  }

  // optional bool kinematic = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_kinematic(), target);
  }

  // optional bool enable_wind = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(13, this->_internal_enable_wind(), target);
  }

  // optional bool canonical = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_canonical(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.LinkState)
  return target;
}

size_t LinkState::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.LinkState)
  size_t total_size = 0;

  if (_internal_has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());
  }

  if (_internal_has_link_name()) {
    // required string link_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_link_name());
  }

  if (_internal_has_world_linear_velocity()) {
    // required .mw.internal.robotics.gazebotransport.Point world_linear_velocity = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *world_linear_velocity_);
  }

  if (_internal_has_world_angular_velocity()) {
    // required .mw.internal.robotics.gazebotransport.Point world_angular_velocity = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *world_angular_velocity_);
  }

  if (_internal_has_relative_linear_velocity()) {
    // required .mw.internal.robotics.gazebotransport.Point relative_linear_velocity = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *relative_linear_velocity_);
  }

  if (_internal_has_relative_angular_velocity()) {
    // required .mw.internal.robotics.gazebotransport.Point relative_angular_velocity = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *relative_angular_velocity_);
  }

  if (_internal_has_link_id()) {
    // required uint32 link_id = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_link_id());
  }

  return total_size;
}
size_t LinkState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.LinkState)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000013f) ^ 0x0000013f) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());

    // required string link_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_link_name());

    // required .mw.internal.robotics.gazebotransport.Point world_linear_velocity = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *world_linear_velocity_);

    // required .mw.internal.robotics.gazebotransport.Point world_angular_velocity = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *world_angular_velocity_);

    // required .mw.internal.robotics.gazebotransport.Point relative_linear_velocity = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *relative_linear_velocity_);

    // required .mw.internal.robotics.gazebotransport.Point relative_angular_velocity = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *relative_angular_velocity_);

    // required uint32 link_id = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_link_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000c0u) {
    // optional .mw.internal.robotics.gazebotransport.Pose world_pose = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *world_pose_);
    }

    // optional .mw.internal.robotics.gazebotransport.Pose relative_pose = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *relative_pose_);
    }

  }
  if (cached_has_bits & 0x00003e00u) {
    // optional bool self_collide = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool gravity = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool kinematic = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool enable_wind = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool canonical = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LinkState::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.LinkState)
  GOOGLE_DCHECK_NE(&from, this);
  const LinkState* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LinkState>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.LinkState)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.LinkState)
    MergeFrom(*source);
  }
}

void LinkState::MergeFrom(const LinkState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.LinkState)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_model_name(from._internal_model_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_link_name(from._internal_link_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_world_linear_velocity()->::mw::internal::robotics::gazebotransport::Point::MergeFrom(from._internal_world_linear_velocity());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_world_angular_velocity()->::mw::internal::robotics::gazebotransport::Point::MergeFrom(from._internal_world_angular_velocity());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_relative_linear_velocity()->::mw::internal::robotics::gazebotransport::Point::MergeFrom(from._internal_relative_linear_velocity());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_relative_angular_velocity()->::mw::internal::robotics::gazebotransport::Point::MergeFrom(from._internal_relative_angular_velocity());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_world_pose()->::mw::internal::robotics::gazebotransport::Pose::MergeFrom(from._internal_world_pose());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_relative_pose()->::mw::internal::robotics::gazebotransport::Pose::MergeFrom(from._internal_relative_pose());
    }
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      link_id_ = from.link_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      self_collide_ = from.self_collide_;
    }
    if (cached_has_bits & 0x00000400u) {
      gravity_ = from.gravity_;
    }
    if (cached_has_bits & 0x00000800u) {
      kinematic_ = from.kinematic_;
    }
    if (cached_has_bits & 0x00001000u) {
      enable_wind_ = from.enable_wind_;
    }
    if (cached_has_bits & 0x00002000u) {
      canonical_ = from.canonical_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void LinkState::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.LinkState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LinkState::CopyFrom(const LinkState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.LinkState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LinkState::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_world_linear_velocity()) {
    if (!world_linear_velocity_->IsInitialized()) return false;
  }
  if (_internal_has_world_angular_velocity()) {
    if (!world_angular_velocity_->IsInitialized()) return false;
  }
  if (_internal_has_relative_linear_velocity()) {
    if (!relative_linear_velocity_->IsInitialized()) return false;
  }
  if (_internal_has_relative_angular_velocity()) {
    if (!relative_angular_velocity_->IsInitialized()) return false;
  }
  if (_internal_has_world_pose()) {
    if (!world_pose_->IsInitialized()) return false;
  }
  if (_internal_has_relative_pose()) {
    if (!relative_pose_->IsInitialized()) return false;
  }
  return true;
}

void LinkState::InternalSwap(LinkState* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  model_name_.Swap(&other->model_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  link_name_.Swap(&other->link_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LinkState, canonical_)
      + sizeof(LinkState::canonical_)
      - PROTOBUF_FIELD_OFFSET(LinkState, world_linear_velocity_)>(
          reinterpret_cast<char*>(&world_linear_velocity_),
          reinterpret_cast<char*>(&other->world_linear_velocity_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LinkState::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ML_Cord::InitAsDefaultInstance() {
}
class ML_Cord::_Internal {
 public:
  using HasBits = decltype(std::declval<ML_Cord>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ML_Cord::ML_Cord(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.ML_Cord)
}
ML_Cord::ML_Cord(const ML_Cord& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&x_)) + sizeof(y_));
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ML_Cord)
}

void ML_Cord::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&y_) -
      reinterpret_cast<char*>(&x_)) + sizeof(y_));
}

ML_Cord::~ML_Cord() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ML_Cord)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ML_Cord::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void ML_Cord::ArenaDtor(void* object) {
  ML_Cord* _this = reinterpret_cast< ML_Cord* >(object);
  (void)_this;
}
void ML_Cord::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ML_Cord::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ML_Cord& ML_Cord::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ML_Cord_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void ML_Cord::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ML_Cord)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&y_) -
        reinterpret_cast<char*>(&x_)) + sizeof(y_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ML_Cord::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional double x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ML_Cord::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ML_Cord)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // optional double y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ML_Cord)
  return target;
}

size_t ML_Cord::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ML_Cord)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ML_Cord::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ML_Cord)
  GOOGLE_DCHECK_NE(&from, this);
  const ML_Cord* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ML_Cord>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ML_Cord)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ML_Cord)
    MergeFrom(*source);
  }
}

void ML_Cord::MergeFrom(const ML_Cord& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ML_Cord)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ML_Cord::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ML_Cord)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ML_Cord::CopyFrom(const ML_Cord& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ML_Cord)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ML_Cord::IsInitialized() const {
  return true;
}

void ML_Cord::InternalSwap(ML_Cord* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ML_Cord, y_)
      + sizeof(ML_Cord::y_)
      - PROTOBUF_FIELD_OFFSET(ML_Cord, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ML_Cord::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ML_Point::InitAsDefaultInstance() {
}
class ML_Point::_Internal {
 public:
  using HasBits = decltype(std::declval<ML_Point>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ML_Point::ML_Point(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.ML_Point)
}
ML_Point::ML_Point(const ML_Point& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ML_Point)
}

void ML_Point::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

ML_Point::~ML_Point() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ML_Point)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ML_Point::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void ML_Point::ArenaDtor(void* object) {
  ML_Point* _this = reinterpret_cast< ML_Point* >(object);
  (void)_this;
}
void ML_Point::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ML_Point::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ML_Point& ML_Point::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ML_Point_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void ML_Point::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ML_Point)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&z_) -
        reinterpret_cast<char*>(&x_)) + sizeof(z_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ML_Point::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional double x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_z(&has_bits);
          z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ML_Point::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ML_Point)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // optional double y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  // optional double z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ML_Point)
  return target;
}

size_t ML_Point::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ML_Point)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double z = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ML_Point::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ML_Point)
  GOOGLE_DCHECK_NE(&from, this);
  const ML_Point* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ML_Point>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ML_Point)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ML_Point)
    MergeFrom(*source);
  }
}

void ML_Point::MergeFrom(const ML_Point& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ML_Point)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      z_ = from.z_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ML_Point::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ML_Point)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ML_Point::CopyFrom(const ML_Point& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ML_Point)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ML_Point::IsInitialized() const {
  return true;
}

void ML_Point::InternalSwap(ML_Point* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ML_Point, z_)
      + sizeof(ML_Point::z_)
      - PROTOBUF_FIELD_OFFSET(ML_Point, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ML_Point::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ML_Quat::InitAsDefaultInstance() {
}
class ML_Quat::_Internal {
 public:
  using HasBits = decltype(std::declval<ML_Quat>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_w(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

ML_Quat::ML_Quat(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.ML_Quat)
}
ML_Quat::ML_Quat(const ML_Quat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&w_) -
    reinterpret_cast<char*>(&x_)) + sizeof(w_));
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ML_Quat)
}

void ML_Quat::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&w_) -
      reinterpret_cast<char*>(&x_)) + sizeof(w_));
}

ML_Quat::~ML_Quat() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ML_Quat)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ML_Quat::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void ML_Quat::ArenaDtor(void* object) {
  ML_Quat* _this = reinterpret_cast< ML_Quat* >(object);
  (void)_this;
}
void ML_Quat::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ML_Quat::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ML_Quat& ML_Quat::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ML_Quat_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void ML_Quat::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ML_Quat)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&w_) -
        reinterpret_cast<char*>(&x_)) + sizeof(w_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ML_Quat::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional double x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_z(&has_bits);
          z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double w = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_w(&has_bits);
          w_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ML_Quat::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ML_Quat)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // optional double y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  // optional double z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_z(), target);
  }

  // optional double w = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_w(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ML_Quat)
  return target;
}

size_t ML_Quat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ML_Quat)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional double x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double z = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double w = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ML_Quat::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ML_Quat)
  GOOGLE_DCHECK_NE(&from, this);
  const ML_Quat* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ML_Quat>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ML_Quat)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ML_Quat)
    MergeFrom(*source);
  }
}

void ML_Quat::MergeFrom(const ML_Quat& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ML_Quat)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      z_ = from.z_;
    }
    if (cached_has_bits & 0x00000008u) {
      w_ = from.w_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ML_Quat::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ML_Quat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ML_Quat::CopyFrom(const ML_Quat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ML_Quat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ML_Quat::IsInitialized() const {
  return true;
}

void ML_Quat::InternalSwap(ML_Quat* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ML_Quat, w_)
      + sizeof(ML_Quat::w_)
      - PROTOBUF_FIELD_OFFSET(ML_Quat, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ML_Quat::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ML_Pose::InitAsDefaultInstance() {
  ::mw::internal::robotics::gazebotransport::_ML_Pose_default_instance_._instance.get_mutable()->position_ = const_cast< ::mw::internal::robotics::gazebotransport::ML_Point*>(
      ::mw::internal::robotics::gazebotransport::ML_Point::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_ML_Pose_default_instance_._instance.get_mutable()->orientation_ = const_cast< ::mw::internal::robotics::gazebotransport::ML_Quat*>(
      ::mw::internal::robotics::gazebotransport::ML_Quat::internal_default_instance());
}
class ML_Pose::_Internal {
 public:
  using HasBits = decltype(std::declval<ML_Pose>()._has_bits_);
  static const ::mw::internal::robotics::gazebotransport::ML_Point& position(const ML_Pose* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mw::internal::robotics::gazebotransport::ML_Quat& orientation(const ML_Pose* msg);
  static void set_has_orientation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::mw::internal::robotics::gazebotransport::ML_Point&
ML_Pose::_Internal::position(const ML_Pose* msg) {
  return *msg->position_;
}
const ::mw::internal::robotics::gazebotransport::ML_Quat&
ML_Pose::_Internal::orientation(const ML_Pose* msg) {
  return *msg->orientation_;
}
ML_Pose::ML_Pose(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.ML_Pose)
}
ML_Pose::ML_Pose(const ML_Pose& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_position()) {
    position_ = new ::mw::internal::robotics::gazebotransport::ML_Point(*from.position_);
  } else {
    position_ = nullptr;
  }
  if (from._internal_has_orientation()) {
    orientation_ = new ::mw::internal::robotics::gazebotransport::ML_Quat(*from.orientation_);
  } else {
    orientation_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ML_Pose)
}

void ML_Pose::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ML_Pose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  ::memset(&position_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&orientation_) -
      reinterpret_cast<char*>(&position_)) + sizeof(orientation_));
}

ML_Pose::~ML_Pose() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ML_Pose)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ML_Pose::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete position_;
  if (this != internal_default_instance()) delete orientation_;
}

void ML_Pose::ArenaDtor(void* object) {
  ML_Pose* _this = reinterpret_cast< ML_Pose* >(object);
  (void)_this;
}
void ML_Pose::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ML_Pose::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ML_Pose& ML_Pose::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ML_Pose_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void ML_Pose::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ML_Pose)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(position_ != nullptr);
      position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(orientation_ != nullptr);
      orientation_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ML_Pose::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .mw.internal.robotics.gazebotransport.ML_Point position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mw.internal.robotics.gazebotransport.ML_Quat orientation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_orientation(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ML_Pose::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ML_Pose)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .mw.internal.robotics.gazebotransport.ML_Point position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::position(this), target, stream);
  }

  // optional .mw.internal.robotics.gazebotransport.ML_Quat orientation = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::orientation(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ML_Pose)
  return target;
}

size_t ML_Pose::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ML_Pose)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .mw.internal.robotics.gazebotransport.ML_Point position = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *position_);
    }

    // optional .mw.internal.robotics.gazebotransport.ML_Quat orientation = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *orientation_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ML_Pose::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ML_Pose)
  GOOGLE_DCHECK_NE(&from, this);
  const ML_Pose* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ML_Pose>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ML_Pose)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ML_Pose)
    MergeFrom(*source);
  }
}

void ML_Pose::MergeFrom(const ML_Pose& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ML_Pose)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_position()->::mw::internal::robotics::gazebotransport::ML_Point::MergeFrom(from._internal_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_orientation()->::mw::internal::robotics::gazebotransport::ML_Quat::MergeFrom(from._internal_orientation());
    }
  }
}

void ML_Pose::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ML_Pose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ML_Pose::CopyFrom(const ML_Pose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ML_Pose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ML_Pose::IsInitialized() const {
  return true;
}

void ML_Pose::InternalSwap(ML_Pose* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ML_Pose, orientation_)
      + sizeof(ML_Pose::orientation_)
      - PROTOBUF_FIELD_OFFSET(ML_Pose, position_)>(
          reinterpret_cast<char*>(&position_),
          reinterpret_cast<char*>(&other->position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ML_Pose::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ML_Inertial::InitAsDefaultInstance() {
}
class ML_Inertial::_Internal {
 public:
  using HasBits = decltype(std::declval<ML_Inertial>()._has_bits_);
  static void set_has_mass(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ixx(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ixy(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ixz(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_iyy(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_iyz(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_izz(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

ML_Inertial::ML_Inertial(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.ML_Inertial)
}
ML_Inertial::ML_Inertial(const ML_Inertial& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&mass_, &from.mass_,
    static_cast<size_t>(reinterpret_cast<char*>(&izz_) -
    reinterpret_cast<char*>(&mass_)) + sizeof(izz_));
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ML_Inertial)
}

void ML_Inertial::SharedCtor() {
  ::memset(&mass_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&izz_) -
      reinterpret_cast<char*>(&mass_)) + sizeof(izz_));
}

ML_Inertial::~ML_Inertial() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ML_Inertial)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ML_Inertial::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void ML_Inertial::ArenaDtor(void* object) {
  ML_Inertial* _this = reinterpret_cast< ML_Inertial* >(object);
  (void)_this;
}
void ML_Inertial::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ML_Inertial::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ML_Inertial& ML_Inertial::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ML_Inertial_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void ML_Inertial::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ML_Inertial)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&mass_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&izz_) -
        reinterpret_cast<char*>(&mass_)) + sizeof(izz_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ML_Inertial::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional double mass = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_mass(&has_bits);
          mass_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double ixx = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_ixx(&has_bits);
          ixx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double ixy = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_ixy(&has_bits);
          ixy_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double ixz = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_ixz(&has_bits);
          ixz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double iyy = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _Internal::set_has_iyy(&has_bits);
          iyy_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double iyz = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 49)) {
          _Internal::set_has_iyz(&has_bits);
          iyz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double izz = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 57)) {
          _Internal::set_has_izz(&has_bits);
          izz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ML_Inertial::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ML_Inertial)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double mass = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_mass(), target);
  }

  // optional double ixx = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_ixx(), target);
  }

  // optional double ixy = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_ixy(), target);
  }

  // optional double ixz = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_ixz(), target);
  }

  // optional double iyy = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_iyy(), target);
  }

  // optional double iyz = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(6, this->_internal_iyz(), target);
  }

  // optional double izz = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(7, this->_internal_izz(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ML_Inertial)
  return target;
}

size_t ML_Inertial::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ML_Inertial)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional double mass = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double ixx = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double ixy = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double ixz = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double iyy = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double iyz = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double izz = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ML_Inertial::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ML_Inertial)
  GOOGLE_DCHECK_NE(&from, this);
  const ML_Inertial* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ML_Inertial>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ML_Inertial)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ML_Inertial)
    MergeFrom(*source);
  }
}

void ML_Inertial::MergeFrom(const ML_Inertial& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ML_Inertial)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      mass_ = from.mass_;
    }
    if (cached_has_bits & 0x00000002u) {
      ixx_ = from.ixx_;
    }
    if (cached_has_bits & 0x00000004u) {
      ixy_ = from.ixy_;
    }
    if (cached_has_bits & 0x00000008u) {
      ixz_ = from.ixz_;
    }
    if (cached_has_bits & 0x00000010u) {
      iyy_ = from.iyy_;
    }
    if (cached_has_bits & 0x00000020u) {
      iyz_ = from.iyz_;
    }
    if (cached_has_bits & 0x00000040u) {
      izz_ = from.izz_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ML_Inertial::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ML_Inertial)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ML_Inertial::CopyFrom(const ML_Inertial& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ML_Inertial)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ML_Inertial::IsInitialized() const {
  return true;
}

void ML_Inertial::InternalSwap(ML_Inertial* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ML_Inertial, izz_)
      + sizeof(ML_Inertial::izz_)
      - PROTOBUF_FIELD_OFFSET(ML_Inertial, mass_)>(
          reinterpret_cast<char*>(&mass_),
          reinterpret_cast<char*>(&other->mass_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ML_Inertial::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ML_Links::InitAsDefaultInstance() {
  ::mw::internal::robotics::gazebotransport::_ML_Links_default_instance_._instance.get_mutable()->pose_ = const_cast< ::mw::internal::robotics::gazebotransport::ML_Pose*>(
      ::mw::internal::robotics::gazebotransport::ML_Pose::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_ML_Links_default_instance_._instance.get_mutable()->inertial_ = const_cast< ::mw::internal::robotics::gazebotransport::ML_Inertial*>(
      ::mw::internal::robotics::gazebotransport::ML_Inertial::internal_default_instance());
}
class ML_Links::_Internal {
 public:
  using HasBits = decltype(std::declval<ML_Links>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mw::internal::robotics::gazebotransport::ML_Pose& pose(const ML_Links* msg);
  static void set_has_pose(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::mw::internal::robotics::gazebotransport::ML_Inertial& inertial(const ML_Links* msg);
  static void set_has_inertial(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_self_collide(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gravity(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_kinematic(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_enabled_wind(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_is_static(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_canonical(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

const ::mw::internal::robotics::gazebotransport::ML_Pose&
ML_Links::_Internal::pose(const ML_Links* msg) {
  return *msg->pose_;
}
const ::mw::internal::robotics::gazebotransport::ML_Inertial&
ML_Links::_Internal::inertial(const ML_Links* msg) {
  return *msg->inertial_;
}
ML_Links::ML_Links(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.ML_Links)
}
ML_Links::ML_Links(const ML_Links& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  if (from._internal_has_pose()) {
    pose_ = new ::mw::internal::robotics::gazebotransport::ML_Pose(*from.pose_);
  } else {
    pose_ = nullptr;
  }
  if (from._internal_has_inertial()) {
    inertial_ = new ::mw::internal::robotics::gazebotransport::ML_Inertial(*from.inertial_);
  } else {
    inertial_ = nullptr;
  }
  ::memcpy(&self_collide_, &from.self_collide_,
    static_cast<size_t>(reinterpret_cast<char*>(&canonical_) -
    reinterpret_cast<char*>(&self_collide_)) + sizeof(canonical_));
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ML_Links)
}

void ML_Links::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ML_Links_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&pose_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&canonical_) -
      reinterpret_cast<char*>(&pose_)) + sizeof(canonical_));
}

ML_Links::~ML_Links() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ML_Links)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ML_Links::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete pose_;
  if (this != internal_default_instance()) delete inertial_;
}

void ML_Links::ArenaDtor(void* object) {
  ML_Links* _this = reinterpret_cast< ML_Links* >(object);
  (void)_this;
}
void ML_Links::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ML_Links::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ML_Links& ML_Links::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ML_Links_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void ML_Links::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ML_Links)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(pose_ != nullptr);
      pose_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(inertial_ != nullptr);
      inertial_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&self_collide_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_static_) -
        reinterpret_cast<char*>(&self_collide_)) + sizeof(is_static_));
  }
  canonical_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ML_Links::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.ML_Links.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_pose(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mw.internal.robotics.gazebotransport.ML_Inertial inertial = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_inertial(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool self_collide = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_self_collide(&has_bits);
          self_collide_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool gravity = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_gravity(&has_bits);
          gravity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool kinematic = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_kinematic(&has_bits);
          kinematic_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool enabled_wind = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_enabled_wind(&has_bits);
          enabled_wind_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_static = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_is_static(&has_bits);
          is_static_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool canonical = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_canonical(&has_bits);
          canonical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ML_Links::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ML_Links)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ML_Links.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::pose(this), target, stream);
  }

  // optional .mw.internal.robotics.gazebotransport.ML_Inertial inertial = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::inertial(this), target, stream);
  }

  // optional bool self_collide = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_self_collide(), target);
  }

  // optional bool gravity = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_gravity(), target);
  }

  // optional bool kinematic = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_kinematic(), target);
  }

  // optional bool enabled_wind = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_enabled_wind(), target);
  }

  // optional bool is_static = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_is_static(), target);
  }

  // optional bool canonical = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_canonical(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ML_Links)
  return target;
}

size_t ML_Links::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ML_Links)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *pose_);
    }

    // optional .mw.internal.robotics.gazebotransport.ML_Inertial inertial = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *inertial_);
    }

    // optional bool self_collide = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool gravity = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool kinematic = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool enabled_wind = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool is_static = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  // optional bool canonical = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ML_Links::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ML_Links)
  GOOGLE_DCHECK_NE(&from, this);
  const ML_Links* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ML_Links>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ML_Links)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ML_Links)
    MergeFrom(*source);
  }
}

void ML_Links::MergeFrom(const ML_Links& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ML_Links)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_pose()->::mw::internal::robotics::gazebotransport::ML_Pose::MergeFrom(from._internal_pose());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_inertial()->::mw::internal::robotics::gazebotransport::ML_Inertial::MergeFrom(from._internal_inertial());
    }
    if (cached_has_bits & 0x00000008u) {
      self_collide_ = from.self_collide_;
    }
    if (cached_has_bits & 0x00000010u) {
      gravity_ = from.gravity_;
    }
    if (cached_has_bits & 0x00000020u) {
      kinematic_ = from.kinematic_;
    }
    if (cached_has_bits & 0x00000040u) {
      enabled_wind_ = from.enabled_wind_;
    }
    if (cached_has_bits & 0x00000080u) {
      is_static_ = from.is_static_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_canonical(from._internal_canonical());
  }
}

void ML_Links::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ML_Links)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ML_Links::CopyFrom(const ML_Links& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ML_Links)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ML_Links::IsInitialized() const {
  return true;
}

void ML_Links::InternalSwap(ML_Links* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ML_Links, canonical_)
      + sizeof(ML_Links::canonical_)
      - PROTOBUF_FIELD_OFFSET(ML_Links, pose_)>(
          reinterpret_cast<char*>(&pose_),
          reinterpret_cast<char*>(&other->pose_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ML_Links::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ML_Axis::InitAsDefaultInstance() {
  ::mw::internal::robotics::gazebotransport::_ML_Axis_default_instance_._instance.get_mutable()->xyz_ = const_cast< ::mw::internal::robotics::gazebotransport::ML_Point*>(
      ::mw::internal::robotics::gazebotransport::ML_Point::internal_default_instance());
}
class ML_Axis::_Internal {
 public:
  using HasBits = decltype(std::declval<ML_Axis>()._has_bits_);
  static const ::mw::internal::robotics::gazebotransport::ML_Point& xyz(const ML_Axis* msg);
  static void set_has_xyz(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_damping(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_friction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_angle(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::mw::internal::robotics::gazebotransport::ML_Point&
ML_Axis::_Internal::xyz(const ML_Axis* msg) {
  return *msg->xyz_;
}
ML_Axis::ML_Axis(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.ML_Axis)
}
ML_Axis::ML_Axis(const ML_Axis& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_xyz()) {
    xyz_ = new ::mw::internal::robotics::gazebotransport::ML_Point(*from.xyz_);
  } else {
    xyz_ = nullptr;
  }
  ::memcpy(&damping_, &from.damping_,
    static_cast<size_t>(reinterpret_cast<char*>(&angle_) -
    reinterpret_cast<char*>(&damping_)) + sizeof(angle_));
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ML_Axis)
}

void ML_Axis::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ML_Axis_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  ::memset(&xyz_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&angle_) -
      reinterpret_cast<char*>(&xyz_)) + sizeof(angle_));
}

ML_Axis::~ML_Axis() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ML_Axis)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ML_Axis::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete xyz_;
}

void ML_Axis::ArenaDtor(void* object) {
  ML_Axis* _this = reinterpret_cast< ML_Axis* >(object);
  (void)_this;
}
void ML_Axis::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ML_Axis::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ML_Axis& ML_Axis::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ML_Axis_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void ML_Axis::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ML_Axis)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(xyz_ != nullptr);
    xyz_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&damping_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&angle_) -
        reinterpret_cast<char*>(&damping_)) + sizeof(angle_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ML_Axis::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .mw.internal.robotics.gazebotransport.ML_Point xyz = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_xyz(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional double damping = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_damping(&has_bits);
          damping_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double friction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_friction(&has_bits);
          friction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double angle = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_angle(&has_bits);
          angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ML_Axis::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ML_Axis)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .mw.internal.robotics.gazebotransport.ML_Point xyz = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::xyz(this), target, stream);
  }

  // optional double damping = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_damping(), target);
  }

  // optional double friction = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_friction(), target);
  }

  // optional double angle = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_angle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ML_Axis)
  return target;
}

size_t ML_Axis::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ML_Axis)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .mw.internal.robotics.gazebotransport.ML_Point xyz = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *xyz_);
    }

    // optional double damping = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double friction = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double angle = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ML_Axis::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ML_Axis)
  GOOGLE_DCHECK_NE(&from, this);
  const ML_Axis* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ML_Axis>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ML_Axis)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ML_Axis)
    MergeFrom(*source);
  }
}

void ML_Axis::MergeFrom(const ML_Axis& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ML_Axis)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_xyz()->::mw::internal::robotics::gazebotransport::ML_Point::MergeFrom(from._internal_xyz());
    }
    if (cached_has_bits & 0x00000002u) {
      damping_ = from.damping_;
    }
    if (cached_has_bits & 0x00000004u) {
      friction_ = from.friction_;
    }
    if (cached_has_bits & 0x00000008u) {
      angle_ = from.angle_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ML_Axis::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ML_Axis)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ML_Axis::CopyFrom(const ML_Axis& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ML_Axis)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ML_Axis::IsInitialized() const {
  return true;
}

void ML_Axis::InternalSwap(ML_Axis* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ML_Axis, angle_)
      + sizeof(ML_Axis::angle_)
      - PROTOBUF_FIELD_OFFSET(ML_Axis, xyz_)>(
          reinterpret_cast<char*>(&xyz_),
          reinterpret_cast<char*>(&other->xyz_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ML_Axis::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ML_Joints::InitAsDefaultInstance() {
  ::mw::internal::robotics::gazebotransport::_ML_Joints_default_instance_._instance.get_mutable()->pose_ = const_cast< ::mw::internal::robotics::gazebotransport::ML_Pose*>(
      ::mw::internal::robotics::gazebotransport::ML_Pose::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_ML_Joints_default_instance_._instance.get_mutable()->axis1_ = const_cast< ::mw::internal::robotics::gazebotransport::ML_Axis*>(
      ::mw::internal::robotics::gazebotransport::ML_Axis::internal_default_instance());
  ::mw::internal::robotics::gazebotransport::_ML_Joints_default_instance_._instance.get_mutable()->axis2_ = const_cast< ::mw::internal::robotics::gazebotransport::ML_Axis*>(
      ::mw::internal::robotics::gazebotransport::ML_Axis::internal_default_instance());
}
class ML_Joints::_Internal {
 public:
  using HasBits = decltype(std::declval<ML_Joints>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mw::internal::robotics::gazebotransport::ML_Pose& pose(const ML_Joints* msg);
  static void set_has_pose(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::mw::internal::robotics::gazebotransport::ML_Axis& axis1(const ML_Joints* msg);
  static void set_has_axis1(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::mw::internal::robotics::gazebotransport::ML_Axis& axis2(const ML_Joints* msg);
  static void set_has_axis2(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_cfm(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_fudge_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_suspension_cfm(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_suspension_erp(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_dof(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

const ::mw::internal::robotics::gazebotransport::ML_Pose&
ML_Joints::_Internal::pose(const ML_Joints* msg) {
  return *msg->pose_;
}
const ::mw::internal::robotics::gazebotransport::ML_Axis&
ML_Joints::_Internal::axis1(const ML_Joints* msg) {
  return *msg->axis1_;
}
const ::mw::internal::robotics::gazebotransport::ML_Axis&
ML_Joints::_Internal::axis2(const ML_Joints* msg) {
  return *msg->axis2_;
}
ML_Joints::ML_Joints(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.ML_Joints)
}
ML_Joints::ML_Joints(const ML_Joints& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  if (from._internal_has_pose()) {
    pose_ = new ::mw::internal::robotics::gazebotransport::ML_Pose(*from.pose_);
  } else {
    pose_ = nullptr;
  }
  if (from._internal_has_axis1()) {
    axis1_ = new ::mw::internal::robotics::gazebotransport::ML_Axis(*from.axis1_);
  } else {
    axis1_ = nullptr;
  }
  if (from._internal_has_axis2()) {
    axis2_ = new ::mw::internal::robotics::gazebotransport::ML_Axis(*from.axis2_);
  } else {
    axis2_ = nullptr;
  }
  ::memcpy(&cfm_, &from.cfm_,
    static_cast<size_t>(reinterpret_cast<char*>(&dof_) -
    reinterpret_cast<char*>(&cfm_)) + sizeof(dof_));
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ML_Joints)
}

void ML_Joints::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ML_Joints_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&pose_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&dof_) -
      reinterpret_cast<char*>(&pose_)) + sizeof(dof_));
}

ML_Joints::~ML_Joints() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ML_Joints)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ML_Joints::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete pose_;
  if (this != internal_default_instance()) delete axis1_;
  if (this != internal_default_instance()) delete axis2_;
}

void ML_Joints::ArenaDtor(void* object) {
  ML_Joints* _this = reinterpret_cast< ML_Joints* >(object);
  (void)_this;
}
void ML_Joints::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ML_Joints::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ML_Joints& ML_Joints::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ML_Joints_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void ML_Joints::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ML_Joints)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(pose_ != nullptr);
      pose_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(axis1_ != nullptr);
      axis1_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(axis2_ != nullptr);
      axis2_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&cfm_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&suspension_erp_) -
        reinterpret_cast<char*>(&cfm_)) + sizeof(suspension_erp_));
  }
  dof_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ML_Joints::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.ML_Joints.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_pose(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mw.internal.robotics.gazebotransport.ML_Axis axis1 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_axis1(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mw.internal.robotics.gazebotransport.ML_Axis axis2 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_axis2(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional double cfm = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _Internal::set_has_cfm(&has_bits);
          cfm_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double fudge_factor = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 49)) {
          _Internal::set_has_fudge_factor(&has_bits);
          fudge_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double suspension_cfm = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 57)) {
          _Internal::set_has_suspension_cfm(&has_bits);
          suspension_cfm_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double suspension_erp = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 65)) {
          _Internal::set_has_suspension_erp(&has_bits);
          suspension_erp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional uint32 dof = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_dof(&has_bits);
          dof_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ML_Joints::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ML_Joints)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ML_Joints.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::pose(this), target, stream);
  }

  // optional .mw.internal.robotics.gazebotransport.ML_Axis axis1 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::axis1(this), target, stream);
  }

  // optional .mw.internal.robotics.gazebotransport.ML_Axis axis2 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::axis2(this), target, stream);
  }

  // optional double cfm = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_cfm(), target);
  }

  // optional double fudge_factor = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(6, this->_internal_fudge_factor(), target);
  }

  // optional double suspension_cfm = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(7, this->_internal_suspension_cfm(), target);
  }

  // optional double suspension_erp = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(8, this->_internal_suspension_erp(), target);
  }

  // optional uint32 dof = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(9, this->_internal_dof(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ML_Joints)
  return target;
}

size_t ML_Joints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ML_Joints)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *pose_);
    }

    // optional .mw.internal.robotics.gazebotransport.ML_Axis axis1 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *axis1_);
    }

    // optional .mw.internal.robotics.gazebotransport.ML_Axis axis2 = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *axis2_);
    }

    // optional double cfm = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double fudge_factor = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double suspension_cfm = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional double suspension_erp = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  // optional uint32 dof = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_dof());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ML_Joints::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ML_Joints)
  GOOGLE_DCHECK_NE(&from, this);
  const ML_Joints* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ML_Joints>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ML_Joints)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ML_Joints)
    MergeFrom(*source);
  }
}

void ML_Joints::MergeFrom(const ML_Joints& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ML_Joints)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_pose()->::mw::internal::robotics::gazebotransport::ML_Pose::MergeFrom(from._internal_pose());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_axis1()->::mw::internal::robotics::gazebotransport::ML_Axis::MergeFrom(from._internal_axis1());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_axis2()->::mw::internal::robotics::gazebotransport::ML_Axis::MergeFrom(from._internal_axis2());
    }
    if (cached_has_bits & 0x00000010u) {
      cfm_ = from.cfm_;
    }
    if (cached_has_bits & 0x00000020u) {
      fudge_factor_ = from.fudge_factor_;
    }
    if (cached_has_bits & 0x00000040u) {
      suspension_cfm_ = from.suspension_cfm_;
    }
    if (cached_has_bits & 0x00000080u) {
      suspension_erp_ = from.suspension_erp_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_dof(from._internal_dof());
  }
}

void ML_Joints::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ML_Joints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ML_Joints::CopyFrom(const ML_Joints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ML_Joints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ML_Joints::IsInitialized() const {
  return true;
}

void ML_Joints::InternalSwap(ML_Joints* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ML_Joints, dof_)
      + sizeof(ML_Joints::dof_)
      - PROTOBUF_FIELD_OFFSET(ML_Joints, pose_)>(
          reinterpret_cast<char*>(&pose_),
          reinterpret_cast<char*>(&other->pose_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ML_Joints::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Gazebomodel::InitAsDefaultInstance() {
  ::mw::internal::robotics::gazebotransport::_Gazebomodel_default_instance_._instance.get_mutable()->pose_ = const_cast< ::mw::internal::robotics::gazebotransport::ML_Pose*>(
      ::mw::internal::robotics::gazebotransport::ML_Pose::internal_default_instance());
}
class Gazebomodel::_Internal {
 public:
  using HasBits = decltype(std::declval<Gazebomodel>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mw::internal::robotics::gazebotransport::ML_Pose& pose(const Gazebomodel* msg);
  static void set_has_pose(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_enable_wind(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_self_collide(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_is_static(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::mw::internal::robotics::gazebotransport::ML_Pose&
Gazebomodel::_Internal::pose(const Gazebomodel* msg) {
  return *msg->pose_;
}
Gazebomodel::Gazebomodel(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  links_(arena),
  joints_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.Gazebomodel)
}
Gazebomodel::Gazebomodel(const Gazebomodel& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      links_(from.links_),
      joints_(from.joints_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  if (from._internal_has_pose()) {
    pose_ = new ::mw::internal::robotics::gazebotransport::ML_Pose(*from.pose_);
  } else {
    pose_ = nullptr;
  }
  ::memcpy(&enable_wind_, &from.enable_wind_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_static_) -
    reinterpret_cast<char*>(&enable_wind_)) + sizeof(is_static_));
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.Gazebomodel)
}

void Gazebomodel::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Gazebomodel_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&pose_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_static_) -
      reinterpret_cast<char*>(&pose_)) + sizeof(is_static_));
}

Gazebomodel::~Gazebomodel() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.Gazebomodel)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Gazebomodel::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete pose_;
}

void Gazebomodel::ArenaDtor(void* object) {
  Gazebomodel* _this = reinterpret_cast< Gazebomodel* >(object);
  (void)_this;
}
void Gazebomodel::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Gazebomodel::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Gazebomodel& Gazebomodel::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Gazebomodel_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void Gazebomodel::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.Gazebomodel)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  links_.Clear();
  joints_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(pose_ != nullptr);
      pose_->Clear();
    }
  }
  ::memset(&enable_wind_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_static_) -
      reinterpret_cast<char*>(&enable_wind_)) + sizeof(is_static_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Gazebomodel::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.Gazebomodel.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .mw.internal.robotics.gazebotransport.ML_Links links = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_links(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .mw.internal.robotics.gazebotransport.ML_Joints joints = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_joints(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_pose(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool enable_wind = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_enable_wind(&has_bits);
          enable_wind_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool self_collide = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_self_collide(&has_bits);
          self_collide_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_static = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_is_static(&has_bits);
          is_static_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Gazebomodel::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.Gazebomodel)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.Gazebomodel.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated .mw.internal.robotics.gazebotransport.ML_Links links = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_links_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_links(i), target, stream);
  }

  // repeated .mw.internal.robotics.gazebotransport.ML_Joints joints = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_joints_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_joints(i), target, stream);
  }

  // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::pose(this), target, stream);
  }

  // optional bool enable_wind = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_enable_wind(), target);
  }

  // optional bool self_collide = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_self_collide(), target);
  }

  // optional bool is_static = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_is_static(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.Gazebomodel)
  return target;
}

size_t Gazebomodel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.Gazebomodel)
  size_t total_size = 0;

  // required string name = 1;
  if (_internal_has_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mw.internal.robotics.gazebotransport.ML_Links links = 2;
  total_size += 1UL * this->_internal_links_size();
  for (const auto& msg : this->links_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .mw.internal.robotics.gazebotransport.ML_Joints joints = 3;
  total_size += 1UL * this->_internal_joints_size();
  for (const auto& msg : this->joints_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001eu) {
    // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *pose_);
    }

    // optional bool enable_wind = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool self_collide = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool is_static = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Gazebomodel::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.Gazebomodel)
  GOOGLE_DCHECK_NE(&from, this);
  const Gazebomodel* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Gazebomodel>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.Gazebomodel)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.Gazebomodel)
    MergeFrom(*source);
  }
}

void Gazebomodel::MergeFrom(const Gazebomodel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.Gazebomodel)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  links_.MergeFrom(from.links_);
  joints_.MergeFrom(from.joints_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_pose()->::mw::internal::robotics::gazebotransport::ML_Pose::MergeFrom(from._internal_pose());
    }
    if (cached_has_bits & 0x00000004u) {
      enable_wind_ = from.enable_wind_;
    }
    if (cached_has_bits & 0x00000008u) {
      self_collide_ = from.self_collide_;
    }
    if (cached_has_bits & 0x00000010u) {
      is_static_ = from.is_static_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Gazebomodel::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.Gazebomodel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Gazebomodel::CopyFrom(const Gazebomodel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.Gazebomodel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Gazebomodel::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void Gazebomodel::InternalSwap(Gazebomodel* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  links_.InternalSwap(&other->links_);
  joints_.InternalSwap(&other->joints_);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Gazebomodel, is_static_)
      + sizeof(Gazebomodel::is_static_)
      - PROTOBUF_FIELD_OFFSET(Gazebomodel, pose_)>(
          reinterpret_cast<char*>(&pose_),
          reinterpret_cast<char*>(&other->pose_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Gazebomodel::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void GetGazeboModelParam::InitAsDefaultInstance() {
}
class GetGazeboModelParam::_Internal {
 public:
  using HasBits = decltype(std::declval<GetGazeboModelParam>()._has_bits_);
  static void set_has_model_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_link(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_link_joint_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

GetGazeboModelParam::GetGazeboModelParam(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
}
GetGazeboModelParam::GetGazeboModelParam(const GetGazeboModelParam& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_model_name()) {
    model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_model_name(),
      GetArena());
  }
  link_joint_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_link_joint_name()) {
    link_joint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_link_joint_name(),
      GetArena());
  }
  is_link_ = from.is_link_;
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
}

void GetGazeboModelParam::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_GetGazeboModelParam_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  link_joint_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  is_link_ = false;
}

GetGazeboModelParam::~GetGazeboModelParam() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void GetGazeboModelParam::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  model_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  link_joint_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GetGazeboModelParam::ArenaDtor(void* object) {
  GetGazeboModelParam* _this = reinterpret_cast< GetGazeboModelParam* >(object);
  (void)_this;
}
void GetGazeboModelParam::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetGazeboModelParam::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GetGazeboModelParam& GetGazeboModelParam::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_GetGazeboModelParam_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void GetGazeboModelParam::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      model_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      link_joint_name_.ClearNonDefaultToEmpty();
    }
  }
  is_link_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetGazeboModelParam::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string model_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_model_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_link = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_is_link(&has_bits);
          is_link_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string link_joint_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_link_joint_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GetGazeboModelParam::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string model_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_model_name().data(), static_cast<int>(this->_internal_model_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_model_name(), target);
  }

  // optional bool is_link = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_is_link(), target);
  }

  // optional string link_joint_name = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_link_joint_name().data(), static_cast<int>(this->_internal_link_joint_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_link_joint_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
  return target;
}

size_t GetGazeboModelParam::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
  size_t total_size = 0;

  // required string model_name = 1;
  if (_internal_has_model_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional string link_joint_name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_link_joint_name());
    }

    // optional bool is_link = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetGazeboModelParam::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
  GOOGLE_DCHECK_NE(&from, this);
  const GetGazeboModelParam* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<GetGazeboModelParam>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
    MergeFrom(*source);
  }
}

void GetGazeboModelParam::MergeFrom(const GetGazeboModelParam& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_model_name(from._internal_model_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_link_joint_name(from._internal_link_joint_name());
    }
    if (cached_has_bits & 0x00000004u) {
      is_link_ = from.is_link_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void GetGazeboModelParam::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetGazeboModelParam::CopyFrom(const GetGazeboModelParam& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetGazeboModelParam::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GetGazeboModelParam::InternalSwap(GetGazeboModelParam* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  model_name_.Swap(&other->model_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  link_joint_name_.Swap(&other->link_joint_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(is_link_, other->is_link_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetGazeboModelParam::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void GazeboModelSDF::InitAsDefaultInstance() {
}
class GazeboModelSDF::_Internal {
 public:
  using HasBits = decltype(std::declval<GazeboModelSDF>()._has_bits_);
  static void set_has_model_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sdf_string(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

GazeboModelSDF::GazeboModelSDF(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.GazeboModelSDF)
}
GazeboModelSDF::GazeboModelSDF(const GazeboModelSDF& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_model_name()) {
    model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_model_name(),
      GetArena());
  }
  sdf_string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_sdf_string()) {
    sdf_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_sdf_string(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.GazeboModelSDF)
}

void GazeboModelSDF::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_GazeboModelSDF_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  sdf_string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

GazeboModelSDF::~GazeboModelSDF() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.GazeboModelSDF)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void GazeboModelSDF::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  model_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  sdf_string_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GazeboModelSDF::ArenaDtor(void* object) {
  GazeboModelSDF* _this = reinterpret_cast< GazeboModelSDF* >(object);
  (void)_this;
}
void GazeboModelSDF::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GazeboModelSDF::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GazeboModelSDF& GazeboModelSDF::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_GazeboModelSDF_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void GazeboModelSDF::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.GazeboModelSDF)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      model_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      sdf_string_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GazeboModelSDF::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string model_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_model_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string sdf_string = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_sdf_string();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GazeboModelSDF::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.GazeboModelSDF)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string model_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_model_name().data(), static_cast<int>(this->_internal_model_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_model_name(), target);
  }

  // required string sdf_string = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sdf_string().data(), static_cast<int>(this->_internal_sdf_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_sdf_string(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.GazeboModelSDF)
  return target;
}

size_t GazeboModelSDF::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.GazeboModelSDF)
  size_t total_size = 0;

  if (_internal_has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());
  }

  if (_internal_has_sdf_string()) {
    // required string sdf_string = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sdf_string());
  }

  return total_size;
}
size_t GazeboModelSDF::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.GazeboModelSDF)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());

    // required string sdf_string = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sdf_string());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GazeboModelSDF::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.GazeboModelSDF)
  GOOGLE_DCHECK_NE(&from, this);
  const GazeboModelSDF* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<GazeboModelSDF>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.GazeboModelSDF)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.GazeboModelSDF)
    MergeFrom(*source);
  }
}

void GazeboModelSDF::MergeFrom(const GazeboModelSDF& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.GazeboModelSDF)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_model_name(from._internal_model_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_sdf_string(from._internal_sdf_string());
    }
  }
}

void GazeboModelSDF::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.GazeboModelSDF)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GazeboModelSDF::CopyFrom(const GazeboModelSDF& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.GazeboModelSDF)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GazeboModelSDF::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GazeboModelSDF::InternalSwap(GazeboModelSDF* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  model_name_.Swap(&other->model_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  sdf_string_.Swap(&other->sdf_string_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata GazeboModelSDF::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void GetGazeboModelSDF::InitAsDefaultInstance() {
}
class GetGazeboModelSDF::_Internal {
 public:
  using HasBits = decltype(std::declval<GetGazeboModelSDF>()._has_bits_);
  static void set_has_model_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

GetGazeboModelSDF::GetGazeboModelSDF(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
}
GetGazeboModelSDF::GetGazeboModelSDF(const GetGazeboModelSDF& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_model_name()) {
    model_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_model_name(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
}

void GetGazeboModelSDF::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_GetGazeboModelSDF_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  model_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

GetGazeboModelSDF::~GetGazeboModelSDF() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void GetGazeboModelSDF::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  model_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GetGazeboModelSDF::ArenaDtor(void* object) {
  GetGazeboModelSDF* _this = reinterpret_cast< GetGazeboModelSDF* >(object);
  (void)_this;
}
void GetGazeboModelSDF::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetGazeboModelSDF::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GetGazeboModelSDF& GetGazeboModelSDF::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_GetGazeboModelSDF_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto.base);
  return *internal_default_instance();
}


void GetGazeboModelSDF::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    model_name_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetGazeboModelSDF::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string model_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_model_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GetGazeboModelSDF::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string model_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_model_name().data(), static_cast<int>(this->_internal_model_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_model_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
  return target;
}

size_t GetGazeboModelSDF::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
  size_t total_size = 0;

  // required string model_name = 1;
  if (_internal_has_model_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_name());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetGazeboModelSDF::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
  GOOGLE_DCHECK_NE(&from, this);
  const GetGazeboModelSDF* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<GetGazeboModelSDF>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
    MergeFrom(*source);
  }
}

void GetGazeboModelSDF::MergeFrom(const GetGazeboModelSDF& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_model_name()) {
    _internal_set_model_name(from._internal_model_name());
  }
}

void GetGazeboModelSDF::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetGazeboModelSDF::CopyFrom(const GetGazeboModelSDF& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetGazeboModelSDF::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GetGazeboModelSDF::InternalSwap(GetGazeboModelSDF* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  model_name_.Swap(&other->model_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata GetGazeboModelSDF::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace gazebotransport
}  // namespace robotics
}  // namespace internal
}  // namespace mw
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::PluginVersion* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::PluginVersion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::PluginVersion >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::Time* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::Time >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::Time >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::PacketHeader* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::PacketHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::PacketHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::Packet* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::Packet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::Packet >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::StepSimulation* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::StepSimulation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::StepSimulation >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::ResetSimulation* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::ResetSimulation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::ResetSimulation >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::Image* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::Image >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::Image >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::RequestImage* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::RequestImage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::RequestImage >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::RequestCoSim* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::RequestCoSim >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::RequestCoSim >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::StopCoSim* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::StopCoSim >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::StopCoSim >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::Point* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::Point >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::Point >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::Quaternion* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::Quaternion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::Quaternion >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::Pose* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::Pose >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::Pose >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::StopSimulation* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::StopSimulation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::StopSimulation >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::LaserData* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::LaserData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::LaserData >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::RequestLaser* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::RequestLaser >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::RequestLaser >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::ImuData* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::ImuData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::ImuData >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::RequestImu* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::RequestImu >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::RequestImu >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::SubscribeImage* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::SubscribeImage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::SubscribeImage >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::SubscribeLaser* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::SubscribeLaser >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::SubscribeLaser >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::SubscribeImu* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::SubscribeImu >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::SubscribeImu >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::ApplyLinkWrench >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::ApplyLinkWrench >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::ApplyJointTorque* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::ApplyJointTorque >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::ApplyJointTorque >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::GetPose* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::GetPose >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::GetPose >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::GetTopicList* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::GetTopicList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::GetTopicList >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::TopicList* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::TopicList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::TopicList >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::GetModelInfo* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::GetModelInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::GetModelInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::ModelInfo_Model* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::ModelInfo_Model >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::ModelInfo_Model >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::ModelInfo* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::ModelInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::ModelInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::MaxStepSize* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::MaxStepSize >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::MaxStepSize >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::InitCustomPublisher* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::InitCustomPublisher >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::InitCustomPublisher >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::InitCustomSubscriber >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::InitCustomSubscriber >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::CustomMessageSupport* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::CustomMessageSupport >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::CustomMessageSupport >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::SetJointPosition* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::SetJointPosition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::SetJointPosition >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::SetJointVelocity* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::SetJointVelocity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::SetJointVelocity >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::GetJointState* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::GetJointState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::GetJointState >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::Axis* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::Axis >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::Axis >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::JointState* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::JointState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::JointState >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::SetLinkWorldPose >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::SetLinkWorldPose >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::GetLinkState* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::GetLinkState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::GetLinkState >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::LinkState* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::LinkState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::LinkState >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::ML_Cord* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::ML_Cord >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::ML_Cord >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::ML_Point* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::ML_Point >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::ML_Point >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::ML_Quat* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::ML_Quat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::ML_Quat >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::ML_Pose* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::ML_Pose >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::ML_Pose >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::ML_Inertial* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::ML_Inertial >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::ML_Inertial >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::ML_Links* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::ML_Links >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::ML_Links >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::ML_Axis* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::ML_Axis >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::ML_Axis >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::ML_Joints* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::ML_Joints >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::ML_Joints >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::Gazebomodel* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::Gazebomodel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::Gazebomodel >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::GetGazeboModelParam* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::GetGazeboModelParam >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::GetGazeboModelParam >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::GazeboModelSDF* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::GazeboModelSDF >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::GazeboModelSDF >(arena);
}
template<> PROTOBUF_NOINLINE ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* Arena::CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
